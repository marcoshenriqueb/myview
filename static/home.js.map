{"version":3,"sources":["webpack:///webpack/bootstrap c81d600910e1d9f033f1","webpack:///./~/inputmask/dist/inputmask/dependencyLibs/inputmask.dependencyLib.js","webpack:///./~/inputmask/dist/inputmask/inputmask.js","webpack:///(webpack)/buildin/global.js","webpack:///./~/inputmask/dist/inputmask/global/document.js","webpack:///./~/inputmask/dist/inputmask/global/window.js","webpack:///./home/static/home/js/paraxify.js","webpack:///./~/@vimeo/player/dist/player.js","webpack:///./home/static/home/css/paraxify.css","webpack:///./home/static/home/styl/home.styl","webpack:///./~/normalize.css/normalize.css","webpack:///./~/inputmask/index.js","webpack:///./~/shufflejs/dist/shuffle.js","webpack:///./home/static/home/js/home.js","webpack:///./~/inputmask/dist/inputmask/inputmask.date.extensions.js","webpack:///./~/inputmask/dist/inputmask/inputmask.extensions.js","webpack:///./~/inputmask/dist/inputmask/inputmask.numeric.extensions.js","webpack:///./~/inputmask/dist/inputmask/inputmask.phone.extensions.js","webpack:///./~/process/browser.js","webpack:///./~/setimmediate/setImmediate.js","webpack:///./~/timers-browserify/main.js"],"names":[],"mappings":"0JACA,cAMA,MACA,eAGA,mBACA,GACA,EACA,KAIA,mDAGA,KAGA,OACA,OAIA,IAzBA,iBA4BA,MAGA,iBAA2C,OAAc,EAGzD,qBACA,OACA,8BACA,CACA,gBACA,kBAGA,GAGA,iBACA,YACA,qBAA2B,UAA0B,UACrD,YAAiC,OAAe,EAChD,mBACA,GACA,CAGA,mBAAsD,+CAA+D,EAGrH,MAGA,wCChEA,QAMA,EAEA,YACA,kFACA,GAAC,eACD,gBACA,iBAA0C,SAAS,wBACnD,UACA,CACA,cACA,oGACA,EACA,cACA,uBACA,MACA,cACA,kCACA,uGACA,GACA,cACA,oBACA,QACA,cACA,qJACA,oEAAsG,2BACtG,EACA,QAA4B,qFAAuG,MAA6B,uCAChK,iCACA,iBACA,0EAA+I,MAAuB,WACtK,sCACA,uBACA,mFACA,UAA+D,oBAC/D,oBACA,EAAiB,IACjB,EACA,OACA,KACA,mBACA,0EAA+I,MAAuB,oDACtK,IACA,yDAAqH,SAAa,aAClI,IACA,4BACA,yBACmB,iBACnB,IACA,4BACA,iBACmB,wFACnB,aAAyD,SAAa,aACtE,IACA,YACA,oBACmB,iBACnB,IACA,YACA,WAEA,UACA,EAAa,qBAA+D,SAAgB,sBAC5F,yGACA,oEAAwJ,0CACxJ,EAAa,8BACb,eACA,KACA,qBACA,sGAA6L,MAAuB,WACpN,sCACA,qCACA,OACA,UACA,cACA,8CAEA,yBACA,IACA,qBACA,EAAyB,SACzB,6EACA,OACA,uCACA,EAAqB,+DACrB,gCACA,EAAiB,wFACjB,yCAAuF,YAAoC,8BAAwD,sBAAiB,YAAyC,8BAC7O,UACA,OACA,KACA,qBACA,qBACA,aACA,uBAEA,WACK,2BACL,sBACA,EAAK,oBAAoC,iDACzC,uBACA,EAAK,+CACL,2GACA,iBAAK,qBACL,iBAAqF,iCACrF,wDACA,kDACA,qBAA6C,OAAY,+CACzD,sEACA,kDACA,6CACA,UACA,EAAK,sBACL,OACA,sBAA2D,iCAAuD,QAAO,6CACzH,YACA,EAAK,qBACL,2BACA,iBAA2B,EAAW,kCAAiE,+CACvG,mBACA,EAAK,wBACL,wCACA,qBAAyC,uBACzC,EAAK,yBACL,MACA,UACA,cACA,aAEA,OACA,uBACA,WACA,EAAS,SACT,6EACA,OAAS,0CACT,QACA,EAAK,sCACL,CAAC,oBC9ID,QAMA,EAEA,YACA,uFACA,GAAC,mBACD,kBACA,8CAC6C,4CAC7C,qCACA,qCAA2D,2DAC3D,mBAAwC,iEACxC,kBAJA,EAKA,kBACA,2BACA,kCACA,iEACA,IACA,EACA,gBACA,kBACA,QACA,gDACA,mHACA,+CACA,2CACA,4GACA,GACA,wEACA,oDACA,MACA,wCACA,GACA,0BACA,SACA,EACA,kBACA,aACa,qCACb,cAA+C,8CAAqF,4BACpI,IACA,CACA,+DACA,oBACA,qCACA,+BACA,wEACA,oEACA,+CACA,IAAiB,mCACjB,EACA,eACA,KACA,oGACA,EACA,kBACA,qBACA,QACA,oBACA,kDACA,GACA,yDACA,+GACA,4KACA,MACa,4DACb,2DACA,EACA,EACA,aACA,OACA,EACA,eACA,QACA,6BAAmF,uBACnF,EACA,qBACA,4BACA,0CACA,MACA,iBACA,2DACA,gBACA,IACA,kCACA,EACA,wBACA,wBAAqE,6BACrE,wBAAqD,MAAe,sGACpE,2BACA,kCACA,0DACA,uBACA,CACA,QACA,CAAa,4EACb,qBAAoD,MAA6B,KACjF,MAAsB,yBAAoD,GAC1E,4DAAuH,SACvH,UACA,sFAAuL,QACvL,qEACA,yFACA,oCACA,IACA,CACA,IACA,EACA,kBACA,sIAAyQ,0BACzQ,sWAA6hB,YAC7hB,OACA,GACA,qBACA,wDACA,IACA,eACA,4DACA,EACA,kBACA,2BAAiE,QAAqB,mDACtF,KACA,EACA,KACA,OACA,GACA,qBACA,yBACA,sBACA,mBACA,4BACA,qDACA,8DACA,CAAyB,GACzB,EACA,sBACA,QACA,6HAAmP,KAAuB,8CAC1Q,gHACA,wDACA,sEACA,MACA,GAAyB,4DACzB,WACA,0KACA,+CACA,OACA,cACA,aACqB,MACrB,kBACA,EAqFA,8BApFA,+DACyB,yBACzB,QACA,yBACA,+CACA,WACA,EACA,CAAyB,yBACzB,uEACA,qCACA,yBACA,4CAAmG,iBAAqB,gBAAuC,oBAC/J,eAAiD,QAA0B,YAC3E,kDACA,uHACA,iCACA,mGACA,qCACA,0BACA,CACA,GACA,qBACA,iBAAsD,QAA2B,YACjF,mBACA,iCACA,cAA0D,WAAiC,OAC3F,cACA,kFACA,mBACA,kHACA,GAAiD,SACjD,iMACA,yHACA,wCACA,KACA,KACA,gCACA,KACA,EACA,KACA,mBACA,2FACA,EAAiD,yBACjD,iHACA,EAAiD,SACjD,kLACA,oJACA,0GACA,wCACA,KACA,KACA,CAEA,aACA,GACA,CACA,kDACA,iBACA,0DACA,qCACA,aAA2D,QAA0B,sFAErF,sBADA,2CAEA,gCACA,GACA,CAAiC,8BACjC,iCACA,OAA6B,2DAC7B,iBACA,CAAyB,+GAAqM,+DAAoF,GAClT,+CACA,gCACA,wEACA,YACA,2BACA,UACA,GACA,KACA,QACA,CACA,QACA,CACyB,oCACJ,CAErB,mCAAuF,gBAAiC,gDACxH,0CACA,yBACA,aACA,KACA,CACA,gBACA,yMACA,0CACA,0EACA,0CACA,IACA,OACA,GACA,oFACA,eACA,WACA,eAAyD,sDAAwH,MACjL,oCACA,IACA,qGACA,4EACA,+CAAwG,wBAAqB,QAAoB,oGACjJ,IAAyB,IACzB,EAAqB,wBACrB,GACA,gEACA,mBAAwD,cAA2B,0CAGnF,IAFA,MAGA,oCACA,OACA,IACA,iBACA,eACA,SACA,SACA,eAEA,IACA,cACa,gFACb,iBACA,KACA,aACA,2CACA,2CACA,cACA,OACA,gBACA,uDACA,QACA,MACA,sBACA,QACA,6BAA6E,mBAAqB,MAAS,kCAC3G,iBAAsC,MAAS,sDAC/C,yBACA,0CACA,WACA,CACA,sBACA,qBACA,YACA,cACA,cAEA,UACA,cACA,cAEA,UACA,qCACA,sFACA,cAEA,MACA,kCACA,mCACA,8DACA,GAEA,QACA,GACA,sBACA,0EAAsJ,WAAkB,uDACxK,cAA+B,QAAwB,yCACvD,KACA,EACA,KACA,OACA,GACA,4BACA,gBACA,oEACA,2EACA,EACA,sBACA,SACA,qCACA,2CAAoG,eAAa,sBACjH,8GACA,oBACA,QACqB,uCACrB,iBACA,+EACA,gBACA,6DACA,8CACA,WACA,EAAyB,kBACzB,YACA,EAAyB,yDACzB,8CACA,WACA,EAAyB,kBACzB,mBACA,GAAyB,yBACzB,WACA,mDACA,uCACA,KACA,sEACA,MACA,CAAyB,kDACzB,oEACA,KACA,mDACA,WAAkE,aAClE,gBACyB,2BACzB,EACA,CAAiB,GACjB,EACA,yBACA,yDACA,kBAA2D,iCAC3D,aAAiC,OAAU,kCAC3C,qCAAsE,KACtE,iDACA,wBAAqC,OAAU,QAC/C,WACA,yBAAmE,yIAA4K,KAC/O,0FAA6M,QAC7M,8CACA,cAAqD,6BACrD,2BACA,yCACA,OACA,CAA6B,4DAC7B,4CACA,OACA,KACA,QACA,KACA,4CAAoF,KACpF,WACA,CAAiB,uCAAwD,KACzE,kBACA,CACA,gBACA,eAA4C,6BAAiD,SAC7F,QACA,OAA4B,QAAgB,yGAC5C,kWACA,GACA,SACA,UACA,2CACA,8BAA6D,SAC7D,sGACA,YACA,8CACA,8DACA,6BACA,2BACA,4DACA,8BAuBA,UAEA,8FAzB8L,QAAe,kCAC7M,iBACA,2BACA,gDAA0H,MAAa,kDACvI,sCACA,oEACA,YAAuD,KAAS,QAChE,qGACA,+CACA,+BACA,IACA,KACA,kBACA,GACA,CAAqC,QAA0B,aAC/D,oCACqC,+DACrC,kBACA,EACA,CAA6B,8BAC7B,GACA,KACqB,CAIrB,4DACA,kBAAmI,kCACnI,sDAA2E,IAAc,8DACzF,oCACA,oEACA,SACA,EACA,WACA,aACA,iDACA,iEACA,2DACA,oDACA,mDACA,mBAA8C,QAAuB,YACrE,yBACA,uGACA,kCAA8F,KAC9F,kCACA,2DACA,sDACA,qCACA,gFACA,gFACA,YAAwD,aAA6C,6BACrG,sFACA,+BACA,qCACA,kBAAuE,EAAwB,aAC/F,WACA,6EACA,KACA,OACA,gCACA,gBACA,YAAiE,SAAgC,4EACjG,2CACA,EACA,cACA,mCAAiG,KACjG,GACA,CACA,CACA,EACA,OACA,GAAiB,0BACjB,KAEA,IACA,0DACA,mCACA,sCACA,WACA,mDACA,OACA,eACA,EACA,iDACA,gCAAyD,UACzD,EACA,mBACA,cACA,6DACA,qBACA,UACA,yDACA,EACA,QACA,CACA,mBACA,YACA,2BACA,WACA,+CAAyH,wFAAyJ,MAClR,OACA,GACA,mBACA,QACA,qBACA,SAAkB,0EAClB,iDAAkF,OAClF,OACA,GACA,gBACA,iEACA,KACA,4BACA,sCACA,iCACA,SACA,yBACA,WACA,2DACA,WACA,EACA,0BACA,YACA,CACA,sIACA,OACA,GAAa,6BACb,gBACA,UACA,sBACA,4GACA,4BACA,sCACA,cACA,wEAA8G,QAAkB,uLAChI,wIACA,OACA,WACA,GACA,8CACA,OACA,4BACA,mBACA,4GACA,EACA,iCACA,+CACA,2FACA,iDACA,cACA,IAAa,YACb,gCACA,WACA,oBACA,2CACA,8EACA,oCACA,2EACA,0CACA,eACA,EAAqB,iDACrB,kDACA,WACA,iEACA,kDACA,WACA,mDACA,8DACA,MACA,CACA,CACA,CAAa,MACb,QACA,yEACA,4EACA,KACA,CACA,gBACA,OACA,+BACA,qEACA,GACA,kBACA,oFACA,yDACA,gCACA,8CACA,wBACA,EACA,OACA,GACA,yBACA,gBACA,4DACA,uCAEA,IACA,EACA,IACA,iDACA,kFACA,uFACA,oFACA,kFACA,8BACA,UACA,WAEA,kEACA,+CACA,8JACA,0EACA,+DAAgG,0BAChG,+DACA,yBACA,mBACA,GACA,0FACA,+FACA,qBACA,YACA,gDACA,GAAiB,gEACjB,8DACA,kBACA,OACA,OAEA,IACA,CACA,gBACA,iCAAoH,0CACpH,qCAA+B,QAAqB,0BACpD,0CAAiF,KACjF,6DACA,YAA8B,oUAA+f,aAC7hB,eACA,GACA,2BACa,GACb,EACA,gBACA,oDAAkJ,+OAAoX,MACtgB,UAAkB,sEAAgJ,2BAClK,0BACA,EACA,gBACA,sDACA,2BACA,gCACA,uFACA,KACA,aAA+B,SAAU,GACzC,iBACA,kIACA,KACA,EACA,KAEA,CACA,OACA,GACA,4BACA,6GACA,eACA,WACA,6BACA,EACA,kFACA,6QACA,8FACA,mDACA,iBACA,wCAAuH,+CAAkF,OAAc,MACvN,8BACA,OACA,qEACA,iHACA,SACA,EAEA,6BAAmG,IAAwB,aAC3H,oBACA,qFACA,EAAqB,mCAAmD,KACxE,GACA,CACA,uBACA,2BAAgE,+BAChE,oBAAuC,sCAAkF,OACzH,GACA,gBACA,gBACA,wBACA,iFACA,uEACA,iFACA,oFACA,uCACA,oBAA0D,WAAiB,QAC3E,wDACA,gCACA,iEACA,GACA,KACA,OACA,WACA,+BACA,EACA,cACA,kDACA,sLACA,6JACA,uFACA,+DACA,gCACA,WACA,kFACA,iEACA,oGACA,2DACA,mGACA,wCACA,8EACA,MACA,IAAa,gCACb,uDACA,IAAa,kCACb,sDACA,IACA,GAAiB,EACjB,EACA,EACA,sBACA,cACA,qEACA,4BACA,+BACA,WACA,gDACA,OACA,OAEA,mBACA,YACA,aACA,aACA,6CACA,+IACA,wEACA,0IACA,qBACqB,4DACrB,GACA,cACA,EACA,CACA,6BACA,6DACA,sBACA,oBACA,+CACA,oBACA,kDACA,KAAqB,KACrB,sLACA,WACA,UACA,kCACA,iBAEA,UACA,oBACA,EAEA,UACA,+BACA,qBACA,EAEA,UACA,gBACA,gBACA,sCACA,aACA,GAAqC,MACrC,CAEA,uBACA,qEACA,EACA,IACA,gBACA,CACA,mFACA,sDACA,uCACA,qBACA,sCACA,IACA,8DACA,gCACA,MAA+C,CAAjB,YAC9B,WACA,yDACA,wCACA,4BACA,GACA,EACA,CACS,MACT,0BACA,0CACA,uIACA,oDACA,mCAA2E,oCAC3E,aACA,EAAiB,qGACjB,6FAAwK,iEACxK,IACA,2BACA,qDACA,uCACA,EAAiB,mKAEjB,+KACA,8EACA,oDACA,yJACA,WACA,aACA,MAAiB,+CACjB,WACA,iCACA,EAAiB,kGACjB,QAXA,0HAYA,WACA,wCACA,mDACA,0IACA,yBACA,YACA,SAAiB,OACjB,QACA,2EACA,cACA,OACA,OACqB,kCACrB,2BACA,kBACA,yDACA,uDACA,iCACA,EAAqB,kCACrB,QACA,6DACA,kCACA,yBACA,WAAyB,EACzB,EACA,8DACA,IACA,EACA,CACA,yBACA,kFACA,+CACA,wDACA,uEACA,4DACA,wBACA,mFAA6J,OAC7J,wDACA,+CACA,EACA,QACA,oCACA,8CACA,yBACA,GACA,kEACA,0CACA,8CACA,gBACA,iCACA,6BACA,kCACA,WACA,oEACA,qDACA,iEACA,oBACA,+FACA,QACA,CACA,mEACA,MACA,iCACA,qBACA,oBACA,mIACA,IACA,CACA,CACA,gDACA,0HACA,uBACA,4DAAyI,0CAAwE,kBACjN,gFACA,mDACA,sEACA,mCAA0G,WAC1G,MAAsC,kCAAmE,mBACzG,qBACA,wCACA,GACA,qCACA,4BACA,OACA,GAA6B,EAC7B,GAAyB,+CACzB,WAAqB,6DACrB,OACA,gBACA,CACA,0BACA,8BACA,yCACA,2DACA,gDACA,kIACA,GACA,yBACA,6BACA,4IACA,6EACA,mDACA,GACA,4BACA,QACA,2DACA,qCACA,gGACA,UACA,IACA,CACA,4BACA,gBACA,sBACA,YACA,oDACA,qBACA,gCACA,iBACA,yDACA,SACA,CACA,CACA,CACA,QACA,CACA,QACA,0BACA,yBACA,WACA,2CACA,gCACA,0BACA,OAEA,UACA,6BACA,gCACA,wCACA,IACA,KAEA,CACA,0CACA,0CAAyK,SACzK,uEACA,4FACA,WACA,gBACA,GACA,OACA,GAEA,EACA,CAAiB,EACjB,EACA,0BACA,QACA,0BACA,YACA,KAAiB,EACjB,EACA,uBACA,sJACA,wDACA,iEACA,uCACA,yDACA,UACA,wBACA,mBACA,qBACA,yCACA,gFACA,wCACA,YACA,aAAqB,8DACrB,0DACA,eACA,UACA,CACA,4BACA,QACA,oGACA,KACA,wBACA,oKACA,gFACA,wBACA,OACA,KAAiB,EACjB,GACA,uBACA,mDACA,YACA,WAAiB,EACjB,EAEA,oCACA,YACA,+BAEA,UACA,kDACA,0EACA,2FACA,OAEA,QACA,oBACA,QACA,0BACA,wIACA,uCACA,wBACA,2DACA,IAAqB,SACrB,qCACA,cACA,mPACA,KACA,gBACA,kDACA,WACA,QACA,+BACA,4BACA,oCACA,8EACA,WACA,SAGA,mGACA,4BACA,+CACA,KACA,OACA,iBACqC,yCACrC,aACA,WAAqC,iBACrC,kBACA,EAAqC,mCACrC,KACA,OACA,iBAEA,IAAiC,gFACjC,qEACA,gCACA,wDACA,EACA,oCACA,+EACA,GAA6B,wCAC7B,kFACA,GAA6B,wBAC7B,aACA,KAA6B,iBAC7B,YACA,EAA6B,cAC7B,yEACA,0EACA,WACA,KAAqC,0EACrC,oBACA,EACA,iBACA,iBACA,iBACA,qDACA,0BACA,+EACA,EACA,WACA,GACA,qBACA,UACA,oDACA,YACA,EACA,kBAEA,EACA,CAA6B,uBAC7B,iCACA,UACA,6DACA,WACA,EAA6B,EAC7B,IACA,CAAqB,MACrB,EAAiB,KACjB,oDACA,gGACA,0DACA,wDACA,sEACA,mEACA,4FACA,sEACA,kEACA,8DACA,uEACA,4DACA,mFACA,uEACA,mDACA,2EACA,mHACA,sIACA,2DACA,iBACA,uDACA,qEACA,8CACA,KACA,CAAa,EACb,IAEA,UACA,mGACA,8CACA,oDACA,yBACA,QACiB,iBACJ,iDAEb,QACA,0FACA,yCAA0G,aAA4B,SACtI,0DAEA,QACA,+BAEA,QACA,uBACA,wFACA,WACA,yLACA,kBACA,4BACA,yBACiB,yHACjB,+EAEA,GAEA,OACA,uCACA,wBACA,4CACA,+BACA,CAAiB,GACjB,EACA,UAEA,UACA,oHACA,qBACA,eACA,0BACA,aACA,mBACA,OACA,QAEA,sBACA,OACA,QAEA,iBACA,OACA,QAEA,sBACA,eACA,UACA,WACA,kBACA,oBACA,iBACA,YACA,UACA,cACA,sBACA,wBACA,cACA,mBACA,QACA,iBACA,kBACA,gCACA,yDACA,CACA,gBACA,cACA,sBACA,mBACA,oBACA,+BACA,kBACA,cACA,gBACA,aACA,8BACA,iBACA,cACA,yBACA,cACA,EACA,4CACA,4HACA,wBACA,mBACA,oBACA,4BACA,cACA,YACA,kBACA,mBACA,uBACA,aACA,eACA,sBACA,eAEA,eACA,GACA,WACA,oBACA,mBAEA,OACA,WACA,6DACA,mBAEA,SACA,WACA,gEAGA,IACA,WACA,8BACA,oBACA,iBACA,wIACA,SACA,GACA,oGACA,wCACA,wBACA,2CACA,kBAA2C,MAAoB,MAC/D,aACA,iCACA,KACA,GACA,KAEA,4CACA,KACA,IACA,aACA,yCACA,KACA,GACA,KAEA,KACA,EACA,yBACA,CACA,OACA,0EACA,6CACA,iBAAgD,OAChD,sBAAsE,sBACtE,2BACA,mFACA,gGAAyI,OACzI,4EACA,mDACA,QAEA,SAAa,gCACb,IACA,sBACA,qFACA,iDACA,EACA,2BACA,oDACA,0BACA,QACA,sBAEA,GACA,mBACA,oBACA,QAEA,UACA,yBACA,oDACA,0BACA,QAEA,gBACA,2BACA,kBACA,UACA,uBACA,oDACA,0BACA,QAEA,cACA,wBACA,oDACA,0BACA,QAEA,eACA,qBACA,oDACA,0BACA,QACA,gBAEA,GACA,sBACA,oDACA,0BACA,QACA,eACA,WAEA,GACA,6BACA,wBACA,iFACA,yEACA,kBACA,KACA,MAEA,EACA,qBACA,sBACA,+BACA,yDACA,+BACA,gBACA,iBACA,2CACA,UACA,SACA,eACA,YACiB,wCACjB,8CACA,IACA,iBACA,iBACA,yDACA,UACA,mCACA,4CACA,eAEA,IAAiB,OAAgB,MACjC,qEACA,eACA,iDAAwI,QAAyB,iBACjK,iDACA,qCACA,wEACA,WACA,EACA,sBACA,iBACA,iEACA,cACA,gCACA,kBACA,sBAC6B,sBAC7B,EACA,0BACA,sGACA,cACA,SACA,qBACA,2BACA,iEACA,cACA,gCACA,kBACA,sBAEA,IAAqB,+BACrB,IACA,iBACA,iBACA,yDACA,UACA,mCACA,4CACA,eACqB,SACrB,CACA,CACA,eACA,kDACA,sBACA,gFACA,wEACA,SACA,GACA,EACA,aACA,MACA,kBAQA,iCAPA,kBACA,MACA,iBAA0C,eAAkC,mCAC5E,8BACA,sCACA,EACiB,CAEjB,eACA,qCACA,sDACA,iBACA,+EACA,mBACA,qDACA,GACA,uDACA,wMACA,OACA,EAAqB,aACrB,sBACA,OACA,GACA,QAA+J,oEAAqO,uOACpY,2EAA2G,0BAAsE,IACjL,qCACA,QACA,MACA,QAEA,UACA,QACA,MAA0B,MAE1B,WAA2C,yBAC3C,WACA,oBACA,IAEA,4BACA,uBACA,uCAUA,cATA,6BAQmE,4CAPnE,kBACA,MACA,iBAA8C,eAAkC,mCAChF,iCACA,8BACA,sCACA,EACqB,CAGrB,4BACA,wBACA,IAEA,yBACA,qBACA,IAEA,8BACA,0BACA,eAAsC,QACtC,iHACA,2DACA,KACA,OACqB,gBACrB,wBACA,4DACA,4BACA,GAAqB,sGACrB,uCACA,uCACA,IAEA,aACA,gCACA,gBACA,qCACA,6FACA,KAAqB,mBACrB,gCAA2E,mCAC3E,gEACA,0BACA,cACA,gBACA,iCACA,GACA,CAEA,MACA,QAEA,KACA,MAAwC,CAAtB,uCAClB,8CACA,yCACA,EACK,+BACL,kCACA,EAAK,iCACL,qCACA,EAAK,6BACL,iCACA,EAAK,0BACL,sBACA,EAAK,wBACL,2BACA,EAAK,yBACL,qBACA,EAAK,sBACL,uBACA,0BACA,QACA,EAAK,2BAEL,yHACA,OAAK,YACL,KACA,aACA,mBACA,cACA,SACA,YACA,gBACA,iBACA,WACA,UACA,QACA,OACA,SACA,UACA,QACA,UACA,QACA,QACA,cACA,mBACA,kBACA,iBACA,oBACA,oBACA,cACA,WACA,UACA,UACA,SACA,SACA,OACA,KACA,WACA,KACK,IACL,CAAC,gBCzmDD,GAGA,aACA,OACA,KAAC,IAED,GAEA,0CACA,OAAC,SAED,CACA,4BACA,OAI4C,CAE5C,6BCpBA,GAQA,eACA,OACA,SAAC,yC,qBCVD,GAQA,eACA,OACA,OAAC,yC,eCJD,CACA,cACA,CACA,gBACA,kBACA,iBACA,WACA,IACA,IACA,EACA,KACA,OACA,iBACA,uBACA,OACA,QAEA,GACA,oBAEA,6BACA,2CAEA,GACA,MAEA,mDACA,wDACO,kCACP,6BAEA,wBAEA,8DACA,eACA,kBACA,KACA,cACA,kBACA,SACA,cACA,MACA,sCACA,wHACA,QACA,kBAEA,4BACA,kBACA,qBAEA,KAEA,SACA,UACA,kBACA,MACA,8BACA,MACA,UAAS,OACT,2BACA,MACA,QAAS,OACT,KACA,oBACA,OACA,MACA,KACA,wCACA,iBACA,4BACA,mBACA,oCACA,qBACA,2GAEA,oBACA,mBACA,4BAGW,gBACX,mBAMA,8DAEA,eAPA,qBACA,2FAGA,qCAIA,+BACA,KACA,CACA,sBACA,kDAIA,YACA,qBACA,OACA,YACA,kEAIA,YAFA,cAGA,MACA,oBACA,sFACA,8CACA,kBACA,KACA,+CAEA,uBAEA,OAEA,mDACA,KAEA,GAEA,WACA,EACA,aACA,CAAC,sCCtID,eACA,eACA,WAGA,GAAC,kBAAqB,cAetB,iBACA,WAAkB,CAAc,iCAChC,OAEA,CAgmBA,oBACA,iBAEA,kBACA,SAGA,oBACA,qBACA,GASA,CACA,iBACA,iBACA,uBACA,OAUA,CACA,oBACA,iBAEA,oBACA,IAIA,aACA,GAMA,UALA,wBAEA,6BAKA,WACA,yBAGA,oBACA,YACA,iBAQA,CACA,iBACA,aAEA,OACA,YAGA,mBACA,uBACA,IACA,EASA,CACA,iBACA,cAEA,aACA,aACA,GAaA,CACA,iBACA,OACA,kCAGA,8DACA,EAQA,CACA,cACA,6BACA,WAUA,CACA,cAEA,6DACA,EAQA,CACA,cACA,gEAEA,GASA,CACA,YACA,4DAEA,YACA,SACA,WAEA,OACA,mBAGA,oHACA,+BAGA,QACA,8BAGA,aACA,mCAGA,mEACA,iCAMA,CAUA,cACA,4DAEA,qCACA,sCAEA,eACA,4BAGA,IACA,EAAK,EACL,GASA,CACA,cACA,4DAEA,wCACA,OACA,oCAGA,qGAEA,iBACA,sBACA,2CAIA,6DACA,8BAEA,2BACA,IACA,gBAIA,qCAHA,6BAIA,gBAIA,qCAHA,iCAIA,sBACA,iBACA,GAAa,UACb,IACA,GACA,CAEA,uBACA,qCACA,2EACA,KAEA,KACA,MACA,EASA,CACA,iBACA,WAEA,SACA,uBAGA,kCACA,yEAGA,wCACA,2BAEA,qBACA,qDAEA,yBACA,SAQA,CAyCA,cACA,OACA,oCAGA,KACA,EAUA,CACA,oBACA,uDAIA,oBACA,QAGA,IACA,uBAIA,mFACA,cACA,0BAGA,gDACA,QASA,CACA,iBACA,MACA,OACA,OAEA,eACA,uBACA,qBAEA,+BACA,0BACA,yBAEA,eACA,wBACA,GACA,EAEA,qBACA,aACA,IAAK,mBACL,gBAEA,QACA,aACA,UAEA,MAEA,wBACA,IACA,IACA,sBAIA,uBAHA,eAIA,GAAS,UAET,CACA,CACA,EAEA,CAEA,iBAAiD,mBAA0C,yBAA4D,oCAEvJ,CApiCA,MACA,qFAEA,QACA,kBACA,iEAEA,gHAWA,aACA,CAGA,+BAsFA,gBACA,8CAEA,cACA,gBACA,wBAGA,oBACA,YAPA,GAUA,OACA,kBACA,KAKA,oBACA,gBAEA,GACA,EAGA,gBAGA,8BAEA,6BACA,mBACA,GAAO,EACP,KAGA,gBACA,iBACA,2BACA,0BAEA,iCACA,cACA,IAGA,OACA,EAEA,gBACA,kCACA,UAEA,mBACA,yDAEA,yEAAsD,wBAA8B,yBACpF,aACA,EAEA,gBACA,kCACA,GAEA,gBACA,gCACA,GAGA,mBACA,6EACA,GACA,IAGA,gBACA,wCACA,IACA,IAEA,cACA,4CACA,CAGA,cAKA,0BACA,QAEA,sBASA,IACA,QACA,qBACA,IACA,gBACA,WAEA,GADA,oBAEA,iCACA,OAEA,OACA,+BAEA,IAAgB,eAChB,GAEA,EAEA,cACA,qBACA,MAEA,mBACA,CACW,gBAAX,eACA,UACA,eACA,yCACA,KACA,CACA,eAzNA,iCACA,+BACA,EAGA,EANA,GAOA,4CAEA,UAEA,SAEA,OAEA,OAEA,OAIA,0FACA,iBAEA,UAGA,OAEA,OAEA,OAEA,GAEA,eAwIA,0BACA,MAEA,SAzIA,GAEA,kBA4IA,qCACA,QAEA,UA7IA,SAIA,uFACA,iBAEA,KAEA,OAEA,YAEA,SAEA,QAEA,UAEA,GAEA,kBAyHA,uCACA,QAEA,UAxHA,MACA,4CAEA,UAEA,OAEA,SAEA,OAQA,QAuIC,yBACD,SAEA,oBACA,+EAAoG,cAAmB,GAAE,cAAmB,qGAA8H,GAK1Q,EAEA,mBAEA,gBACA,SACA,wBAMA,IAAC,iDAED,CAEA,+BA2DA,WACA,IACA,cAEA,OAGA,gBACA,8CAGA,IAFA,mCAGA,wBAEA,6BACA,EAEA,cACA,YAAiB,gBAAuB,OACxC,qFAEA,uBACA,CAKA,sBACA,QACA,MACA,CACA,qBAEA,SACA,WAEA,sBAGA,aACA,4BACK,+BACL,8BAEA,mBAGA,IAAG,UACH,WACA,GACA,CAEA,gBACA,QAIA,KAHA,UAOA,cAGA,gBACA,YAGA,QACA,QACA,kBACA,eACA,OACA,sBACA,aACA,UAAO,YACP,aACA,UACA,EAAM,UACN,YACA,GACA,CAEA,WACA,YACA,EACA,yBAGA,IAAG,UACH,oBACA,GACA,EAEA,gBACA,QAGA,QAIA,eAGA,gBACA,YAGA,YACA,YACA,EACA,yBAEA,IAEA,yBACA,YAAmB,QAAkB,OACrC,kBACA,qCACA,OACA,GAAK,EACL,GAAI,GAEJ,GAEA,gBACA,UACA,QACA,YAEA,gBACA,cACA,cACA,OACA,kBACA,sBACA,EAEA,gBACA,IACA,sCAGA,qBACA,iCAKA,8BAEA,gBAEA,+BACA,QACA,gCACA,kCAKA,0DACA,2BACA,sCAGA,6BACA,aACA,EACA,iBAEA,IACA,oBAGA,OACA,OACA,4BACA,yBACA,GAEA,KACA,4BACA,YACA,GAAI,cACJ,YACA,GACA,EAAG,UACH,YACA,GACA,CAEA,yBAxPA,kCAKA,uBAJA,UACA,GAAE,EALF,GACA,GACA,MAOA,QAA0B,kBAC1B,gCACA,oCACA,OACA,GACA,yBAEA,SACA,CAAE,UACF,sBACA,eACA,GACA,EACA,CAGA,cACA,mBAGA,SACA,aACA,iBACA,EAEA,WANA,SAOA,oBACA,cACA,IACA,WAEA,MAEA,MACA,UACA,EACA,kBACA,QACA,oBAEA,GACA,kBACA,YAEA,IAEA,EAEA,WAkMsC,oBAItC,2BAGA,mBAGA,kCACA,QAIA,uEACA,eAGA,yBACA,2BACA,sCAGA,qBACA,GACA,EAEA,8BACA,gCACA,2BACA,sCAGA,qBACA,GACA,EAEA,2BACA,QAGA,WACA,8BAGA,iBAGA,kCACA,2BACA,sCAGA,4BACA,gBACA,OAEA,0BACA,QACA,UACA,OAEA,GAAI,EACJ,GACA,uBApBA,gBAsBA,4BACA,QAGA,WACA,oDAIA,2BACA,sCAGA,0CACA,IACA,GAAI,EACJ,GACA,uBATA,gBAWA,GACA,EACA,EAMA,QAWA,SAqMA,kJA2OgC,mBAA2C,YAAgB,WAAkB,OAAO,WAA2B,qBAAwD,kBAAgC,kCAAuD,6CAA6D,GAAE,0BAAyD,4BAAqE,cAA6D,IAAoB,EAAG,CAAE,SAKjjB,eAEA,sBAUA,gBACA,QAEA,4DAEA,gBAGA,gCACA,+CACA,mBAGA,qFAIA,IACA,iDAIA,QACA,wBAIA,iFACA,yBAEA,UACA,QAEA,GAGA,uDACA,oBAIA,gEACA,iBAGA,iBACA,eAEA,gCACA,oBACA,gDAIA,QACA,+BAGA,oBACA,uBACA,qCAEA,8BACA,yCACA,YAIA,iBACA,IAEA,YACA,mDACa,cACb,4CAGA,mCACA,aACA,SAEA,8BACA,aACA,sBAEA,QACA,qBAEA,IACA,EAAiB,qBACjB,WACA,GACA,EACA,CAGA,sBACA,uBAIA,MACA,yCAGA,QACA,IAYA,cACA,KACA,+BACA,QAEA,4DAEA,kCAIA,kCACA,SACA,SACA,UAGA,aACA,GACA,EACA,EAUK,GACL,KACA,wBACA,QAEA,iCACA,gBAKA,iCACA,SACA,SACA,UAGA,UACA,GACA,EACA,EAWK,GACL,KACA,2BACA,QAEA,2CACA,YAEA,oBACA,8BAGA,kEACA,6BACA,SACA,SACA,UAGA,aACA,GACA,EACA,EACA,EAaK,GACL,KACA,0BACA,KACA,uBAGA,oCACA,uBAGA,yCACA,0CAGA,2DACA,IACA,sEAGA,CAGA,sBACA,GAaK,GACL,KACA,2BACA,KACA,uBAGA,uCACA,0CAGA,8DAGA,IACA,8DAGA,CAEA,EAmBK,GACL,KACA,8BACA,oCACA,GAkBK,GACL,KACA,wBACA,eACA,uBACA,GAqBK,GACL,KACA,gCACA,4DAEA,2CAAmD,cACnD,IAoBK,GACL,KACA,mCACA,yCACA,GAiCK,GACL,KACA,uCACA,KACA,uBAGA,sEACA,UACA,QAEA,IAeK,GACL,KACA,mCACA,wBACA,mBAeK,GACL,KACA,wBACA,wBACA,QAkBK,GACL,KACA,uBACA,wBACA,OAeK,GACL,KACA,yBACA,wBACA,SAiBK,GACL,KACA,+BACA,iBACA,YAuBK,GACL,KACA,iCACA,6BACA,GAeK,GACL,KACA,2BACA,iBACA,QAuBK,GACL,KACA,6BACA,yBACA,GAyBK,GACL,KACA,+BACA,iBACA,YAeK,GACL,KACA,iCACA,iBACA,cAwBK,GACL,KACA,mCACA,+BACA,GAiBK,GACL,KACA,8BACA,iBACA,WAgBK,GACL,KACA,2BACA,iBACA,QAeK,GACL,KACA,0BACA,iBACA,OAiBK,GACL,KACA,4BACA,wBACA,GAeK,GACL,KACA,4BACA,iBACA,SAeK,GACL,KACA,gCACA,iBACA,aAeK,GACL,KACA,oCACA,iBACA,iBAeK,GACL,KACA,6BACA,iBACA,UAeK,GACL,KACA,gCACA,iBACA,aAgBK,GACL,KACA,gCACA,iBACA,aAgBK,GACL,KACA,iCACA,iBACA,cAgBK,GACL,KACA,8BACA,iBACA,WAkBK,GACL,KACA,4BACA,iBACA,SAsBK,GACL,KACA,8BACA,0BACA,GAGA,KACA,EAAC,IAID,MA7kCA,WACA,+DAEA,8CAEA,qDACA,6BACA,8DAEA,GAEA,yBACA,IAEA,IACA,2CAGA,gBACA,SAEA,8BACA,aACA,GAAa,SACb,GAAS,UACT,IACA,GACA,CACA,EAWA,CAoiCA,GAIA,EAEA,gDCt/DA,aCAA,aCAA,mBCAA,MACA,MACA,MACA,EAMA,IAEA,+BCXA,4BACA,WAGA,GAAC,kBAAqB,CAMtB,aA4OA,aAMA,CACA,cACA,wBACA,CAEA,CAyLA,iBACA,0FAEA,cAGA,gBACA,kBAEA,mFAGA,wFAJG,kBAKH,EAQA,CACA,cACA,eAEA,WACA,KACA,sCACA,UACA,cACA,WACA,EAEA,OACA,IAkBA,iBACA,aACA,qBACA,IAEA,gBAIA,UACA,YAKA,KACA,iDAEA,IACA,SAGA,sBACA,qBAGA,0BACA,aACA,MAGA,4BACA,iBAGA,0BACA,iBAGA,EACA,CAIA,GACA,IAGA,OACA,YAGA,UACA,MAEA,CAIA,YACA,YACA,KACA,GAEA,cACA,YACA,mDACA,iBAKA,SAEA,iBACA,QACA,mBACA,uBACA,WACA,OAEA,IAEA,gCAEA,WAAqB,qBAErB,IACA,GAEA,cACA,4BACA,IAEA,cACA,4BACA,GASA,CACA,uBACA,WAKA,sCAEA,mBAIA,4BACA,GAOA,CACA,oBAEA,IACA,aAyBA,WAGA,UAAiB,SAA2B,GAE5C,8BAGA,YACA,GASA,CACA,iBACA,cACA,eAAyC,UAAS,GAClD,kCACA,SAIA,UACA,EAWA,CACA,cACA,eACA,eACA,gBACA,eACA,YACA,gBAEA,2BACA,eACA,YAGA,8CAKA,mBACA,UAAiB,KAAU,GAC3B,eAGA,SACA,IAEA,cACA,mCACA,IAEA,iBACA,QACA,gBAGA,CAxsBA,GACA,8BACA,aACA,wBAGA,iCAEA,4BAAC,UACD,sBACA,QACA,iBACA,CACA,WACA,cAGA,uCACA,iEACA,cACA,2CACA,SACA,SACA,+CACA,eACA,CACA,QAEA,GAAO,UACP,MACA,mBACA,CACA,EACA,EAEA,2BACA,6BACA,EAEA,cACA,cACA,WACA,mBACA,yBACA,sBACA,qBAEA,iBASA,EAEA,eACA,uBACA,8CACA,OAAiB,QAAkB,OACnC,mBAEA,SACA,QAEA,iGAMA,eACA,WAAkB,CAAc,iCAChC,OAEA,eAKA,gBA0DA,eARA,6CAXA,UACA,IAEA,gDACA,IACA,EAEA,GACA,OAEA,CAEA,GAxBA,YACA,IAEA,8CACA,SACA,GAEA,GACA,EAGA,EAxBA,YACA,WACA,kCACA,eACA,aAKA,OACA,EAEA,EAzBA,YACA,QAEA,UAAgB,QAAgB,OAChC,MACA,mCAIA,WACA,GAEA,CA+CA,GAEA,EAEA,UACA,QAEA,UAAmB,kBAAsB,OACzC,gCAEA,IACA,aACA,gBAKA,WACA,GAUA,yDA0BA,gBAsBA,uBACA,OAEA,WACA,UACA,SAIA,oBAEA,mBACA,IACA,CACA,CAnCA,KACA,0BACA,MAEA,SAIA,iBACA,wBAEA,YACA,gBAEA,iCACA,eACA,IAAG,iBACH,OACA,IAEA,sBA6BA,mBACA,yBAEA,oCAEA,eACA,mBACA,YAAmB,WAAkB,OACrC,WACA,qBACA,kBACA,kCACA,6CAEA,GAEA,0BACA,4BACA,cACA,IACA,EACA,CAEA,iBAOA,mBACA,SAEA,aACA,aACA,GAUA,oBACA,KACA,8BACA,+BACA,CAEA,KACA,EAEA,OACA,MACA,uBACA,uBACA,+BAGA,2BAEA,eACA,gBACA,SAEA,QACA,UACA,gBACA,QACA,YAEA,eACA,KACA,uBACA,MACA,8CACA,sCACA,QACG,GACH,KACA,uBACA,MACA,8CACA,uCACA,OACG,GACH,KACA,uBACA,qCACA,+BACA,6BACA,sBACA,GACG,GACH,KACA,+BACA,QAEA,4BACA,0BACA,GACA,EACG,GACH,KACA,kCACA,QAEA,4BACA,6BACA,GACA,EACG,GACH,KACA,6BACA,QAEA,yCACA,yBACA,GACA,EACG,GACH,KACA,0BACA,6CAEA,4CACA,sBACA,IAEA,KACA,EAAC,IAED,OACA,SACA,UACA,eACA,OACA,aACA,wBAEA,qBACA,QACA,SACA,aAEA,WAEA,iBACA,QACA,SAEA,SACA,YAGA,YAEA,SACA,SACA,EACA,aAEA,+BACA,iDACA,iBAAkE,gDAClE,mBAEA,wCACA,qBAEA,eAWA,IAqCA,OAEA,CAGA,cAGA,KAIA,iBAGA,WAyDA,SACA,wBA+KA,eASA,gBACA,4DACA,cAEA,8BAEA,SACA,iBACA,0BACA,6BACA,eACA,kBACA,oBACA,sBACA,qBACA,wBAEA,wCAEA,QACA,uBAGA,iEACA,sBACA,OAEA,OACA,aACA,gBAEA,eACA,KACA,wBACA,iBAEA,mEAEA,oBACA,aAIA,mDAGA,WAGA,iCACA,2DAGA,uDACA,kCAGA,2BAIA,qBAGA,gDAMA,0BACA,iBACA,gGACA,MAQG,GACH,KACA,qCACA,gCACA,uFACA,EASG,GACH,KACA,sCAGA,OACA,+CAGO,qBACP,gBAGO,UACP,UAGA,GACA,IAQG,GACH,KACA,oCAEA,CACA,qDAIA,YACA,qDAEA,SAYG,GACH,KACA,0BACA,oEACA,0EAEA,kCAGA,qCAGA,oBAIA,GACA,iCAGA,IACA,EAUG,GACH,KACA,wCACA,QAEA,KACA,MAGA,qBACA,aAKA,0BACA,0BACA,iBAEA,YAEA,GAGA,GACA,SACA,UAEA,GAUG,GACH,KACA,uCACA,gBASA,aACA,GAEA,IAXA,2CAIA,wCACA,4FAEA,yBAKA,4CACA,YAEA,aAGA,SACA,GAQG,GACH,KACA,yCACA,WACA,cAEA,8BACA,IACA,MAEA,0BACA,IACA,MACA,EAQG,GACH,KACA,6BACA,oEAEA,6BACA,IACA,MACA,EAOG,GACH,KACA,gCACA,oEAEA,6BACA,IACA,SACA,EAOG,GACH,KACA,mCACA,4CACA,MAUG,GACH,KACA,kCACA,oEAEA,sBACA,sBAEA,sJAEA,0BACA,6BACA,EACA,EACG,GACH,KACA,4BACA,QAEA,wDACA,wBACA,aAAO,mBACP,eACA,GACA,EAOG,GACH,KACA,oCACA,qBACA,iCACA,gBACA,wCACA,GAEA,GACG,GACH,KACA,oCACA,sCACA,WACA,SACA,EACG,GACH,KACA,qCACA,sCACA,WACA,SACA,EAUG,GACH,KACA,sCACA,IAGA,cACA,qEAGO,SACP,wCAGO,mBACP,yBAGO,YACP,yDAIA,MAIA,GACA,YAGA,OACA,EASG,GACH,KACA,mCACA,IACA,cACA,qEACO,SACP,8BAEA,2BAGA,YACA,EAQG,GACH,KACA,8BACA,wFAEA,6BACA,8BACA,eAGA,4CAEA,gCAGA,uCACA,uBACA,iBACA,EAMG,GACH,KACA,oCACA,oDACA,IAQG,GACH,KACA,oCACA,eACA,UAQG,GACH,KACA,sCACA,4DACA,iBAMG,GACH,KACA,8BACA,4DAEA,kBAIA,yBACA,oDACA,CACA,WACA,qBAEA,MAOG,GACH,KACA,6BACA,aACA,cACA,aACA,QACA,sBAEA,EAQG,GACH,KACA,4BACA,QAEA,QACA,yBACA,cAMA,kCACA,8BACA,MAIA,WAXA,YACA,uBACA,mCAEA,uCAQA,QAKA,kCAJA,YACA,eAIA,qBAIA,gCACA,oDAEA,oBACA,MACA,UACA,YAGA,SACA,CACA,EASG,GACH,KACA,qCACA,UACA,UACA,kBACA,wBACA,oBACA,4BACA,oCAEA,QAQG,GACH,KACA,0BACA,QAEA,oEAEA,wBACA,yBACA,cACA,2BACA,MAQA,wBACA,OAKA,iCAJA,YACA,wBAKA,8BACA,oDAEA,oBACA,MACA,UACA,YAGA,SACA,CACA,EAOG,GACH,KACA,gCAEA,0BAKA,6CAGA,gBAIA,qBACA,SASG,GACH,KACA,4CACA,WACA,WAEA,UACA,qCAGA,uBACA,cAEA,sBACA,2EAEA,gBACA,eAGA,MACA,EAUG,GACH,KACA,8CACA,yBACA,CACA,aACA,GAEA,0BACA,GASG,GACH,KACA,2CACA,QAEA,wBACA,6CACA,wDACA,GACA,CAQG,GACH,KACA,gCACA,MACA,sBAGA,yBACA,wBAEA,kCACA,0CACO,QACP,gCACA,aAMA,wBAIA,qCACA,CAOG,GACH,KACA,sCACA,QAGA,UAGA,6CACA,kCACA,GAEA,qCACA,MACG,GACH,KACA,kCAEA,2BAGA,4BAGA,OACA,kBAQG,GACH,KACA,sCACA,QAEA,kBACA,2BACA,gBACA,OAEA,oCACA,wBACA,6CACA,QACA,UACA,EACA,EACA,CACG,GACH,KACA,oCACA,0BACA,OACA,wBACA,iBACG,GACH,KACA,kCACA,6BACA,OASG,GACH,KACA,8BACA,MAIA,sBACA,uBAGA,wBAGA,SAGA,eAGA,6BACA,IAOG,GACH,KACA,uBACA,oEAEA,iBAIA,gBAEA,yBACA,4BAEA,iBAIA,SAGA,qBAEA,kCACA,GAQG,GACH,KACA,2BACA,MACA,aAEA,SAIA,mBAEA,OAQG,GACH,KACA,yBACA,MACA,UAQG,GACH,KACA,wBACA,8BACA,eACA,GAGA,mBAGA,yBAGA,iCACA,SACA,qCACA,WAMG,GACH,KACA,0BACA,MACA,YAOG,GACH,KACA,2BACA,MACA,aACA,cAEA,QASG,GACH,KACA,2BACA,QAEA,WAIA,iBAEA,0BACA,4BACA,GAAO,sBACP,SACA,EAEA,mBACA,oDACA,qBAGA,2BACA,2BACA,GAEA,qCAAqD,YACrD,IAGA,4BACA,CACA,kBAGA,kBAEA,SAIA,gDACA,aACA,GACA,QAEA,qEACA,IAQG,GACH,KACA,qCACA,8BAAyC,EAAQ,MACjD,iCACA,qBAIA,UACA,KAMG,GACH,KACA,0BACA,MACA,2DAGA,yCACA,wCAGA,cAGA,2BACA,wBACA,kBACA,uBAIA,UACA,cAyBG,KACH,KACA,+BAEA,mCACA,sBACA,qBAEA,UACA,0BACA,0BACA,wBACA,2BACA,WACA,UACA,EAEA,OACA,OACA,UAEA,GAUG,GACH,KACA,wCACA,QAGA,4BACA,WACA,YACA,yBAGA,6CACA,sBAEA,GACA,UACA,SAEA,GAEA,GAGA,WAGA,sCACA,oCACA,yCACA,KACA,EAEA,KACA,EAAC,IAiGD,MA/FA,mBAEA,mBACA,wBAIA,SACA,aACA,QACA,yBAGkB,mBAClB,WAIA,GACA,cACA,KACA,UAGA,OACA,WAEA,UAGA,gBAGA,WAGA,oBAIA,UAIA,iBAIA,cAIA,YAIA,YAIA,kBAIA,iBAIA,KAGA,SAhwDA,eACA,cAcA,IACA,SACA,qBACA,OACA,QACA,IACA,QAjBA,WAFA,oBAGA,IACA,QACA,0BACA,SACA,aACA,yBACA,KACA,EAEA,CASA,eA4uDA,kBAGA,oBAGA,IAKA,0CAGA,KACA,cACA,cACA,qBACA,6BACA,sBAIA,EACA,oNC58DA,GAEA,iDACA,sCACA,uBACA,UACA,sDAEA,4DAEA,QAEA,uEACA,0DACA,SAGA,eACA,gBACA,mDACA,8BACA,8BACA,IACA,CACA,2BACA,iDACA,GACA,uCACA,CACA,GAIA,YAGA,yBACA,gBACA,uCACA,sBACA,qBACA,mEACA,IAEA,kBACA,gBACA,IAEA,EACA,EAEA,oEACA,WACA,cACA,+BAEA,IAGA,0DACA,iCACA,GACA,gDACA,YACA,+BACA,0CACA,kCACA,wBACA,sBACA,2CACA,0BACA,EACA,oCACA,CACA,wDAEA,EACA,iBACA,kCACA,uBACA,8BACA,wCACA,gBACA,qBACA,GAEA,UACA,EAGA,0DACA,iCACA,GACA,gDACA,YACA,+BACA,0CACA,kCACA,wBACA,sBACA,2CACA,0BACA,EACA,oCACA,CACA,wDAEA,EACA,iBACA,kCACA,uBAAkC,oBAClC,uBAAsC,8BACtC,0BAAuC,+BACvC,6CACA,kBACA,EACA,EAGA,SACA,eACA,iCACA,6EACA,UACA,sBACA,SACA,2CAA+D,CAC/D,KACA,GACA,wBACA,kBAGA,eACA,SACA,2CAA+D,CAC/D,KACA,GAAa,KACb,mBAC+D,eAA/D,SACA,SACA,CAEA,CAEA,WACA,gCACA,GACA,EACA,EAEA,4BACA,sDACA,gCACA,QACA,YACA,yBACA,GACA,QAIA,wCACA,aACA,mBACA,cACA,qCACA,oBACA,WACA,SACA,SACa,EACb,cAEA,qEACA,iBACA,sBACA,IACA,GACA,CAEA,qEACA,iCACA,2BACA,4BACA,GACA,EACA,EAEA,QAQA,aAPA,CACA,IACA,GAEA,GACA,EAE6C,qCAC7C,oBAAC,oBC7MD,QAMA,EAEA,YACA,kFACA,GAAC,eACD,cACA,uCACA,SACA,wBACA,cACA,MACA,oBACA,mBACA,CACA,gBACA,iDACA,+BACA,mDACA,QACA,kBACA,+BACA,gGACA,oBAEA,WACA,mBACA,cACA,SACA,aAEA,mCACA,oBACA,kGACA,2DACA,CACA,mCACA,kBACA,2BACA,UACA,0DAA6H,OAAgC,GAC7J,YACA,eACA,CACA,eACA,gCAAoF,OAAoC,GACxH,YACA,eACA,CACA,OACA,EACA,uBACA,SACA,gDACA,UACA,+EACA,sBACA,WACA,CACA,+BACA,mBAAsD,+BAA2C,GACjG,6BACA,6BAEA,+BACA,EACA,gCACA,cACA,8FACA,0CACA,GACA,cACA,GACA,8BACA,yBACA,qIACA,IACA,mBACA,SACA,MAEA,OACA,aAEA,IACA,cACA,gBACA,8BACA,OACA,uCACA,iEACA,aACA,kDACA,oBACA,KACA,IAEA,sDACA,QACA,KAEA,EACA,OACA,EACA,cAGA,OACA,8BACA,uCACA,+CACA,kDACA,oJACA,IACA,mBACA,SACA,MAEA,OACA,aAEA,IACA,cACA,gBACA,8BACA,sCACA,0CACA,+CACA,sGACA,4EACA,QACA,KAEA,GACA,cAGA,OACA,8BACA,0DACA,QACA,cACA,gBACA,8BACA,yDACA,mBACA,6FACA,mGACA,GACA,KAEA,8FACA,gGACA,6BACA,KAEA,EACA,OACA,EACA,cACqB,GACrB,8BACA,yDACA,mBACA,yFACA,8GACA,GACA,KAEA,0FACA,gGACA,oDACA,GACA,mBACA,SACA,MAEA,OAEA,EACA,OACA,EACA,cACqB,GACrB,8BACA,0DACA,QACA,cAIA,kBACA,cAEA,gBACA,aACA,mBACA,mBACA,oBACA,+BACA,0DACA,SACA,kBACA,+BACA,8GACA,MACA,EACA,eAEA,8BACA,8BACA,SACA,gDACA,UACA,+EACA,sBACA,WACA,CAEA,gBACA,MACA,oBACA,mBACA,qBACA,8BACA,SACA,gDACA,UACA,+EACA,sBACA,WACA,CAEA,gBACA,MACA,oBACA,qBACA,mBACA,UAEA,2BACA,MACA,oBACA,qBACA,mBACA,UAEA,2BACA,MACA,oBACA,qBACA,mBACA,UAEA,2BACA,MACA,oBACA,qBACA,mBACA,UAEA,2BACA,MACA,oBACA,qBACA,mBACA,UAEA,2BACA,MACA,oBACA,qBACA,mBACA,UAEA,uBACA,MACA,wBACA,yBACA,mBACA,CACA,eACA,sBACA,uBACA,uBACA,cAEA,+BACA,eACA,iBACA,GACA,8BACA,kEACA,oBACA,mBACA,SACA,MAEA,KAEA,4BACA,2IACA,gCACA,mBACA,SACA,MAEA,OACA,MAEA,gEACA,kBACA,uEACA,iDACA,+DACA,yCACA,mBACA,SACA,QAEA,cAEA,GACA,OACA,EACA,cACA,gBACA,8BACA,2BACA,4DACA,QACA,KAEA,GACA,cAGA,OACA,WACA,yBACA,gBACA,8BACA,0BACA,2DACA,QACA,KAEA,GACA,cAGA,OACA,8BACA,4BACA,IACA,SACA,oBAGA,gBACA,cAEA,cACA,MACA,6BACA,4BACA,sBAEA,4BACA,MACA,6BACA,4BACA,mBACA,oBACA,+BACA,0DACA,SACA,kBACA,+BACA,8GACA,MACA,EACA,eAEA,8BACA,8BACA,SACA,gDACA,UACA,+EACA,sBACA,WACA,CAEA,aACA,MACA,uBACA,iBACA,sBAEA,cACA,MACA,uBACA,iBACA,sBAEA,iBACA,MACA,oBACA,iBACA,uBAEA,WACA,MACA,kBACA,cACA,uBAEA,QACA,OAEA,wBACA,MACA,kBACA,kBACA,qBACA,UAEA,qBACA,OACA,oBACA,+BACA,0CACA,SACA,kBACA,+BACA,qGACA,MACA,EACA,eAEA,gCACA,SACA,aAEA,WACA,gBACA,qBACA,mBACA,8BAEA,yBACA,MACA,0BACA,4BACA,qBACA,YACA,eACA,oBACA,+BACA,0DACA,SACA,kBACA,+BACA,8GACA,MACA,EACA,eAEA,2CAEK,KACL,CAAC,oBC7dD,QAMA,EAEA,YACA,kFACA,GAAC,eACD,4BACA,GACA,WACA,6DACA,SAEA,aACA,WACA,gEACA,SAEA,aACA,WACA,0BACA,SAEK,2BACL,KACA,aACA,GACA,WACA,gBAGA,SACA,kEACA,cACA,YAEA,UACA,MACA,8CACA,GACA,0BACA,oDACA,8DACA,4CACA,EACA,cAGA,wBACA,OACA,EACA,YAEA,iBACA,MACA,oFACA,2BACA,8CACA,GACA,cACA,KACA,WACA,8CACA,SAEA,aACA,WACA,2BACA,SAGA,8BACA,OACA,EACA,YAEA,aACA,MAEA,yBACA,MACA,wBACA,GACA,WACA,wCACA,SAGA,2BACA,cAEK,KACL,CAAC,oBChGD,QAMA,EAEA,YACA,kFACA,GAAC,iBACD,gBACA,gBAAwC,MAAgB,uWACxD,SACA,EACA,wBACA,SACA,iBACA,6DACA,sJACA,4FACA,0GACA,uCACA,mEACA,8DACA,uCACA,IACA,6DACA,+GACA,qBAAmC,sCAA+C,sBAClF,+FACA,yFACA,SACA,oDAAoG,uBAA6B,IAAe,qBAChJ,iBACA,qDACA,2CACA,0EAA+G,cAAoB,mGAAmI,gBAAsB,qCAAkD,cAC9U,IACA,8CACA,CACA,cACA,WACA,SACA,oBACA,uBACA,aACA,yBACA,uBACA,iBACA,cACA,cACA,iBACA,OACA,SAEA,kBACA,qBACA,SACA,UACA,eACA,kBACA,MACA,SACA,UACA,cACA,cACA,kBACA,YACA,2CACA,mGACA,4BACA,OACA,UAEA,uFACA,8BACA,6CACA,SAEA,EACA,QACA,CACA,gCACA,2CACA,kDACA,sCACA,4CACA,mBACA,sCACA,0DACA,yFACA,iQACA,4BACA,+BACA,qFACA,+EACA,qEACA,oFACA,2EACA,uGACA,UACA,mGACA,0DACA,4CACA,aAAuC,OAAkB,6MACzD,EACA,oGACA,OACA,8BAAuE,iBAA2B,0BAClG,0BACA,mCAA+E,wCAC/E,IACA,OACA,EAAqB,OACrB,eACA,cACA,cACA,KACA,WACA,qBAGqB,kEACrB,gBACA,wDACA,sDACA,sCACA,qGACA,0BAAyG,kFACzG,mBACA,cACA,EACA,qCACA,iBACA,gDACA,SACA,kDAEA,kCACA,CACA,iCACA,eACA,UACA,oCACA,OACA,UACqB,GAErB,OACA,WACA,cACA,iBACA,0HACA,0DACA,8EACA,0GACA,0DACA,8EACA,iCACA,OAAqB,gCACrB,gCAA4F,YAC5F,iBACyB,+CACzB,8EACA,OACA,UACA,cACyB,KACzB,gDACA,8EACA,OACA,UACA,cACyB,KACzB,EACA,2BACA,OACA,UACA,cACA,UACqB,QAErB,OACA,kBACA,OAGA,IACA,QACA,0BACA,2HACA,UACA,0BACA,iGACA,KAEA,eACA,KACA,gCACA,qFACA,aACA,gEAmBA,MACA,OAEA,kGArBA,qBACA,+EACA,qEACA,oBACA,qEACA,8DACA,+BACA,wBACA,6BAAyG,mCAA0E,gBACnL,+BACA,eACA,KACA,SACiC,GACjC,KAEA,EACyB,OAKzB,EACA,cAEA,OACA,8BACA,qDACA,MACA,cACA,cAEA,QACA,8BACA,2CACA,IACA,cACA,cAEA,QACA,8BACA,gEACA,2FACA,SACyB,IACzB,CACA,cACA,yBACA,UACA,UAGA,4BACA,kCACA,4BACA,gGACA,uFACA,4HACA,wEACA,sEACA,QACA,CACA,0BACA,cACA,qCACA,2BACA,gGACA,iEACA,eACA,EACA,4BACA,wGACA,0CACA,4CACA,wHACA,YACA,+BACA,oDACA,uEACA,wKACA,uFACA,4GACA,iDACA,6CACA,8BACA,iDACA,mCACA,+BACA,WACA,CACA,OACA,EACA,sCACA,0TACA,8EACA,GACA,CACA,6BACA,SACA,4BACA,wBACA,gFACA,YAEA,qBACA,kFAEA,aAEA,YACA,QACA,oBACA,UACA,sBACA,eACA,SACA,kBACA,wBAEA,WACA,OAEA,mBACA,OACA,iBACA,aAEA,eACA,OACA,iBACA,kBACA,aACA,gBACA,eACA,MACA,MACA,WACA,iBAEK,KACL,CAAC,oBCvVD,QAMA,EAEA,YACA,kFACA,GAAC,eACD,gBACA,4MACA,iEACA,EACA,mBACA,0DACA,kBACA,cACA,aACA,yCAAiI,EAAQ,wBACzI,0BACA,4CACA,oDACA,EACA,cACA,UACA,oMACA,oIACA,IACA,CACA,IACA,0FACA,gEACA,yDACA,EAAK,kBACL,eACA,aACA,OACA,QAEA,iBACA,GACA,8BACA,sBACA,6BACiB,sBACjB,EACA,cACA,4BACA,iBAA2D,8BAC3D,4FACA,GACA,CACA,sBACA,4BACA,GACA,YAEK,SACL,CAAC,eC5DD,CAWA,YACA,iBACA,mCACA,YACA,iBACA,oCACA,CAoBA,aACA,QAEA,+BAGA,mBACA,oBACA,wBAEA,MAEA,YACA,EAAK,SACL,IAEA,sBACA,EAAS,SAET,sBACA,EACA,CAGA,EACA,aACA,QAEA,iCAGA,mBACA,sBACA,0BAEA,MAEA,UACA,EAAK,SACL,IAEA,oBACA,EAAS,SAGT,oBACA,EACA,CAIA,EAMA,YACA,IAGA,IACA,OACA,kBAEA,MAEA,IACA,QAEA,KAEA,YACA,KAGA,WACA,GAEA,iBACA,UACA,OACA,EACA,SACA,GACA,QAGA,SACA,MACA,MACA,GACA,KACA,OACA,IAgBA,eACA,UACA,aACA,EAWA,cAhKA,QAOA,WACA,eASA,IACA,GACA,8BAEA,WAEA,CAAK,SACL,GACA,CACA,IACA,GACA,gCAEA,aAEA,CAAK,SACL,GACA,CACA,CAAC,KAqDD,GACA,MACA,KACA,OAyCA,sBACA,8BACA,MACA,6BAAuB,cAAsB,OAC7C,qBAGA,kBACA,kBACA,KAEA,EAEA,EAKA,0BACA,0BACA,QACA,kBACA,aACA,SACA,UACA,UAAqB,GACrB,cAIA,OACA,gBACA,SACA,QACA,mBACA,uBACA,SACA,oBACA,wBAEA,sBAAqC,WAErC,oBACA,iBACA,qCAEA,gBAA2B,YAC3B,kBACA,iBACA,mCACA,kBAA4B,OAAU,oBCvLtC,8BACA,CAEA,0BAYA,CACA,yCAGA,qCACA,KAAqB,MAAiB,OACtC,qBAGA,SAAkB,iBAClB,eACA,IACA,GACA,GAEA,cACA,UACA,EAEA,cACA,SACA,aACA,cACA,YACA,GACA,IACA,UACA,OACA,IACA,UACA,YACA,IACA,UACA,iBACA,IACA,MACA,kBAGA,IAEA,cAGA,IAGA,iBACS,OACT,SACA,QACA,CACA,QACA,GACA,EAAiB,QACjB,GACA,GACA,IACA,CACA,CACA,CAEA,aACA,cACA,sBAA0C,GAAsB,EAChE,EACA,CAEA,aAGA,oCACA,IACA,UACA,uCACA,CACA,IACA,mBACA,iBACA,EACA,CACA,CAEA,aAKA,qCACA,iBACA,YACA,GACA,yBACA,yCAEA,QAEA,IACA,8CAEA,gCAGA,gBACA,mBACA,IACA,CAEA,aACA,UACA,6CACA,SACA,OACA,EAEA,eACA,qBACA,EACA,CAEA,aACA,SACA,6BAGA,uBACA,yCACA,GACA,wBACA,mBACA,KACA,IACA,gBACA,EACA,CAEA,aACA,cACA,gBACA,EACA,CAGA,OAvJA,oBACA,EACA,KACA,SACA,wDAoJA,GAlJA,sBAqJA,EAEA,kBAFU,+BAIL,IAEL,IAEK,MAEL,eAEK,8CAEL,UAIA,IAGA,mBACA,mBACA,EAAC,qGCxKD,eACA,UACA,gBACA,EApBA,yBAEA,MAEA,uBACA,kDACA,eACA,wBACA,mDACA,gBACA,eACA,2BACA,CACA,KAEA,SAMA,+CACA,4BACA,gCACA,IAEA,EACA,sBACA,gBACA,+BACA,GAEA,sBACA,gBACA,gCACA,GAEA,mCACA,gBAEA,wBACA,aACA,6CACA,GACA,cACA,YAAK,EAEL,GAEA,EACA,MACA,4BACA","file":"home.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/static/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 12);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap c81d600910e1d9f033f1","/*!\n* dependencyLibs/inputmask.dependencyLib.js\n* https://github.com/RobinHerbots/Inputmask\n* Copyright (c) 2010 - 2017 Robin Herbots\n* Licensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)\n* Version: 3.3.7\n*/\n\n!function(factory) {\n    \"function\" == typeof define && define.amd ? define([ \"../global/window\", \"../global/document\" ], factory) : \"object\" == typeof exports ? module.exports = factory(require(\"../global/window\"), require(\"../global/document\")) : window.dependencyLib = factory(window, document);\n}(function(window, document) {\n    function indexOf(list, elem) {\n        for (var i = 0, len = list.length; i < len; i++) if (list[i] === elem) return i;\n        return -1;\n    }\n    function type(obj) {\n        return null == obj ? obj + \"\" : \"object\" == typeof obj || \"function\" == typeof obj ? class2type[class2type.toString.call(obj)] || \"object\" : typeof obj;\n    }\n    function isWindow(obj) {\n        return null != obj && obj === obj.window;\n    }\n    function isArraylike(obj) {\n        var length = \"length\" in obj && obj.length, ltype = type(obj);\n        return \"function\" !== ltype && !isWindow(obj) && (!(1 !== obj.nodeType || !length) || (\"array\" === ltype || 0 === length || \"number\" == typeof length && length > 0 && length - 1 in obj));\n    }\n    function isValidElement(elem) {\n        return elem instanceof Element;\n    }\n    function DependencyLib(elem) {\n        return elem instanceof DependencyLib ? elem : this instanceof DependencyLib ? void (void 0 !== elem && null !== elem && elem !== window && (this[0] = elem.nodeName ? elem : void 0 !== elem[0] && elem[0].nodeName ? elem[0] : document.querySelector(elem), \n        void 0 !== this[0] && null !== this[0] && (this[0].eventRegistry = this[0].eventRegistry || {}))) : new DependencyLib(elem);\n    }\n    for (var class2type = {}, classTypes = \"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), nameNdx = 0; nameNdx < classTypes.length; nameNdx++) class2type[\"[object \" + classTypes[nameNdx] + \"]\"] = classTypes[nameNdx].toLowerCase();\n    return DependencyLib.prototype = {\n        on: function(events, handler) {\n            if (isValidElement(this[0])) for (var eventRegistry = this[0].eventRegistry, elem = this[0], _events = events.split(\" \"), endx = 0; endx < _events.length; endx++) {\n                var nsEvent = _events[endx].split(\".\"), ev = nsEvent[0], namespace = nsEvent[1] || \"global\";\n                !function(ev, namespace) {\n                    elem.addEventListener ? elem.addEventListener(ev, handler, !1) : elem.attachEvent && elem.attachEvent(\"on\" + ev, handler), \n                    eventRegistry[ev] = eventRegistry[ev] || {}, eventRegistry[ev][namespace] = eventRegistry[ev][namespace] || [], \n                    eventRegistry[ev][namespace].push(handler);\n                }(ev, namespace);\n            }\n            return this;\n        },\n        off: function(events, handler) {\n            if (isValidElement(this[0])) for (var eventRegistry = this[0].eventRegistry, elem = this[0], _events = events.split(\" \"), endx = 0; endx < _events.length; endx++) for (var nsEvent = _events[endx].split(\".\"), offEvents = function(ev, namespace) {\n                var hndx, hndL, evts = [];\n                if (ev.length > 0) if (void 0 === handler) for (hndx = 0, hndL = eventRegistry[ev][namespace].length; hndx < hndL; hndx++) evts.push({\n                    ev: ev,\n                    namespace: namespace && namespace.length > 0 ? namespace : \"global\",\n                    handler: eventRegistry[ev][namespace][hndx]\n                }); else evts.push({\n                    ev: ev,\n                    namespace: namespace && namespace.length > 0 ? namespace : \"global\",\n                    handler: handler\n                }); else if (namespace.length > 0) for (var evNdx in eventRegistry) for (var nmsp in eventRegistry[evNdx]) if (nmsp === namespace) if (void 0 === handler) for (hndx = 0, \n                hndL = eventRegistry[evNdx][nmsp].length; hndx < hndL; hndx++) evts.push({\n                    ev: evNdx,\n                    namespace: nmsp,\n                    handler: eventRegistry[evNdx][nmsp][hndx]\n                }); else evts.push({\n                    ev: evNdx,\n                    namespace: nmsp,\n                    handler: handler\n                });\n                return evts;\n            }(nsEvent[0], nsEvent[1]), i = 0, offEventsL = offEvents.length; i < offEventsL; i++) !function(ev, namespace, handler) {\n                if (ev in eventRegistry == 1) if (elem.removeEventListener ? elem.removeEventListener(ev, handler, !1) : elem.detachEvent && elem.detachEvent(\"on\" + ev, handler), \n                \"global\" === namespace) for (var nmsp in eventRegistry[ev]) eventRegistry[ev][nmsp].splice(eventRegistry[ev][nmsp].indexOf(handler), 1); else eventRegistry[ev][namespace].splice(eventRegistry[ev][namespace].indexOf(handler), 1);\n            }(offEvents[i].ev, offEvents[i].namespace, offEvents[i].handler);\n            return this;\n        },\n        trigger: function(events) {\n            if (isValidElement(this[0])) for (var eventRegistry = this[0].eventRegistry, elem = this[0], _events = \"string\" == typeof events ? events.split(\" \") : [ events.type ], endx = 0; endx < _events.length; endx++) {\n                var nsEvent = _events[endx].split(\".\"), ev = nsEvent[0], namespace = nsEvent[1] || \"global\";\n                if (void 0 !== document && \"global\" === namespace) {\n                    var evnt, i, params = {\n                        bubbles: !0,\n                        cancelable: !0,\n                        detail: Array.prototype.slice.call(arguments, 1)\n                    };\n                    if (document.createEvent) {\n                        try {\n                            evnt = new CustomEvent(ev, params);\n                        } catch (e) {\n                            evnt = document.createEvent(\"CustomEvent\"), evnt.initCustomEvent(ev, params.bubbles, params.cancelable, params.detail);\n                        }\n                        events.type && DependencyLib.extend(evnt, events), elem.dispatchEvent(evnt);\n                    } else evnt = document.createEventObject(), evnt.eventType = ev, events.type && DependencyLib.extend(evnt, events), \n                    elem.fireEvent(\"on\" + evnt.eventType, evnt);\n                } else if (void 0 !== eventRegistry[ev]) if (arguments[0] = arguments[0].type ? arguments[0] : DependencyLib.Event(arguments[0]), \n                \"global\" === namespace) for (var nmsp in eventRegistry[ev]) for (i = 0; i < eventRegistry[ev][nmsp].length; i++) eventRegistry[ev][nmsp][i].apply(elem, arguments); else for (i = 0; i < eventRegistry[ev][namespace].length; i++) eventRegistry[ev][namespace][i].apply(elem, arguments);\n            }\n            return this;\n        },\n        position: function() {\n            if (isValidElement(this[0])) return {\n                top: this[0].offsetTop,\n                left: this[0].offsetLeft\n            };\n        }\n    }, DependencyLib.isFunction = function(obj) {\n        return \"function\" === type(obj);\n    }, DependencyLib.noop = function() {}, DependencyLib.isArray = Array.isArray, DependencyLib.inArray = function(elem, arr, i) {\n        return null == arr ? -1 : indexOf(arr, elem);\n    }, DependencyLib.valHooks = void 0, DependencyLib.isPlainObject = function(obj) {\n        return \"object\" === type(obj) && !obj.nodeType && !isWindow(obj) && !(obj.constructor && !class2type.hasOwnProperty.call(obj.constructor.prototype, \"isPrototypeOf\"));\n    }, DependencyLib.extend = function() {\n        var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = !1;\n        for (\"boolean\" == typeof target && (deep = target, target = arguments[i] || {}, \n        i++), \"object\" == typeof target || DependencyLib.isFunction(target) || (target = {}), \n        i === length && (target = this, i--); i < length; i++) if (null != (options = arguments[i])) for (name in options) src = target[name], \n        copy = options[name], target !== copy && (deep && copy && (DependencyLib.isPlainObject(copy) || (copyIsArray = DependencyLib.isArray(copy))) ? (copyIsArray ? (copyIsArray = !1, \n        clone = src && DependencyLib.isArray(src) ? src : []) : clone = src && DependencyLib.isPlainObject(src) ? src : {}, \n        target[name] = DependencyLib.extend(deep, clone, copy)) : void 0 !== copy && (target[name] = copy));\n        return target;\n    }, DependencyLib.each = function(obj, callback) {\n        var i = 0;\n        if (isArraylike(obj)) for (var length = obj.length; i < length && !1 !== callback.call(obj[i], i, obj[i]); i++) ; else for (i in obj) if (!1 === callback.call(obj[i], i, obj[i])) break;\n        return obj;\n    }, DependencyLib.map = function(elems, callback) {\n        var value, i = 0, length = elems.length, isArray = isArraylike(elems), ret = [];\n        if (isArray) for (;i < length; i++) null != (value = callback(elems[i], i)) && ret.push(value); else for (i in elems) null != (value = callback(elems[i], i)) && ret.push(value);\n        return [].concat(ret);\n    }, DependencyLib.data = function(owner, key, value) {\n        if (void 0 === value) return owner.__data ? owner.__data[key] : null;\n        owner.__data = owner.__data || {}, owner.__data[key] = value;\n    }, DependencyLib.Event = function CustomEvent(event, params) {\n        params = params || {\n            bubbles: !1,\n            cancelable: !1,\n            detail: void 0\n        };\n        var evnt;\n        if (document.createEvent) try {\n            evnt = new CustomEvent(event, params);\n        } catch (e) {\n            evnt = document.createEvent(\"CustomEvent\"), evnt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n        } else evnt = document.createEventObject(), evnt.eventType = event;\n        return evnt;\n    }, DependencyLib.Event.prototype = window.Event.prototype, DependencyLib;\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/inputmask/dist/inputmask/dependencyLibs/inputmask.dependencyLib.js\n// module id = 0\n// module chunks = 0","/*!\n* inputmask.js\n* https://github.com/RobinHerbots/Inputmask\n* Copyright (c) 2010 - 2017 Robin Herbots\n* Licensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)\n* Version: 3.3.7\n*/\n\n!function(factory) {\n    \"function\" == typeof define && define.amd ? define([ \"./dependencyLibs/inputmask.dependencyLib\", \"./global/window\", \"./global/document\" ], factory) : \"object\" == typeof exports ? module.exports = factory(require(\"./dependencyLibs/inputmask.dependencyLib\"), require(\"./global/window\"), require(\"./global/document\")) : window.Inputmask = factory(window.dependencyLib || jQuery, window, document);\n}(function($, window, document, undefined) {\n    function Inputmask(alias, options, internal) {\n        if (!(this instanceof Inputmask)) return new Inputmask(alias, options, internal);\n        this.el = undefined, this.events = {}, this.maskset = undefined, this.refreshValue = !1, \n        !0 !== internal && ($.isPlainObject(alias) ? options = alias : (options = options || {}, \n        options.alias = alias), this.opts = $.extend(!0, {}, this.defaults, options), this.noMasksCache = options && options.definitions !== undefined, \n        this.userOptions = options || {}, this.isRTL = this.opts.numericInput, resolveAlias(this.opts.alias, options, this.opts));\n    }\n    function resolveAlias(aliasStr, options, opts) {\n        var aliasDefinition = Inputmask.prototype.aliases[aliasStr];\n        return aliasDefinition ? (aliasDefinition.alias && resolveAlias(aliasDefinition.alias, undefined, opts), \n        $.extend(!0, opts, aliasDefinition), $.extend(!0, opts, options), !0) : (null === opts.mask && (opts.mask = aliasStr), \n        !1);\n    }\n    function generateMaskSet(opts, nocache) {\n        function generateMask(mask, metadata, opts) {\n            var regexMask = !1;\n            if (null !== mask && \"\" !== mask || (regexMask = null !== opts.regex, regexMask ? (mask = opts.regex, \n            mask = mask.replace(/^(\\^)(.*)(\\$)$/, \"$2\")) : (regexMask = !0, mask = \".*\")), 1 === mask.length && !1 === opts.greedy && 0 !== opts.repeat && (opts.placeholder = \"\"), \n            opts.repeat > 0 || \"*\" === opts.repeat || \"+\" === opts.repeat) {\n                var repeatStart = \"*\" === opts.repeat ? 0 : \"+\" === opts.repeat ? 1 : opts.repeat;\n                mask = opts.groupmarker.start + mask + opts.groupmarker.end + opts.quantifiermarker.start + repeatStart + \",\" + opts.repeat + opts.quantifiermarker.end;\n            }\n            var masksetDefinition, maskdefKey = regexMask ? \"regex_\" + opts.regex : opts.numericInput ? mask.split(\"\").reverse().join(\"\") : mask;\n            return Inputmask.prototype.masksCache[maskdefKey] === undefined || !0 === nocache ? (masksetDefinition = {\n                mask: mask,\n                maskToken: Inputmask.prototype.analyseMask(mask, regexMask, opts),\n                validPositions: {},\n                _buffer: undefined,\n                buffer: undefined,\n                tests: {},\n                metadata: metadata,\n                maskLength: undefined\n            }, !0 !== nocache && (Inputmask.prototype.masksCache[maskdefKey] = masksetDefinition, \n            masksetDefinition = $.extend(!0, {}, Inputmask.prototype.masksCache[maskdefKey]))) : masksetDefinition = $.extend(!0, {}, Inputmask.prototype.masksCache[maskdefKey]), \n            masksetDefinition;\n        }\n        if ($.isFunction(opts.mask) && (opts.mask = opts.mask(opts)), $.isArray(opts.mask)) {\n            if (opts.mask.length > 1) {\n                opts.keepStatic = null === opts.keepStatic || opts.keepStatic;\n                var altMask = opts.groupmarker.start;\n                return $.each(opts.numericInput ? opts.mask.reverse() : opts.mask, function(ndx, msk) {\n                    altMask.length > 1 && (altMask += opts.groupmarker.end + opts.alternatormarker + opts.groupmarker.start), \n                    msk.mask === undefined || $.isFunction(msk.mask) ? altMask += msk : altMask += msk.mask;\n                }), altMask += opts.groupmarker.end, generateMask(altMask, opts.mask, opts);\n            }\n            opts.mask = opts.mask.pop();\n        }\n        return opts.mask && opts.mask.mask !== undefined && !$.isFunction(opts.mask.mask) ? generateMask(opts.mask.mask, opts.mask, opts) : generateMask(opts.mask, opts.mask, opts);\n    }\n    function maskScope(actionObj, maskset, opts) {\n        function getMaskTemplate(baseOnInput, minimalPos, includeMode) {\n            minimalPos = minimalPos || 0;\n            var ndxIntlzr, test, testPos, maskTemplate = [], pos = 0, lvp = getLastValidPosition();\n            -1 === (maxLength = el !== undefined ? el.maxLength : undefined) && (maxLength = undefined);\n            do {\n                !0 === baseOnInput && getMaskSet().validPositions[pos] ? (testPos = getMaskSet().validPositions[pos], \n                test = testPos.match, ndxIntlzr = testPos.locator.slice(), maskTemplate.push(!0 === includeMode ? testPos.input : !1 === includeMode ? test.nativeDef : getPlaceholder(pos, test))) : (testPos = getTestTemplate(pos, ndxIntlzr, pos - 1), \n                test = testPos.match, ndxIntlzr = testPos.locator.slice(), (!1 === opts.jitMasking || pos < lvp || \"number\" == typeof opts.jitMasking && isFinite(opts.jitMasking) && opts.jitMasking > pos) && maskTemplate.push(!1 === includeMode ? test.nativeDef : getPlaceholder(pos, test))), \n                pos++;\n            } while ((maxLength === undefined || pos < maxLength) && (null !== test.fn || \"\" !== test.def) || minimalPos > pos);\n            return \"\" === maskTemplate[maskTemplate.length - 1] && maskTemplate.pop(), getMaskSet().maskLength = pos + 1, \n            maskTemplate;\n        }\n        function getMaskSet() {\n            return maskset;\n        }\n        function resetMaskSet(soft) {\n            var maskset = getMaskSet();\n            maskset.buffer = undefined, !0 !== soft && (maskset.validPositions = {}, maskset.p = 0);\n        }\n        function getLastValidPosition(closestTo, strict, validPositions) {\n            var before = -1, after = -1, valids = validPositions || getMaskSet().validPositions;\n            closestTo === undefined && (closestTo = -1);\n            for (var posNdx in valids) {\n                var psNdx = parseInt(posNdx);\n                valids[psNdx] && (strict || !0 !== valids[psNdx].generatedInput) && (psNdx <= closestTo && (before = psNdx), \n                psNdx >= closestTo && (after = psNdx));\n            }\n            return -1 !== before && closestTo - before > 1 || after < closestTo ? before : after;\n        }\n        function stripValidPositions(start, end, nocheck, strict) {\n            var i, startPos = start, positionsClone = $.extend(!0, {}, getMaskSet().validPositions), needsValidation = !1;\n            for (getMaskSet().p = start, i = end - 1; i >= startPos; i--) getMaskSet().validPositions[i] !== undefined && (!0 !== nocheck && (!getMaskSet().validPositions[i].match.optionality && function(pos) {\n                var posMatch = getMaskSet().validPositions[pos];\n                if (posMatch !== undefined && null === posMatch.match.fn) {\n                    var prevMatch = getMaskSet().validPositions[pos - 1], nextMatch = getMaskSet().validPositions[pos + 1];\n                    return prevMatch !== undefined && nextMatch !== undefined;\n                }\n                return !1;\n            }(i) || !1 === opts.canClearPosition(getMaskSet(), i, getLastValidPosition(), strict, opts)) || delete getMaskSet().validPositions[i]);\n            for (resetMaskSet(!0), i = startPos + 1; i <= getLastValidPosition(); ) {\n                for (;getMaskSet().validPositions[startPos] !== undefined; ) startPos++;\n                if (i < startPos && (i = startPos + 1), getMaskSet().validPositions[i] === undefined && isMask(i)) i++; else {\n                    var t = getTestTemplate(i);\n                    !1 === needsValidation && positionsClone[startPos] && positionsClone[startPos].match.def === t.match.def ? (getMaskSet().validPositions[startPos] = $.extend(!0, {}, positionsClone[startPos]), \n                    getMaskSet().validPositions[startPos].input = t.input, delete getMaskSet().validPositions[i], \n                    i++) : positionCanMatchDefinition(startPos, t.match.def) ? !1 !== isValid(startPos, t.input || getPlaceholder(i), !0) && (delete getMaskSet().validPositions[i], \n                    i++, needsValidation = !0) : isMask(i) || (i++, startPos--), startPos++;\n                }\n            }\n            resetMaskSet(!0);\n        }\n        function determineTestTemplate(tests, guessNextBest) {\n            for (var testPos, testPositions = tests, lvp = getLastValidPosition(), lvTest = getMaskSet().validPositions[lvp] || getTests(0)[0], lvTestAltArr = lvTest.alternation !== undefined ? lvTest.locator[lvTest.alternation].toString().split(\",\") : [], ndx = 0; ndx < testPositions.length && (testPos = testPositions[ndx], \n            !(testPos.match && (opts.greedy && !0 !== testPos.match.optionalQuantifier || (!1 === testPos.match.optionality || !1 === testPos.match.newBlockMarker) && !0 !== testPos.match.optionalQuantifier) && (lvTest.alternation === undefined || lvTest.alternation !== testPos.alternation || testPos.locator[lvTest.alternation] !== undefined && checkAlternationMatch(testPos.locator[lvTest.alternation].toString().split(\",\"), lvTestAltArr))) || !0 === guessNextBest && (null !== testPos.match.fn || /[0-9a-bA-Z]/.test(testPos.match.def))); ndx++) ;\n            return testPos;\n        }\n        function getTestTemplate(pos, ndxIntlzr, tstPs) {\n            return getMaskSet().validPositions[pos] || determineTestTemplate(getTests(pos, ndxIntlzr ? ndxIntlzr.slice() : ndxIntlzr, tstPs));\n        }\n        function getTest(pos) {\n            return getMaskSet().validPositions[pos] ? getMaskSet().validPositions[pos] : getTests(pos)[0];\n        }\n        function positionCanMatchDefinition(pos, def) {\n            for (var valid = !1, tests = getTests(pos), tndx = 0; tndx < tests.length; tndx++) if (tests[tndx].match && tests[tndx].match.def === def) {\n                valid = !0;\n                break;\n            }\n            return valid;\n        }\n        function getTests(pos, ndxIntlzr, tstPs) {\n            function resolveTestFromToken(maskToken, ndxInitializer, loopNdx, quantifierRecurse) {\n                function handleMatch(match, loopNdx, quantifierRecurse) {\n                    function isFirstMatch(latestMatch, tokenGroup) {\n                        var firstMatch = 0 === $.inArray(latestMatch, tokenGroup.matches);\n                        return firstMatch || $.each(tokenGroup.matches, function(ndx, match) {\n                            if (!0 === match.isQuantifier && (firstMatch = isFirstMatch(latestMatch, tokenGroup.matches[ndx - 1]))) return !1;\n                        }), firstMatch;\n                    }\n                    function resolveNdxInitializer(pos, alternateNdx, targetAlternation) {\n                        var bestMatch, indexPos;\n                        if (getMaskSet().validPositions[pos - 1] && targetAlternation && getMaskSet().tests[pos]) for (var vpAlternation = getMaskSet().validPositions[pos - 1].locator, tpAlternation = getMaskSet().tests[pos][0].locator, i = 0; i < targetAlternation; i++) if (vpAlternation[i] !== tpAlternation[i]) return vpAlternation.slice(targetAlternation + 1);\n                        return (getMaskSet().tests[pos] || getMaskSet().validPositions[pos]) && $.each(getMaskSet().tests[pos] || [ getMaskSet().validPositions[pos] ], function(ndx, lmnt) {\n                            var alternation = targetAlternation !== undefined ? targetAlternation : lmnt.alternation, ndxPos = lmnt.locator[alternation] !== undefined ? lmnt.locator[alternation].toString().indexOf(alternateNdx) : -1;\n                            (indexPos === undefined || ndxPos < indexPos) && -1 !== ndxPos && (bestMatch = lmnt, \n                            indexPos = ndxPos);\n                        }), bestMatch ? bestMatch.locator.slice((targetAlternation !== undefined ? targetAlternation : bestMatch.alternation) + 1) : targetAlternation !== undefined ? resolveNdxInitializer(pos, alternateNdx) : undefined;\n                    }\n                    if (testPos > 1e4) throw \"Inputmask: There is probably an error in your mask definition or in the code. Create an issue on github with an example of the mask you are using. \" + getMaskSet().mask;\n                    if (testPos === pos && match.matches === undefined) return matches.push({\n                        match: match,\n                        locator: loopNdx.reverse(),\n                        cd: cacheDependency\n                    }), !0;\n                    if (match.matches !== undefined) {\n                        if (match.isGroup && quantifierRecurse !== match) {\n                            if (match = handleMatch(maskToken.matches[$.inArray(match, maskToken.matches) + 1], loopNdx)) return !0;\n                        } else if (match.isOptional) {\n                            var optionalToken = match;\n                            if (match = resolveTestFromToken(match, ndxInitializer, loopNdx, quantifierRecurse)) {\n                                if (latestMatch = matches[matches.length - 1].match, !isFirstMatch(latestMatch, optionalToken)) return !0;\n                                insertStop = !0, testPos = pos;\n                            }\n                        } else if (match.isAlternator) {\n                            var maltMatches, alternateToken = match, malternateMatches = [], currentMatches = matches.slice(), loopNdxCnt = loopNdx.length, altIndex = ndxInitializer.length > 0 ? ndxInitializer.shift() : -1;\n                            if (-1 === altIndex || \"string\" == typeof altIndex) {\n                                var amndx, currentPos = testPos, ndxInitializerClone = ndxInitializer.slice(), altIndexArr = [];\n                                if (\"string\" == typeof altIndex) altIndexArr = altIndex.split(\",\"); else for (amndx = 0; amndx < alternateToken.matches.length; amndx++) altIndexArr.push(amndx);\n                                for (var ndx = 0; ndx < altIndexArr.length; ndx++) {\n                                    if (amndx = parseInt(altIndexArr[ndx]), matches = [], ndxInitializer = resolveNdxInitializer(testPos, amndx, loopNdxCnt) || ndxInitializerClone.slice(), \n                                    !0 !== (match = handleMatch(alternateToken.matches[amndx] || maskToken.matches[amndx], [ amndx ].concat(loopNdx), quantifierRecurse) || match) && match !== undefined && altIndexArr[altIndexArr.length - 1] < alternateToken.matches.length) {\n                                        var ntndx = $.inArray(match, maskToken.matches) + 1;\n                                        maskToken.matches.length > ntndx && (match = handleMatch(maskToken.matches[ntndx], [ ntndx ].concat(loopNdx.slice(1, loopNdx.length)), quantifierRecurse)) && (altIndexArr.push(ntndx.toString()), \n                                        $.each(matches, function(ndx, lmnt) {\n                                            lmnt.alternation = loopNdx.length - 1;\n                                        }));\n                                    }\n                                    maltMatches = matches.slice(), testPos = currentPos, matches = [];\n                                    for (var ndx1 = 0; ndx1 < maltMatches.length; ndx1++) {\n                                        var altMatch = maltMatches[ndx1], dropMatch = !1;\n                                        altMatch.alternation = altMatch.alternation || loopNdxCnt;\n                                        for (var ndx2 = 0; ndx2 < malternateMatches.length; ndx2++) {\n                                            var altMatch2 = malternateMatches[ndx2];\n                                            if (\"string\" != typeof altIndex || -1 !== $.inArray(altMatch.locator[altMatch.alternation].toString(), altIndexArr)) {\n                                                if (function(source, target) {\n                                                    return source.match.nativeDef === target.match.nativeDef || source.match.def === target.match.nativeDef || source.match.nativeDef === target.match.def;\n                                                }(altMatch, altMatch2)) {\n                                                    dropMatch = !0, altMatch.alternation === altMatch2.alternation && -1 === altMatch2.locator[altMatch2.alternation].toString().indexOf(altMatch.locator[altMatch.alternation]) && (altMatch2.locator[altMatch2.alternation] = altMatch2.locator[altMatch2.alternation] + \",\" + altMatch.locator[altMatch.alternation], \n                                                    altMatch2.alternation = altMatch.alternation), altMatch.match.nativeDef === altMatch2.match.def && (altMatch.locator[altMatch.alternation] = altMatch2.locator[altMatch2.alternation], \n                                                    malternateMatches.splice(malternateMatches.indexOf(altMatch2), 1, altMatch));\n                                                    break;\n                                                }\n                                                if (altMatch.match.def === altMatch2.match.def) {\n                                                    dropMatch = !1;\n                                                    break;\n                                                }\n                                                if (function(source, target) {\n                                                    return null === source.match.fn && null !== target.match.fn && target.match.fn.test(source.match.def, getMaskSet(), pos, !1, opts, !1);\n                                                }(altMatch, altMatch2) || function(source, target) {\n                                                    return null !== source.match.fn && null !== target.match.fn && target.match.fn.test(source.match.def.replace(/[\\[\\]]/g, \"\"), getMaskSet(), pos, !1, opts, !1);\n                                                }(altMatch, altMatch2)) {\n                                                    altMatch.alternation == altMatch2.alternation && -1 === altMatch.locator[altMatch.alternation].toString().indexOf(altMatch2.locator[altMatch2.alternation].toString().split(\"\")[0]) && (altMatch.na = altMatch.na || altMatch.locator[altMatch.alternation].toString(), \n                                                    -1 === altMatch.na.indexOf(altMatch.locator[altMatch.alternation].toString().split(\"\")[0]) && (altMatch.na = altMatch.na + \",\" + altMatch.locator[altMatch2.alternation].toString().split(\"\")[0]), \n                                                    dropMatch = !0, altMatch.locator[altMatch.alternation] = altMatch2.locator[altMatch2.alternation].toString().split(\"\")[0] + \",\" + altMatch.locator[altMatch.alternation], \n                                                    malternateMatches.splice(malternateMatches.indexOf(altMatch2), 0, altMatch));\n                                                    break;\n                                                }\n                                            }\n                                        }\n                                        dropMatch || malternateMatches.push(altMatch);\n                                    }\n                                }\n                                \"string\" == typeof altIndex && (malternateMatches = $.map(malternateMatches, function(lmnt, ndx) {\n                                    if (isFinite(ndx)) {\n                                        var alternation = lmnt.alternation, altLocArr = lmnt.locator[alternation].toString().split(\",\");\n                                        lmnt.locator[alternation] = undefined, lmnt.alternation = undefined;\n                                        for (var alndx = 0; alndx < altLocArr.length; alndx++) -1 !== $.inArray(altLocArr[alndx], altIndexArr) && (lmnt.locator[alternation] !== undefined ? (lmnt.locator[alternation] += \",\", \n                                        lmnt.locator[alternation] += altLocArr[alndx]) : lmnt.locator[alternation] = parseInt(altLocArr[alndx]), \n                                        lmnt.alternation = alternation);\n                                        if (lmnt.locator[alternation] !== undefined) return lmnt;\n                                    }\n                                })), matches = currentMatches.concat(malternateMatches), testPos = pos, insertStop = matches.length > 0, \n                                match = malternateMatches.length > 0, ndxInitializer = ndxInitializerClone.slice();\n                            } else match = handleMatch(alternateToken.matches[altIndex] || maskToken.matches[altIndex], [ altIndex ].concat(loopNdx), quantifierRecurse);\n                            if (match) return !0;\n                        } else if (match.isQuantifier && quantifierRecurse !== maskToken.matches[$.inArray(match, maskToken.matches) - 1]) for (var qt = match, qndx = ndxInitializer.length > 0 ? ndxInitializer.shift() : 0; qndx < (isNaN(qt.quantifier.max) ? qndx + 1 : qt.quantifier.max) && testPos <= pos; qndx++) {\n                            var tokenGroup = maskToken.matches[$.inArray(qt, maskToken.matches) - 1];\n                            if (match = handleMatch(tokenGroup, [ qndx ].concat(loopNdx), tokenGroup)) {\n                                if (latestMatch = matches[matches.length - 1].match, latestMatch.optionalQuantifier = qndx > qt.quantifier.min - 1, \n                                isFirstMatch(latestMatch, tokenGroup)) {\n                                    if (qndx > qt.quantifier.min - 1) {\n                                        insertStop = !0, testPos = pos;\n                                        break;\n                                    }\n                                    return !0;\n                                }\n                                return !0;\n                            }\n                        } else if (match = resolveTestFromToken(match, ndxInitializer, loopNdx, quantifierRecurse)) return !0;\n                    } else testPos++;\n                }\n                for (var tndx = ndxInitializer.length > 0 ? ndxInitializer.shift() : 0; tndx < maskToken.matches.length; tndx++) if (!0 !== maskToken.matches[tndx].isQuantifier) {\n                    var match = handleMatch(maskToken.matches[tndx], [ tndx ].concat(loopNdx), quantifierRecurse);\n                    if (match && testPos === pos) return match;\n                    if (testPos > pos) break;\n                }\n            }\n            function filterTests(tests) {\n                if (opts.keepStatic && pos > 0 && tests.length > 1 + (\"\" === tests[tests.length - 1].match.def ? 1 : 0) && !0 !== tests[0].match.optionality && !0 !== tests[0].match.optionalQuantifier && null === tests[0].match.fn && !/[0-9a-bA-Z]/.test(tests[0].match.def)) {\n                    if (getMaskSet().validPositions[pos - 1] === undefined) return [ determineTestTemplate(tests) ];\n                    if (getMaskSet().validPositions[pos - 1].alternation === tests[0].alternation) return [ determineTestTemplate(tests) ];\n                    if (getMaskSet().validPositions[pos - 1]) return [ determineTestTemplate(tests) ];\n                }\n                return tests;\n            }\n            var latestMatch, maskTokens = getMaskSet().maskToken, testPos = ndxIntlzr ? tstPs : 0, ndxInitializer = ndxIntlzr ? ndxIntlzr.slice() : [ 0 ], matches = [], insertStop = !1, cacheDependency = ndxIntlzr ? ndxIntlzr.join(\"\") : \"\";\n            if (pos > -1) {\n                if (ndxIntlzr === undefined) {\n                    for (var test, previousPos = pos - 1; (test = getMaskSet().validPositions[previousPos] || getMaskSet().tests[previousPos]) === undefined && previousPos > -1; ) previousPos--;\n                    test !== undefined && previousPos > -1 && (ndxInitializer = function(tests) {\n                        var locator = [];\n                        return $.isArray(tests) || (tests = [ tests ]), tests.length > 0 && (tests[0].alternation === undefined ? (locator = determineTestTemplate(tests.slice()).locator.slice(), \n                        0 === locator.length && (locator = tests[0].locator.slice())) : $.each(tests, function(ndx, tst) {\n                            if (\"\" !== tst.def) if (0 === locator.length) locator = tst.locator.slice(); else for (var i = 0; i < locator.length; i++) tst.locator[i] && -1 === locator[i].toString().indexOf(tst.locator[i]) && (locator[i] += \",\" + tst.locator[i]);\n                        })), locator;\n                    }(test), cacheDependency = ndxInitializer.join(\"\"), testPos = previousPos);\n                }\n                if (getMaskSet().tests[pos] && getMaskSet().tests[pos][0].cd === cacheDependency) return filterTests(getMaskSet().tests[pos]);\n                for (var mtndx = ndxInitializer.shift(); mtndx < maskTokens.length; mtndx++) {\n                    if (resolveTestFromToken(maskTokens[mtndx], ndxInitializer, [ mtndx ]) && testPos === pos || testPos > pos) break;\n                }\n            }\n            return (0 === matches.length || insertStop) && matches.push({\n                match: {\n                    fn: null,\n                    cardinality: 0,\n                    optionality: !0,\n                    casing: null,\n                    def: \"\",\n                    placeholder: \"\"\n                },\n                locator: [],\n                cd: cacheDependency\n            }), ndxIntlzr !== undefined && getMaskSet().tests[pos] ? filterTests($.extend(!0, [], matches)) : (getMaskSet().tests[pos] = $.extend(!0, [], matches), \n            filterTests(getMaskSet().tests[pos]));\n        }\n        function getBufferTemplate() {\n            return getMaskSet()._buffer === undefined && (getMaskSet()._buffer = getMaskTemplate(!1, 1), \n            getMaskSet().buffer === undefined && (getMaskSet().buffer = getMaskSet()._buffer.slice())), \n            getMaskSet()._buffer;\n        }\n        function getBuffer(noCache) {\n            return getMaskSet().buffer !== undefined && !0 !== noCache || (getMaskSet().buffer = getMaskTemplate(!0, getLastValidPosition(), !0)), \n            getMaskSet().buffer;\n        }\n        function refreshFromBuffer(start, end, buffer) {\n            var i, p;\n            if (!0 === start) resetMaskSet(), start = 0, end = buffer.length; else for (i = start; i < end; i++) delete getMaskSet().validPositions[i];\n            for (p = start, i = start; i < end; i++) if (resetMaskSet(!0), buffer[i] !== opts.skipOptionalPartCharacter) {\n                var valResult = isValid(p, buffer[i], !0, !0);\n                !1 !== valResult && (resetMaskSet(!0), p = valResult.caret !== undefined ? valResult.caret : valResult.pos + 1);\n            }\n        }\n        function casing(elem, test, pos) {\n            switch (opts.casing || test.casing) {\n              case \"upper\":\n                elem = elem.toUpperCase();\n                break;\n\n              case \"lower\":\n                elem = elem.toLowerCase();\n                break;\n\n              case \"title\":\n                var posBefore = getMaskSet().validPositions[pos - 1];\n                elem = 0 === pos || posBefore && posBefore.input === String.fromCharCode(Inputmask.keyCode.SPACE) ? elem.toUpperCase() : elem.toLowerCase();\n                break;\n\n              default:\n                if ($.isFunction(opts.casing)) {\n                    var args = Array.prototype.slice.call(arguments);\n                    args.push(getMaskSet().validPositions), elem = opts.casing.apply(this, args);\n                }\n            }\n            return elem;\n        }\n        function checkAlternationMatch(altArr1, altArr2, na) {\n            for (var naNdx, altArrC = opts.greedy ? altArr2 : altArr2.slice(0, 1), isMatch = !1, naArr = na !== undefined ? na.split(\",\") : [], i = 0; i < naArr.length; i++) -1 !== (naNdx = altArr1.indexOf(naArr[i])) && altArr1.splice(naNdx, 1);\n            for (var alndx = 0; alndx < altArr1.length; alndx++) if (-1 !== $.inArray(altArr1[alndx], altArrC)) {\n                isMatch = !0;\n                break;\n            }\n            return isMatch;\n        }\n        function isValid(pos, c, strict, fromSetValid, fromAlternate) {\n            function isSelection(posObj) {\n                var selection = isRTL ? posObj.begin - posObj.end > 1 || posObj.begin - posObj.end == 1 : posObj.end - posObj.begin > 1 || posObj.end - posObj.begin == 1;\n                return selection && 0 === posObj.begin && posObj.end === getMaskSet().maskLength ? \"full\" : selection;\n            }\n            function _isValid(position, c, strict) {\n                var rslt = !1;\n                return $.each(getTests(position), function(ndx, tst) {\n                    for (var test = tst.match, loopend = c ? 1 : 0, chrs = \"\", i = test.cardinality; i > loopend; i--) chrs += getBufferElement(position - (i - 1));\n                    if (c && (chrs += c), getBuffer(!0), !1 !== (rslt = null != test.fn ? test.fn.test(chrs, getMaskSet(), position, strict, opts, isSelection(pos)) : (c === test.def || c === opts.skipOptionalPartCharacter) && \"\" !== test.def && {\n                        c: getPlaceholder(position, test, !0) || test.def,\n                        pos: position\n                    })) {\n                        var elem = rslt.c !== undefined ? rslt.c : c;\n                        elem = elem === opts.skipOptionalPartCharacter && null === test.fn ? getPlaceholder(position, test, !0) || test.def : elem;\n                        var validatedPos = position, possibleModifiedBuffer = getBuffer();\n                        if (rslt.remove !== undefined && ($.isArray(rslt.remove) || (rslt.remove = [ rslt.remove ]), \n                        $.each(rslt.remove.sort(function(a, b) {\n                            return b - a;\n                        }), function(ndx, lmnt) {\n                            stripValidPositions(lmnt, lmnt + 1, !0);\n                        })), rslt.insert !== undefined && ($.isArray(rslt.insert) || (rslt.insert = [ rslt.insert ]), \n                        $.each(rslt.insert.sort(function(a, b) {\n                            return a - b;\n                        }), function(ndx, lmnt) {\n                            isValid(lmnt.pos, lmnt.c, !0, fromSetValid);\n                        })), rslt.refreshFromBuffer) {\n                            var refresh = rslt.refreshFromBuffer;\n                            if (refreshFromBuffer(!0 === refresh ? refresh : refresh.start, refresh.end, possibleModifiedBuffer), \n                            rslt.pos === undefined && rslt.c === undefined) return rslt.pos = getLastValidPosition(), \n                            !1;\n                            if ((validatedPos = rslt.pos !== undefined ? rslt.pos : position) !== position) return rslt = $.extend(rslt, isValid(validatedPos, elem, !0, fromSetValid)), \n                            !1;\n                        } else if (!0 !== rslt && rslt.pos !== undefined && rslt.pos !== position && (validatedPos = rslt.pos, \n                        refreshFromBuffer(position, validatedPos, getBuffer().slice()), validatedPos !== position)) return rslt = $.extend(rslt, isValid(validatedPos, elem, !0)), \n                        !1;\n                        return (!0 === rslt || rslt.pos !== undefined || rslt.c !== undefined) && (ndx > 0 && resetMaskSet(!0), \n                        setValidPosition(validatedPos, $.extend({}, tst, {\n                            input: casing(elem, test, validatedPos)\n                        }), fromSetValid, isSelection(pos)) || (rslt = !1), !1);\n                    }\n                }), rslt;\n            }\n            function setValidPosition(pos, validTest, fromSetValid, isSelection) {\n                if (isSelection || opts.insertMode && getMaskSet().validPositions[pos] !== undefined && fromSetValid === undefined) {\n                    var i, positionsClone = $.extend(!0, {}, getMaskSet().validPositions), lvp = getLastValidPosition(undefined, !0);\n                    for (i = pos; i <= lvp; i++) delete getMaskSet().validPositions[i];\n                    getMaskSet().validPositions[pos] = $.extend(!0, {}, validTest);\n                    var j, valid = !0, vps = getMaskSet().validPositions, needsValidation = !1, initialLength = getMaskSet().maskLength;\n                    for (i = j = pos; i <= lvp; i++) {\n                        var t = positionsClone[i];\n                        if (t !== undefined) for (var posMatch = j; posMatch < getMaskSet().maskLength && (null === t.match.fn && vps[i] && (!0 === vps[i].match.optionalQuantifier || !0 === vps[i].match.optionality) || null != t.match.fn); ) {\n                            if (posMatch++, !1 === needsValidation && positionsClone[posMatch] && positionsClone[posMatch].match.def === t.match.def) getMaskSet().validPositions[posMatch] = $.extend(!0, {}, positionsClone[posMatch]), \n                            getMaskSet().validPositions[posMatch].input = t.input, fillMissingNonMask(posMatch), \n                            j = posMatch, valid = !0; else if (positionCanMatchDefinition(posMatch, t.match.def)) {\n                                var result = isValid(posMatch, t.input, !0, !0);\n                                valid = !1 !== result, j = result.caret || result.insert ? getLastValidPosition() : posMatch, \n                                needsValidation = !0;\n                            } else if (!(valid = !0 === t.generatedInput) && posMatch >= getMaskSet().maskLength - 1) break;\n                            if (getMaskSet().maskLength < initialLength && (getMaskSet().maskLength = initialLength), \n                            valid) break;\n                        }\n                        if (!valid) break;\n                    }\n                    if (!valid) return getMaskSet().validPositions = $.extend(!0, {}, positionsClone), \n                    resetMaskSet(!0), !1;\n                } else getMaskSet().validPositions[pos] = $.extend(!0, {}, validTest);\n                return resetMaskSet(!0), !0;\n            }\n            function fillMissingNonMask(maskPos) {\n                for (var pndx = maskPos - 1; pndx > -1 && !getMaskSet().validPositions[pndx]; pndx--) ;\n                var testTemplate, testsFromPos;\n                for (pndx++; pndx < maskPos; pndx++) getMaskSet().validPositions[pndx] === undefined && (!1 === opts.jitMasking || opts.jitMasking > pndx) && (testsFromPos = getTests(pndx, getTestTemplate(pndx - 1).locator, pndx - 1).slice(), \n                \"\" === testsFromPos[testsFromPos.length - 1].match.def && testsFromPos.pop(), (testTemplate = determineTestTemplate(testsFromPos)) && (testTemplate.match.def === opts.radixPointDefinitionSymbol || !isMask(pndx, !0) || $.inArray(opts.radixPoint, getBuffer()) < pndx && testTemplate.match.fn && testTemplate.match.fn.test(getPlaceholder(pndx), getMaskSet(), pndx, !1, opts)) && !1 !== (result = _isValid(pndx, getPlaceholder(pndx, testTemplate.match, !0) || (null == testTemplate.match.fn ? testTemplate.match.def : \"\" !== getPlaceholder(pndx) ? getPlaceholder(pndx) : getBuffer()[pndx]), !0)) && (getMaskSet().validPositions[result.pos || pndx].generatedInput = !0));\n            }\n            strict = !0 === strict;\n            var maskPos = pos;\n            pos.begin !== undefined && (maskPos = isRTL && !isSelection(pos) ? pos.end : pos.begin);\n            var result = !0, positionsClone = $.extend(!0, {}, getMaskSet().validPositions);\n            if ($.isFunction(opts.preValidation) && !strict && !0 !== fromSetValid && (result = opts.preValidation(getBuffer(), maskPos, c, isSelection(pos), opts)), \n            !0 === result) {\n                if (fillMissingNonMask(maskPos), isSelection(pos) && (handleRemove(undefined, Inputmask.keyCode.DELETE, pos, !0), \n                maskPos = getMaskSet().p), maskPos < getMaskSet().maskLength && (maxLength === undefined || maskPos < maxLength) && (result = _isValid(maskPos, c, strict), \n                (!strict || !0 === fromSetValid) && !1 === result)) {\n                    var currentPosValid = getMaskSet().validPositions[maskPos];\n                    if (!currentPosValid || null !== currentPosValid.match.fn || currentPosValid.match.def !== c && c !== opts.skipOptionalPartCharacter) {\n                        if ((opts.insertMode || getMaskSet().validPositions[seekNext(maskPos)] === undefined) && !isMask(maskPos, !0)) for (var nPos = maskPos + 1, snPos = seekNext(maskPos); nPos <= snPos; nPos++) if (!1 !== (result = _isValid(nPos, c, strict))) {\n                            !function(originalPos, newPos) {\n                                var vp = getMaskSet().validPositions[newPos];\n                                if (vp) for (var targetLocator = vp.locator, tll = targetLocator.length, ps = originalPos; ps < newPos; ps++) if (getMaskSet().validPositions[ps] === undefined && !isMask(ps, !0)) {\n                                    var tests = getTests(ps).slice(), bestMatch = determineTestTemplate(tests, !0), equality = -1;\n                                    \"\" === tests[tests.length - 1].match.def && tests.pop(), $.each(tests, function(ndx, tst) {\n                                        for (var i = 0; i < tll; i++) {\n                                            if (tst.locator[i] === undefined || !checkAlternationMatch(tst.locator[i].toString().split(\",\"), targetLocator[i].toString().split(\",\"), tst.na)) {\n                                                var targetAI = targetLocator[i], bestMatchAI = bestMatch.locator[i], tstAI = tst.locator[i];\n                                                targetAI - bestMatchAI > Math.abs(targetAI - tstAI) && (bestMatch = tst);\n                                                break;\n                                            }\n                                            equality < i && (equality = i, bestMatch = tst);\n                                        }\n                                    }), bestMatch = $.extend({}, bestMatch, {\n                                        input: getPlaceholder(ps, bestMatch.match, !0) || bestMatch.match.def\n                                    }), bestMatch.generatedInput = !0, setValidPosition(ps, bestMatch, !0), getMaskSet().validPositions[newPos] = undefined, \n                                    _isValid(newPos, vp.input, !0);\n                                }\n                            }(maskPos, result.pos !== undefined ? result.pos : nPos), maskPos = nPos;\n                            break;\n                        }\n                    } else result = {\n                        caret: seekNext(maskPos)\n                    };\n                }\n                !1 === result && opts.keepStatic && !strict && !0 !== fromAlternate && (result = function(pos, c, strict) {\n                    var lastAlt, alternation, altPos, prevAltPos, i, validPos, altNdxs, decisionPos, validPsClone = $.extend(!0, {}, getMaskSet().validPositions), isValidRslt = !1, lAltPos = getLastValidPosition();\n                    for (prevAltPos = getMaskSet().validPositions[lAltPos]; lAltPos >= 0; lAltPos--) if ((altPos = getMaskSet().validPositions[lAltPos]) && altPos.alternation !== undefined) {\n                        if (lastAlt = lAltPos, alternation = getMaskSet().validPositions[lastAlt].alternation, \n                        prevAltPos.locator[altPos.alternation] !== altPos.locator[altPos.alternation]) break;\n                        prevAltPos = altPos;\n                    }\n                    if (alternation !== undefined) {\n                        decisionPos = parseInt(lastAlt);\n                        var decisionTaker = prevAltPos.locator[prevAltPos.alternation || alternation] !== undefined ? prevAltPos.locator[prevAltPos.alternation || alternation] : altNdxs[0];\n                        decisionTaker.length > 0 && (decisionTaker = decisionTaker.split(\",\")[0]);\n                        var possibilityPos = getMaskSet().validPositions[decisionPos], prevPos = getMaskSet().validPositions[decisionPos - 1];\n                        $.each(getTests(decisionPos, prevPos ? prevPos.locator : undefined, decisionPos - 1), function(ndx, test) {\n                            altNdxs = test.locator[alternation] ? test.locator[alternation].toString().split(\",\") : [];\n                            for (var mndx = 0; mndx < altNdxs.length; mndx++) {\n                                var validInputs = [], staticInputsBeforePos = 0, staticInputsBeforePosAlternate = 0, verifyValidInput = !1;\n                                if (decisionTaker < altNdxs[mndx] && (test.na === undefined || -1 === $.inArray(altNdxs[mndx], test.na.split(\",\")) || -1 === $.inArray(decisionTaker.toString(), altNdxs))) {\n                                    getMaskSet().validPositions[decisionPos] = $.extend(!0, {}, test);\n                                    var possibilities = getMaskSet().validPositions[decisionPos].locator;\n                                    for (getMaskSet().validPositions[decisionPos].locator[alternation] = parseInt(altNdxs[mndx]), \n                                    null == test.match.fn ? (possibilityPos.input !== test.match.def && (verifyValidInput = !0, \n                                    !0 !== possibilityPos.generatedInput && validInputs.push(possibilityPos.input)), \n                                    staticInputsBeforePosAlternate++, getMaskSet().validPositions[decisionPos].generatedInput = !/[0-9a-bA-Z]/.test(test.match.def), \n                                    getMaskSet().validPositions[decisionPos].input = test.match.def) : getMaskSet().validPositions[decisionPos].input = possibilityPos.input, \n                                    i = decisionPos + 1; i < getLastValidPosition(undefined, !0) + 1; i++) validPos = getMaskSet().validPositions[i], \n                                    validPos && !0 !== validPos.generatedInput && /[0-9a-bA-Z]/.test(validPos.input) ? validInputs.push(validPos.input) : i < pos && staticInputsBeforePos++, \n                                    delete getMaskSet().validPositions[i];\n                                    for (verifyValidInput && validInputs[0] === test.match.def && validInputs.shift(), \n                                    resetMaskSet(!0), isValidRslt = !0; validInputs.length > 0; ) {\n                                        var input = validInputs.shift();\n                                        if (input !== opts.skipOptionalPartCharacter && !(isValidRslt = isValid(getLastValidPosition(undefined, !0) + 1, input, !1, fromSetValid, !0))) break;\n                                    }\n                                    if (isValidRslt) {\n                                        getMaskSet().validPositions[decisionPos].locator = possibilities;\n                                        var targetLvp = getLastValidPosition(pos) + 1;\n                                        for (i = decisionPos + 1; i < getLastValidPosition() + 1; i++) ((validPos = getMaskSet().validPositions[i]) === undefined || null == validPos.match.fn) && i < pos + (staticInputsBeforePosAlternate - staticInputsBeforePos) && staticInputsBeforePosAlternate++;\n                                        pos += staticInputsBeforePosAlternate - staticInputsBeforePos, isValidRslt = isValid(pos > targetLvp ? targetLvp : pos, c, strict, fromSetValid, !0);\n                                    }\n                                    if (isValidRslt) return !1;\n                                    resetMaskSet(), getMaskSet().validPositions = $.extend(!0, {}, validPsClone);\n                                }\n                            }\n                        });\n                    }\n                    return isValidRslt;\n                }(maskPos, c, strict)), !0 === result && (result = {\n                    pos: maskPos\n                });\n            }\n            if ($.isFunction(opts.postValidation) && !1 !== result && !strict && !0 !== fromSetValid) {\n                var postResult = opts.postValidation(getBuffer(!0), result, opts);\n                if (postResult.refreshFromBuffer && postResult.buffer) {\n                    var refresh = postResult.refreshFromBuffer;\n                    refreshFromBuffer(!0 === refresh ? refresh : refresh.start, refresh.end, postResult.buffer);\n                }\n                result = !0 === postResult ? result : postResult;\n            }\n            return result && result.pos === undefined && (result.pos = maskPos), !1 === result && (resetMaskSet(!0), \n            getMaskSet().validPositions = $.extend(!0, {}, positionsClone)), result;\n        }\n        function isMask(pos, strict) {\n            var test = getTestTemplate(pos).match;\n            if (\"\" === test.def && (test = getTest(pos).match), null != test.fn) return test.fn;\n            if (!0 !== strict && pos > -1) {\n                var tests = getTests(pos);\n                return tests.length > 1 + (\"\" === tests[tests.length - 1].match.def ? 1 : 0);\n            }\n            return !1;\n        }\n        function seekNext(pos, newBlock) {\n            var maskL = getMaskSet().maskLength;\n            if (pos >= maskL) return maskL;\n            var position = pos;\n            for (getTests(maskL + 1).length > 1 && (getMaskTemplate(!0, maskL + 1, !0), maskL = getMaskSet().maskLength); ++position < maskL && (!0 === newBlock && (!0 !== getTest(position).match.newBlockMarker || !isMask(position)) || !0 !== newBlock && !isMask(position)); ) ;\n            return position;\n        }\n        function seekPrevious(pos, newBlock) {\n            var tests, position = pos;\n            if (position <= 0) return 0;\n            for (;--position > 0 && (!0 === newBlock && !0 !== getTest(position).match.newBlockMarker || !0 !== newBlock && !isMask(position) && (tests = getTests(position), \n            tests.length < 2 || 2 === tests.length && \"\" === tests[1].match.def)); ) ;\n            return position;\n        }\n        function getBufferElement(position) {\n            return getMaskSet().validPositions[position] === undefined ? getPlaceholder(position) : getMaskSet().validPositions[position].input;\n        }\n        function writeBuffer(input, buffer, caretPos, event, triggerInputEvent) {\n            if (event && $.isFunction(opts.onBeforeWrite)) {\n                var result = opts.onBeforeWrite(event, buffer, caretPos, opts);\n                if (result) {\n                    if (result.refreshFromBuffer) {\n                        var refresh = result.refreshFromBuffer;\n                        refreshFromBuffer(!0 === refresh ? refresh : refresh.start, refresh.end, result.buffer || buffer), \n                        buffer = getBuffer(!0);\n                    }\n                    caretPos !== undefined && (caretPos = result.caret !== undefined ? result.caret : caretPos);\n                }\n            }\n            input !== undefined && (input.inputmask._valueSet(buffer.join(\"\")), caretPos === undefined || event !== undefined && \"blur\" === event.type ? renderColorMask(input, buffer, caretPos) : android && \"input\" === event.type ? setTimeout(function() {\n                caret(input, caretPos);\n            }, 0) : caret(input, caretPos), !0 === triggerInputEvent && (skipInputEvent = !0, \n            $(input).trigger(\"input\")));\n        }\n        function getPlaceholder(pos, test, returnPL) {\n            if (test = test || getTest(pos).match, test.placeholder !== undefined || !0 === returnPL) return $.isFunction(test.placeholder) ? test.placeholder(opts) : test.placeholder;\n            if (null === test.fn) {\n                if (pos > -1 && getMaskSet().validPositions[pos] === undefined) {\n                    var prevTest, tests = getTests(pos), staticAlternations = [];\n                    if (tests.length > 1 + (\"\" === tests[tests.length - 1].match.def ? 1 : 0)) for (var i = 0; i < tests.length; i++) if (!0 !== tests[i].match.optionality && !0 !== tests[i].match.optionalQuantifier && (null === tests[i].match.fn || prevTest === undefined || !1 !== tests[i].match.fn.test(prevTest.match.def, getMaskSet(), pos, !0, opts)) && (staticAlternations.push(tests[i]), \n                    null === tests[i].match.fn && (prevTest = tests[i]), staticAlternations.length > 1 && /[0-9a-bA-Z]/.test(staticAlternations[0].match.def))) return opts.placeholder.charAt(pos % opts.placeholder.length);\n                }\n                return test.def;\n            }\n            return opts.placeholder.charAt(pos % opts.placeholder.length);\n        }\n        function checkVal(input, writeOut, strict, nptvl, initiatingEvent) {\n            function isTemplateMatch(ndx, charCodes) {\n                return -1 !== getBufferTemplate().slice(ndx, seekNext(ndx)).join(\"\").indexOf(charCodes) && !isMask(ndx) && getTest(ndx).match.nativeDef === charCodes.charAt(charCodes.length - 1);\n            }\n            var inputValue = nptvl.slice(), charCodes = \"\", initialNdx = 0, result = undefined;\n            if (resetMaskSet(), getMaskSet().p = seekNext(-1), !strict) if (!0 !== opts.autoUnmask) {\n                var staticInput = getBufferTemplate().slice(0, seekNext(-1)).join(\"\"), matches = inputValue.join(\"\").match(new RegExp(\"^\" + Inputmask.escapeRegex(staticInput), \"g\"));\n                matches && matches.length > 0 && (inputValue.splice(0, matches.length * staticInput.length), \n                initialNdx = seekNext(initialNdx));\n            } else initialNdx = seekNext(initialNdx);\n            if ($.each(inputValue, function(ndx, charCode) {\n                if (charCode !== undefined) {\n                    var keypress = new $.Event(\"_checkval\");\n                    keypress.which = charCode.charCodeAt(0), charCodes += charCode;\n                    var lvp = getLastValidPosition(undefined, !0), lvTest = getMaskSet().validPositions[lvp], nextTest = getTestTemplate(lvp + 1, lvTest ? lvTest.locator.slice() : undefined, lvp);\n                    if (!isTemplateMatch(initialNdx, charCodes) || strict || opts.autoUnmask) {\n                        var pos = strict ? ndx : null == nextTest.match.fn && nextTest.match.optionality && lvp + 1 < getMaskSet().p ? lvp + 1 : getMaskSet().p;\n                        result = EventHandlers.keypressEvent.call(input, keypress, !0, !1, strict, pos), \n                        initialNdx = pos + 1, charCodes = \"\";\n                    } else result = EventHandlers.keypressEvent.call(input, keypress, !0, !1, !0, lvp + 1);\n                    if (!1 !== result && !strict && $.isFunction(opts.onBeforeWrite)) {\n                        var fp = result.forwardPosition;\n                        if (result = opts.onBeforeWrite(keypress, getBuffer(), result.forwardPosition, opts), \n                        result.forwardPosition = fp, result && result.refreshFromBuffer) {\n                            var refresh = result.refreshFromBuffer;\n                            refreshFromBuffer(!0 === refresh ? refresh : refresh.start, refresh.end, result.buffer), \n                            resetMaskSet(!0), result.caret && (getMaskSet().p = result.caret, result.forwardPosition = result.caret);\n                        }\n                    }\n                }\n            }), writeOut) {\n                var caretPos = undefined;\n                document.activeElement === input && result && (caretPos = opts.numericInput ? seekPrevious(result.forwardPosition) : result.forwardPosition), \n                writeBuffer(input, getBuffer(), caretPos, initiatingEvent || new $.Event(\"checkval\"), initiatingEvent && \"input\" === initiatingEvent.type);\n            }\n        }\n        function unmaskedvalue(input) {\n            if (input) {\n                if (input.inputmask === undefined) return input.value;\n                input.inputmask && input.inputmask.refreshValue && EventHandlers.setValueEvent.call(input);\n            }\n            var umValue = [], vps = getMaskSet().validPositions;\n            for (var pndx in vps) vps[pndx].match && null != vps[pndx].match.fn && umValue.push(vps[pndx].input);\n            var unmaskedValue = 0 === umValue.length ? \"\" : (isRTL ? umValue.reverse() : umValue).join(\"\");\n            if ($.isFunction(opts.onUnMask)) {\n                var bufferValue = (isRTL ? getBuffer().slice().reverse() : getBuffer()).join(\"\");\n                unmaskedValue = opts.onUnMask(bufferValue, unmaskedValue, opts);\n            }\n            return unmaskedValue;\n        }\n        function caret(input, begin, end, notranslate) {\n            function translatePosition(pos) {\n                if (!0 !== notranslate && isRTL && \"number\" == typeof pos && (!opts.greedy || \"\" !== opts.placeholder)) {\n                    pos = getBuffer().join(\"\").length - pos;\n                }\n                return pos;\n            }\n            var range;\n            if (begin === undefined) return input.setSelectionRange ? (begin = input.selectionStart, \n            end = input.selectionEnd) : window.getSelection ? (range = window.getSelection().getRangeAt(0), \n            range.commonAncestorContainer.parentNode !== input && range.commonAncestorContainer !== input || (begin = range.startOffset, \n            end = range.endOffset)) : document.selection && document.selection.createRange && (range = document.selection.createRange(), \n            begin = 0 - range.duplicate().moveStart(\"character\", -input.inputmask._valueGet().length), \n            end = begin + range.text.length), {\n                begin: translatePosition(begin),\n                end: translatePosition(end)\n            };\n            if (begin.begin !== undefined && (end = begin.end, begin = begin.begin), \"number\" == typeof begin) {\n                begin = translatePosition(begin), end = translatePosition(end), end = \"number\" == typeof end ? end : begin;\n                var scrollCalc = parseInt(((input.ownerDocument.defaultView || window).getComputedStyle ? (input.ownerDocument.defaultView || window).getComputedStyle(input, null) : input.currentStyle).fontSize) * end;\n                if (input.scrollLeft = scrollCalc > input.scrollWidth ? scrollCalc : 0, mobile || !1 !== opts.insertMode || begin !== end || end++, \n                input.setSelectionRange) input.selectionStart = begin, input.selectionEnd = end; else if (window.getSelection) {\n                    if (range = document.createRange(), input.firstChild === undefined || null === input.firstChild) {\n                        var textNode = document.createTextNode(\"\");\n                        input.appendChild(textNode);\n                    }\n                    range.setStart(input.firstChild, begin < input.inputmask._valueGet().length ? begin : input.inputmask._valueGet().length), \n                    range.setEnd(input.firstChild, end < input.inputmask._valueGet().length ? end : input.inputmask._valueGet().length), \n                    range.collapse(!0);\n                    var sel = window.getSelection();\n                    sel.removeAllRanges(), sel.addRange(range);\n                } else input.createTextRange && (range = input.createTextRange(), range.collapse(!0), \n                range.moveEnd(\"character\", end), range.moveStart(\"character\", begin), range.select());\n                renderColorMask(input, undefined, {\n                    begin: begin,\n                    end: end\n                });\n            }\n        }\n        function determineLastRequiredPosition(returnDefinition) {\n            var pos, testPos, buffer = getBuffer(), bl = buffer.length, lvp = getLastValidPosition(), positions = {}, lvTest = getMaskSet().validPositions[lvp], ndxIntlzr = lvTest !== undefined ? lvTest.locator.slice() : undefined;\n            for (pos = lvp + 1; pos < buffer.length; pos++) testPos = getTestTemplate(pos, ndxIntlzr, pos - 1), \n            ndxIntlzr = testPos.locator.slice(), positions[pos] = $.extend(!0, {}, testPos);\n            var lvTestAlt = lvTest && lvTest.alternation !== undefined ? lvTest.locator[lvTest.alternation] : undefined;\n            for (pos = bl - 1; pos > lvp && (testPos = positions[pos], (testPos.match.optionality || testPos.match.optionalQuantifier && testPos.match.newBlockMarker || lvTestAlt && (lvTestAlt !== positions[pos].locator[lvTest.alternation] && null != testPos.match.fn || null === testPos.match.fn && testPos.locator[lvTest.alternation] && checkAlternationMatch(testPos.locator[lvTest.alternation].toString().split(\",\"), lvTestAlt.toString().split(\",\")) && \"\" !== getTests(pos)[0].def)) && buffer[pos] === getPlaceholder(pos, testPos.match)); pos--) bl--;\n            return returnDefinition ? {\n                l: bl,\n                def: positions[bl] ? positions[bl].match : undefined\n            } : bl;\n        }\n        function clearOptionalTail(buffer) {\n            for (var validPos, rl = determineLastRequiredPosition(), bl = buffer.length, lv = getMaskSet().validPositions[getLastValidPosition()]; rl < bl && !isMask(rl, !0) && (validPos = lv !== undefined ? getTestTemplate(rl, lv.locator.slice(\"\"), lv) : getTest(rl)) && !0 !== validPos.match.optionality && (!0 !== validPos.match.optionalQuantifier && !0 !== validPos.match.newBlockMarker || rl + 1 === bl && \"\" === (lv !== undefined ? getTestTemplate(rl + 1, lv.locator.slice(\"\"), lv) : getTest(rl + 1)).match.def); ) rl++;\n            for (;(validPos = getMaskSet().validPositions[rl - 1]) && validPos && validPos.match.optionality && validPos.input === opts.skipOptionalPartCharacter; ) rl--;\n            return buffer.splice(rl), buffer;\n        }\n        function isComplete(buffer) {\n            if ($.isFunction(opts.isComplete)) return opts.isComplete(buffer, opts);\n            if (\"*\" === opts.repeat) return undefined;\n            var complete = !1, lrp = determineLastRequiredPosition(!0), aml = seekPrevious(lrp.l);\n            if (lrp.def === undefined || lrp.def.newBlockMarker || lrp.def.optionality || lrp.def.optionalQuantifier) {\n                complete = !0;\n                for (var i = 0; i <= aml; i++) {\n                    var test = getTestTemplate(i).match;\n                    if (null !== test.fn && getMaskSet().validPositions[i] === undefined && !0 !== test.optionality && !0 !== test.optionalQuantifier || null === test.fn && buffer[i] !== getPlaceholder(i, test)) {\n                        complete = !1;\n                        break;\n                    }\n                }\n            }\n            return complete;\n        }\n        function handleRemove(input, k, pos, strict, fromIsValid) {\n            if ((opts.numericInput || isRTL) && (k === Inputmask.keyCode.BACKSPACE ? k = Inputmask.keyCode.DELETE : k === Inputmask.keyCode.DELETE && (k = Inputmask.keyCode.BACKSPACE), \n            isRTL)) {\n                var pend = pos.end;\n                pos.end = pos.begin, pos.begin = pend;\n            }\n            k === Inputmask.keyCode.BACKSPACE && (pos.end - pos.begin < 1 || !1 === opts.insertMode) ? (pos.begin = seekPrevious(pos.begin), \n            getMaskSet().validPositions[pos.begin] !== undefined && getMaskSet().validPositions[pos.begin].input === opts.groupSeparator && pos.begin--) : k === Inputmask.keyCode.DELETE && pos.begin === pos.end && (pos.end = isMask(pos.end, !0) && getMaskSet().validPositions[pos.end] && getMaskSet().validPositions[pos.end].input !== opts.radixPoint ? pos.end + 1 : seekNext(pos.end) + 1, \n            getMaskSet().validPositions[pos.begin] !== undefined && getMaskSet().validPositions[pos.begin].input === opts.groupSeparator && pos.end++), \n            stripValidPositions(pos.begin, pos.end, !1, strict), !0 !== strict && function() {\n                if (opts.keepStatic) {\n                    for (var validInputs = [], lastAlt = getLastValidPosition(-1, !0), positionsClone = $.extend(!0, {}, getMaskSet().validPositions), prevAltPos = getMaskSet().validPositions[lastAlt]; lastAlt >= 0; lastAlt--) {\n                        var altPos = getMaskSet().validPositions[lastAlt];\n                        if (altPos) {\n                            if (!0 !== altPos.generatedInput && /[0-9a-bA-Z]/.test(altPos.input) && validInputs.push(altPos.input), \n                            delete getMaskSet().validPositions[lastAlt], altPos.alternation !== undefined && altPos.locator[altPos.alternation] !== prevAltPos.locator[altPos.alternation]) break;\n                            prevAltPos = altPos;\n                        }\n                    }\n                    if (lastAlt > -1) for (getMaskSet().p = seekNext(getLastValidPosition(-1, !0)); validInputs.length > 0; ) {\n                        var keypress = new $.Event(\"keypress\");\n                        keypress.which = validInputs.pop().charCodeAt(0), EventHandlers.keypressEvent.call(input, keypress, !0, !1, !1, getMaskSet().p);\n                    } else getMaskSet().validPositions = $.extend(!0, {}, positionsClone);\n                }\n            }();\n            var lvp = getLastValidPosition(pos.begin, !0);\n            if (lvp < pos.begin) getMaskSet().p = seekNext(lvp); else if (!0 !== strict && (getMaskSet().p = pos.begin, \n            !0 !== fromIsValid)) for (;getMaskSet().p < lvp && getMaskSet().validPositions[getMaskSet().p] === undefined; ) getMaskSet().p++;\n        }\n        function initializeColorMask(input) {\n            function findCaretPos(clientx) {\n                var caretPos, e = document.createElement(\"span\");\n                for (var style in computedStyle) isNaN(style) && -1 !== style.indexOf(\"font\") && (e.style[style] = computedStyle[style]);\n                e.style.textTransform = computedStyle.textTransform, e.style.letterSpacing = computedStyle.letterSpacing, \n                e.style.position = \"absolute\", e.style.height = \"auto\", e.style.width = \"auto\", \n                e.style.visibility = \"hidden\", e.style.whiteSpace = \"nowrap\", document.body.appendChild(e);\n                var itl, inputText = input.inputmask._valueGet(), previousWidth = 0;\n                for (caretPos = 0, itl = inputText.length; caretPos <= itl; caretPos++) {\n                    if (e.innerHTML += inputText.charAt(caretPos) || \"_\", e.offsetWidth >= clientx) {\n                        var offset1 = clientx - previousWidth, offset2 = e.offsetWidth - clientx;\n                        e.innerHTML = inputText.charAt(caretPos), offset1 -= e.offsetWidth / 3, caretPos = offset1 < offset2 ? caretPos - 1 : caretPos;\n                        break;\n                    }\n                    previousWidth = e.offsetWidth;\n                }\n                return document.body.removeChild(e), caretPos;\n            }\n            function position() {\n                colorMask.style.position = \"absolute\", colorMask.style.top = offset.top + \"px\", \n                colorMask.style.left = offset.left + \"px\", colorMask.style.width = parseInt(input.offsetWidth) - parseInt(computedStyle.paddingLeft) - parseInt(computedStyle.paddingRight) - parseInt(computedStyle.borderLeftWidth) - parseInt(computedStyle.borderRightWidth) + \"px\", \n                colorMask.style.height = parseInt(input.offsetHeight) - parseInt(computedStyle.paddingTop) - parseInt(computedStyle.paddingBottom) - parseInt(computedStyle.borderTopWidth) - parseInt(computedStyle.borderBottomWidth) + \"px\", \n                colorMask.style.lineHeight = colorMask.style.height, colorMask.style.zIndex = isNaN(computedStyle.zIndex) ? -1 : computedStyle.zIndex - 1, \n                colorMask.style.webkitAppearance = \"textfield\", colorMask.style.mozAppearance = \"textfield\", \n                colorMask.style.Appearance = \"textfield\";\n            }\n            var offset = $(input).position(), computedStyle = (input.ownerDocument.defaultView || window).getComputedStyle(input, null);\n            colorMask = document.createElement(\"div\"), document.body.appendChild(colorMask);\n            for (var style in computedStyle) computedStyle.hasOwnProperty(style) && isNaN(style) && \"cssText\" !== style && -1 == style.indexOf(\"webkit\") && (colorMask.style[style] = computedStyle[style]);\n            input.style.backgroundColor = \"transparent\", input.style.color = \"transparent\", \n            input.style.webkitAppearance = \"caret\", input.style.mozAppearance = \"caret\", input.style.Appearance = \"caret\", \n            position(), $(window).on(\"resize\", function(e) {\n                offset = $(input).position(), computedStyle = (input.ownerDocument.defaultView || window).getComputedStyle(input, null), \n                position();\n            }), $(input).on(\"click\", function(e) {\n                return caret(input, findCaretPos(e.clientX)), EventHandlers.clickEvent.call(this, [ e ]);\n            }), $(input).on(\"keydown\", function(e) {\n                e.shiftKey || !1 === opts.insertMode || setTimeout(function() {\n                    renderColorMask(input);\n                }, 0);\n            });\n        }\n        function renderColorMask(input, buffer, caretPos) {\n            function handleStatic() {\n                isStatic || null !== test.fn && testPos.input !== undefined ? isStatic && null !== test.fn && testPos.input !== undefined && (isStatic = !1, \n                maskTemplate += \"</span>\") : (isStatic = !0, maskTemplate += \"<span class='im-static''>\");\n            }\n            if (colorMask !== undefined) {\n                buffer = buffer || getBuffer(), caretPos === undefined ? caretPos = caret(input) : caretPos.begin === undefined && (caretPos = {\n                    begin: caretPos,\n                    end: caretPos\n                });\n                var maskTemplate = \"\", isStatic = !1;\n                if (\"\" != buffer) {\n                    var ndxIntlzr, test, testPos, pos = 0, lvp = getLastValidPosition();\n                    do {\n                        pos === caretPos.begin && document.activeElement === input && (maskTemplate += \"<span class='im-caret' style='border-right-width: 1px;border-right-style: solid;'></span>\"), \n                        getMaskSet().validPositions[pos] ? (testPos = getMaskSet().validPositions[pos], \n                        test = testPos.match, ndxIntlzr = testPos.locator.slice(), handleStatic(), maskTemplate += testPos.input) : (testPos = getTestTemplate(pos, ndxIntlzr, pos - 1), \n                        test = testPos.match, ndxIntlzr = testPos.locator.slice(), (!1 === opts.jitMasking || pos < lvp || \"number\" == typeof opts.jitMasking && isFinite(opts.jitMasking) && opts.jitMasking > pos) && (handleStatic(), \n                        maskTemplate += getPlaceholder(pos, test))), pos++;\n                    } while ((maxLength === undefined || pos < maxLength) && (null !== test.fn || \"\" !== test.def) || lvp > pos);\n                }\n                colorMask.innerHTML = maskTemplate;\n            }\n        }\n        maskset = maskset || this.maskset, opts = opts || this.opts;\n        var undoValue, $el, maxLength, colorMask, valueBuffer, el = this.el, isRTL = this.isRTL, skipKeyPressEvent = !1, skipInputEvent = !1, ignorable = !1, mouseEnter = !1, EventRuler = {\n            on: function(input, eventName, eventHandler) {\n                var ev = function(e) {\n                    if (this.inputmask === undefined && \"FORM\" !== this.nodeName) {\n                        var imOpts = $.data(this, \"_inputmask_opts\");\n                        imOpts ? new Inputmask(imOpts).mask(this) : EventRuler.off(this);\n                    } else {\n                        if (\"setvalue\" === e.type || \"FORM\" === this.nodeName || !(this.disabled || this.readOnly && !(\"keydown\" === e.type && e.ctrlKey && 67 === e.keyCode || !1 === opts.tabThrough && e.keyCode === Inputmask.keyCode.TAB))) {\n                            switch (e.type) {\n                              case \"input\":\n                                if (!0 === skipInputEvent) return skipInputEvent = !1, e.preventDefault();\n                                break;\n\n                              case \"keydown\":\n                                skipKeyPressEvent = !1, skipInputEvent = !1;\n                                break;\n\n                              case \"keypress\":\n                                if (!0 === skipKeyPressEvent) return e.preventDefault();\n                                skipKeyPressEvent = !0;\n                                break;\n\n                              case \"click\":\n                                if (iemobile || iphone) {\n                                    var that = this, args = arguments;\n                                    return setTimeout(function() {\n                                        eventHandler.apply(that, args);\n                                    }, 0), !1;\n                                }\n                            }\n                            var returnVal = eventHandler.apply(this, arguments);\n                            return !1 === returnVal && (e.preventDefault(), e.stopPropagation()), returnVal;\n                        }\n                        e.preventDefault();\n                    }\n                };\n                input.inputmask.events[eventName] = input.inputmask.events[eventName] || [], input.inputmask.events[eventName].push(ev), \n                -1 !== $.inArray(eventName, [ \"submit\", \"reset\" ]) ? null != input.form && $(input.form).on(eventName, ev) : $(input).on(eventName, ev);\n            },\n            off: function(input, event) {\n                if (input.inputmask && input.inputmask.events) {\n                    var events;\n                    event ? (events = [], events[event] = input.inputmask.events[event]) : events = input.inputmask.events, \n                    $.each(events, function(eventName, evArr) {\n                        for (;evArr.length > 0; ) {\n                            var ev = evArr.pop();\n                            -1 !== $.inArray(eventName, [ \"submit\", \"reset\" ]) ? null != input.form && $(input.form).off(eventName, ev) : $(input).off(eventName, ev);\n                        }\n                        delete input.inputmask.events[eventName];\n                    });\n                }\n            }\n        }, EventHandlers = {\n            keydownEvent: function(e) {\n                var input = this, $input = $(input), k = e.keyCode, pos = caret(input);\n                if (k === Inputmask.keyCode.BACKSPACE || k === Inputmask.keyCode.DELETE || iphone && k === Inputmask.keyCode.BACKSPACE_SAFARI || e.ctrlKey && k === Inputmask.keyCode.X && !function(eventName) {\n                    var el = document.createElement(\"input\"), evName = \"on\" + eventName, isSupported = evName in el;\n                    return isSupported || (el.setAttribute(evName, \"return;\"), isSupported = \"function\" == typeof el[evName]), \n                    el = null, isSupported;\n                }(\"cut\")) e.preventDefault(), handleRemove(input, k, pos), writeBuffer(input, getBuffer(!0), getMaskSet().p, e, input.inputmask._valueGet() !== getBuffer().join(\"\")), \n                input.inputmask._valueGet() === getBufferTemplate().join(\"\") ? $input.trigger(\"cleared\") : !0 === isComplete(getBuffer()) && $input.trigger(\"complete\"); else if (k === Inputmask.keyCode.END || k === Inputmask.keyCode.PAGE_DOWN) {\n                    e.preventDefault();\n                    var caretPos = seekNext(getLastValidPosition());\n                    opts.insertMode || caretPos !== getMaskSet().maskLength || e.shiftKey || caretPos--, \n                    caret(input, e.shiftKey ? pos.begin : caretPos, caretPos, !0);\n                } else k === Inputmask.keyCode.HOME && !e.shiftKey || k === Inputmask.keyCode.PAGE_UP ? (e.preventDefault(), \n                caret(input, 0, e.shiftKey ? pos.begin : 0, !0)) : (opts.undoOnEscape && k === Inputmask.keyCode.ESCAPE || 90 === k && e.ctrlKey) && !0 !== e.altKey ? (checkVal(input, !0, !1, undoValue.split(\"\")), \n                $input.trigger(\"click\")) : k !== Inputmask.keyCode.INSERT || e.shiftKey || e.ctrlKey ? !0 === opts.tabThrough && k === Inputmask.keyCode.TAB ? (!0 === e.shiftKey ? (null === getTest(pos.begin).match.fn && (pos.begin = seekNext(pos.begin)), \n                pos.end = seekPrevious(pos.begin, !0), pos.begin = seekPrevious(pos.end, !0)) : (pos.begin = seekNext(pos.begin, !0), \n                pos.end = seekNext(pos.begin, !0), pos.end < getMaskSet().maskLength && pos.end--), \n                pos.begin < getMaskSet().maskLength && (e.preventDefault(), caret(input, pos.begin, pos.end))) : e.shiftKey || !1 === opts.insertMode && (k === Inputmask.keyCode.RIGHT ? setTimeout(function() {\n                    var caretPos = caret(input);\n                    caret(input, caretPos.begin);\n                }, 0) : k === Inputmask.keyCode.LEFT && setTimeout(function() {\n                    var caretPos = caret(input);\n                    caret(input, isRTL ? caretPos.begin + 1 : caretPos.begin - 1);\n                }, 0)) : (opts.insertMode = !opts.insertMode, caret(input, opts.insertMode || pos.begin !== getMaskSet().maskLength ? pos.begin : pos.begin - 1));\n                opts.onKeyDown.call(this, e, getBuffer(), caret(input).begin, opts), ignorable = -1 !== $.inArray(k, opts.ignorables);\n            },\n            keypressEvent: function(e, checkval, writeOut, strict, ndx) {\n                var input = this, $input = $(input), k = e.which || e.charCode || e.keyCode;\n                if (!(!0 === checkval || e.ctrlKey && e.altKey) && (e.ctrlKey || e.metaKey || ignorable)) return k === Inputmask.keyCode.ENTER && undoValue !== getBuffer().join(\"\") && (undoValue = getBuffer().join(\"\"), \n                setTimeout(function() {\n                    $input.trigger(\"change\");\n                }, 0)), !0;\n                if (k) {\n                    46 === k && !1 === e.shiftKey && \"\" !== opts.radixPoint && (k = opts.radixPoint.charCodeAt(0));\n                    var forwardPosition, pos = checkval ? {\n                        begin: ndx,\n                        end: ndx\n                    } : caret(input), c = String.fromCharCode(k);\n                    getMaskSet().writeOutBuffer = !0;\n                    var valResult = isValid(pos, c, strict);\n                    if (!1 !== valResult && (resetMaskSet(!0), forwardPosition = valResult.caret !== undefined ? valResult.caret : checkval ? valResult.pos + 1 : seekNext(valResult.pos), \n                    getMaskSet().p = forwardPosition), !1 !== writeOut && (setTimeout(function() {\n                        opts.onKeyValidation.call(input, k, valResult, opts);\n                    }, 0), getMaskSet().writeOutBuffer && !1 !== valResult)) {\n                        var buffer = getBuffer();\n                        writeBuffer(input, buffer, opts.numericInput && valResult.caret === undefined ? seekPrevious(forwardPosition) : forwardPosition, e, !0 !== checkval), \n                        !0 !== checkval && setTimeout(function() {\n                            !0 === isComplete(buffer) && $input.trigger(\"complete\");\n                        }, 0);\n                    }\n                    if (e.preventDefault(), checkval) return !1 !== valResult && (valResult.forwardPosition = forwardPosition), \n                    valResult;\n                }\n            },\n            pasteEvent: function(e) {\n                var tempValue, input = this, ev = e.originalEvent || e, $input = $(input), inputValue = input.inputmask._valueGet(!0), caretPos = caret(input);\n                isRTL && (tempValue = caretPos.end, caretPos.end = caretPos.begin, caretPos.begin = tempValue);\n                var valueBeforeCaret = inputValue.substr(0, caretPos.begin), valueAfterCaret = inputValue.substr(caretPos.end, inputValue.length);\n                if (valueBeforeCaret === (isRTL ? getBufferTemplate().reverse() : getBufferTemplate()).slice(0, caretPos.begin).join(\"\") && (valueBeforeCaret = \"\"), \n                valueAfterCaret === (isRTL ? getBufferTemplate().reverse() : getBufferTemplate()).slice(caretPos.end).join(\"\") && (valueAfterCaret = \"\"), \n                isRTL && (tempValue = valueBeforeCaret, valueBeforeCaret = valueAfterCaret, valueAfterCaret = tempValue), \n                window.clipboardData && window.clipboardData.getData) inputValue = valueBeforeCaret + window.clipboardData.getData(\"Text\") + valueAfterCaret; else {\n                    if (!ev.clipboardData || !ev.clipboardData.getData) return !0;\n                    inputValue = valueBeforeCaret + ev.clipboardData.getData(\"text/plain\") + valueAfterCaret;\n                }\n                var pasteValue = inputValue;\n                if ($.isFunction(opts.onBeforePaste)) {\n                    if (!1 === (pasteValue = opts.onBeforePaste(inputValue, opts))) return e.preventDefault();\n                    pasteValue || (pasteValue = inputValue);\n                }\n                return checkVal(input, !1, !1, isRTL ? pasteValue.split(\"\").reverse() : pasteValue.toString().split(\"\")), \n                writeBuffer(input, getBuffer(), seekNext(getLastValidPosition()), e, undoValue !== getBuffer().join(\"\")), \n                !0 === isComplete(getBuffer()) && $input.trigger(\"complete\"), e.preventDefault();\n            },\n            inputFallBackEvent: function(e) {\n                var input = this, inputValue = input.inputmask._valueGet();\n                if (getBuffer().join(\"\") !== inputValue) {\n                    var caretPos = caret(input);\n                    if (\".\" === inputValue.charAt(caretPos.begin - 1) && \"\" !== opts.radixPoint && (inputValue = inputValue.split(\"\"), \n                    inputValue[caretPos.begin - 1] = opts.radixPoint.charAt(0), inputValue = inputValue.join(\"\")), \n                    inputValue.charAt(caretPos.begin - 1) === opts.radixPoint && inputValue.length > getBuffer().length) {\n                        var keypress = new $.Event(\"keypress\");\n                        return keypress.which = opts.radixPoint.charCodeAt(0), EventHandlers.keypressEvent.call(input, keypress, !0, !0, !1, caretPos.begin), \n                        !1;\n                    }\n                    if (inputValue = inputValue.replace(new RegExp(\"(\" + Inputmask.escapeRegex(getBufferTemplate().join(\"\")) + \")*\"), \"\"), \n                    iemobile) {\n                        var inputChar = inputValue.replace(getBuffer().join(\"\"), \"\");\n                        if (1 === inputChar.length) {\n                            var keypress = new $.Event(\"keypress\");\n                            return keypress.which = inputChar.charCodeAt(0), EventHandlers.keypressEvent.call(input, keypress, !0, !0, !1, getMaskSet().validPositions[caretPos.begin - 1] ? caretPos.begin : caretPos.begin - 1), \n                            !1;\n                        }\n                    }\n                    if (caretPos.begin > inputValue.length && (caret(input, inputValue.length), caretPos = caret(input)), \n                    getBuffer().length - inputValue.length != 1 || inputValue.charAt(caretPos.begin) === getBuffer()[caretPos.begin] || inputValue.charAt(caretPos.begin + 1) === getBuffer()[caretPos.begin] || isMask(caretPos.begin)) {\n                        var stickyParts = [], bufferTemplate = getBufferTemplate().join(\"\");\n                        for (stickyParts.push(inputValue.substr(0, caretPos.begin)), stickyParts.push(inputValue.substr(caretPos.begin)); null === inputValue.match(Inputmask.escapeRegex(bufferTemplate) + \"$\"); ) bufferTemplate = bufferTemplate.slice(1);\n                        inputValue = inputValue.replace(bufferTemplate, \"\"), $.isFunction(opts.onBeforeMask) && (inputValue = opts.onBeforeMask(inputValue, opts) || inputValue), \n                        checkVal(input, !0, !1, inputValue.split(\"\"), e), function(input, frontPart, backPart) {\n                            var targetPos = caret(input).begin, currentValue = input.inputmask._valueGet(), pos = currentValue.indexOf(frontPart), currentPos = targetPos;\n                            if (0 === pos && targetPos !== frontPart.length) targetPos = frontPart.length; else {\n                                for (;null === currentValue.match(Inputmask.escapeRegex(backPart) + \"$\"); ) backPart = backPart.substr(1);\n                                var pos2 = currentValue.indexOf(backPart);\n                                -1 !== pos2 && \"\" !== backPart && targetPos > pos2 && pos2 > pos && (targetPos = pos2);\n                            }\n                            isMask(targetPos) || (targetPos = seekNext(targetPos)), currentPos !== targetPos && (caret(input, targetPos), \n                            android && setTimeout(function() {\n                                caret(input, targetPos);\n                            }, 0));\n                        }(input, stickyParts[0], stickyParts[1]), !0 === isComplete(getBuffer()) && $(input).trigger(\"complete\");\n                    } else e.keyCode = Inputmask.keyCode.BACKSPACE, EventHandlers.keydownEvent.call(input, e);\n                    e.preventDefault();\n                }\n            },\n            setValueEvent: function(e) {\n                this.inputmask.refreshValue = !1;\n                var input = this, value = input.inputmask._valueGet(!0);\n                $.isFunction(opts.onBeforeMask) && (value = opts.onBeforeMask(value, opts) || value), \n                value = value.split(\"\"), checkVal(input, !0, !1, isRTL ? value.reverse() : value), \n                undoValue = getBuffer().join(\"\"), (opts.clearMaskOnLostFocus || opts.clearIncomplete) && input.inputmask._valueGet() === getBufferTemplate().join(\"\") && input.inputmask._valueSet(\"\");\n            },\n            focusEvent: function(e) {\n                var input = this, nptValue = input.inputmask._valueGet();\n                opts.showMaskOnFocus && (!opts.showMaskOnHover || opts.showMaskOnHover && \"\" === nptValue) && (input.inputmask._valueGet() !== getBuffer().join(\"\") ? writeBuffer(input, getBuffer(), seekNext(getLastValidPosition())) : !1 === mouseEnter && caret(input, seekNext(getLastValidPosition()))), \n                !0 === opts.positionCaretOnTab && !1 === mouseEnter && (writeBuffer(input, getBuffer(), caret(input)), \n                EventHandlers.clickEvent.apply(input, [ e, !0 ])), undoValue = getBuffer().join(\"\");\n            },\n            mouseleaveEvent: function(e) {\n                var input = this;\n                if (mouseEnter = !1, opts.clearMaskOnLostFocus && document.activeElement !== input) {\n                    var buffer = getBuffer().slice(), nptValue = input.inputmask._valueGet();\n                    nptValue !== input.getAttribute(\"placeholder\") && \"\" !== nptValue && (-1 === getLastValidPosition() && nptValue === getBufferTemplate().join(\"\") ? buffer = [] : clearOptionalTail(buffer), \n                    writeBuffer(input, buffer));\n                }\n            },\n            clickEvent: function(e, tabbed) {\n                function doRadixFocus(clickPos) {\n                    if (\"\" !== opts.radixPoint) {\n                        var vps = getMaskSet().validPositions;\n                        if (vps[clickPos] === undefined || vps[clickPos].input === getPlaceholder(clickPos)) {\n                            if (clickPos < seekNext(-1)) return !0;\n                            var radixPos = $.inArray(opts.radixPoint, getBuffer());\n                            if (-1 !== radixPos) {\n                                for (var vp in vps) if (radixPos < vp && vps[vp].input !== getPlaceholder(vp)) return !1;\n                                return !0;\n                            }\n                        }\n                    }\n                    return !1;\n                }\n                var input = this;\n                setTimeout(function() {\n                    if (document.activeElement === input) {\n                        var selectedCaret = caret(input);\n                        if (tabbed && (isRTL ? selectedCaret.end = selectedCaret.begin : selectedCaret.begin = selectedCaret.end), \n                        selectedCaret.begin === selectedCaret.end) switch (opts.positionCaretOnClick) {\n                          case \"none\":\n                            break;\n\n                          case \"radixFocus\":\n                            if (doRadixFocus(selectedCaret.begin)) {\n                                var radixPos = getBuffer().join(\"\").indexOf(opts.radixPoint);\n                                caret(input, opts.numericInput ? seekNext(radixPos) : radixPos);\n                                break;\n                            }\n\n                          default:\n                            var clickPosition = selectedCaret.begin, lvclickPosition = getLastValidPosition(clickPosition, !0), lastPosition = seekNext(lvclickPosition);\n                            if (clickPosition < lastPosition) caret(input, isMask(clickPosition) || isMask(clickPosition - 1) ? clickPosition : seekNext(clickPosition)); else {\n                                var placeholder = getPlaceholder(lastPosition), lvp = getMaskSet().validPositions[lvclickPosition], tt = getTestTemplate(lastPosition, lvp ? lvp.match.locator : undefined, lvp);\n                                if (\"\" !== placeholder && getBuffer()[lastPosition] !== placeholder && !0 !== tt.match.optionalQuantifier || !isMask(lastPosition) && tt.match.def === placeholder) {\n                                    var newPos = seekNext(lastPosition);\n                                    clickPosition >= newPos && (lastPosition = newPos);\n                                }\n                                caret(input, lastPosition);\n                            }\n                        }\n                    }\n                }, 0);\n            },\n            dblclickEvent: function(e) {\n                var input = this;\n                setTimeout(function() {\n                    caret(input, 0, seekNext(getLastValidPosition()));\n                }, 0);\n            },\n            cutEvent: function(e) {\n                var input = this, $input = $(input), pos = caret(input), ev = e.originalEvent || e, clipboardData = window.clipboardData || ev.clipboardData, clipData = isRTL ? getBuffer().slice(pos.end, pos.begin) : getBuffer().slice(pos.begin, pos.end);\n                clipboardData.setData(\"text\", isRTL ? clipData.reverse().join(\"\") : clipData.join(\"\")), \n                document.execCommand && document.execCommand(\"copy\"), handleRemove(input, Inputmask.keyCode.DELETE, pos), \n                writeBuffer(input, getBuffer(), getMaskSet().p, e, undoValue !== getBuffer().join(\"\")), \n                input.inputmask._valueGet() === getBufferTemplate().join(\"\") && $input.trigger(\"cleared\");\n            },\n            blurEvent: function(e) {\n                var $input = $(this), input = this;\n                if (input.inputmask) {\n                    var nptValue = input.inputmask._valueGet(), buffer = getBuffer().slice();\n                    \"\" !== nptValue && (opts.clearMaskOnLostFocus && (-1 === getLastValidPosition() && nptValue === getBufferTemplate().join(\"\") ? buffer = [] : clearOptionalTail(buffer)), \n                    !1 === isComplete(buffer) && (setTimeout(function() {\n                        $input.trigger(\"incomplete\");\n                    }, 0), opts.clearIncomplete && (resetMaskSet(), buffer = opts.clearMaskOnLostFocus ? [] : getBufferTemplate().slice())), \n                    writeBuffer(input, buffer, undefined, e)), undoValue !== getBuffer().join(\"\") && (undoValue = buffer.join(\"\"), \n                    $input.trigger(\"change\"));\n                }\n            },\n            mouseenterEvent: function(e) {\n                var input = this;\n                mouseEnter = !0, document.activeElement !== input && opts.showMaskOnHover && input.inputmask._valueGet() !== getBuffer().join(\"\") && writeBuffer(input, getBuffer());\n            },\n            submitEvent: function(e) {\n                undoValue !== getBuffer().join(\"\") && $el.trigger(\"change\"), opts.clearMaskOnLostFocus && -1 === getLastValidPosition() && el.inputmask._valueGet && el.inputmask._valueGet() === getBufferTemplate().join(\"\") && el.inputmask._valueSet(\"\"), \n                opts.removeMaskOnSubmit && (el.inputmask._valueSet(el.inputmask.unmaskedvalue(), !0), \n                setTimeout(function() {\n                    writeBuffer(el, getBuffer());\n                }, 0));\n            },\n            resetEvent: function(e) {\n                el.inputmask.refreshValue = !0, setTimeout(function() {\n                    $el.trigger(\"setvalue\");\n                }, 0);\n            }\n        };\n        if (actionObj !== undefined) switch (actionObj.action) {\n          case \"isComplete\":\n            return el = actionObj.el, isComplete(getBuffer());\n\n          case \"unmaskedvalue\":\n            return el !== undefined && actionObj.value === undefined || (valueBuffer = actionObj.value, \n            valueBuffer = ($.isFunction(opts.onBeforeMask) ? opts.onBeforeMask(valueBuffer, opts) || valueBuffer : valueBuffer).split(\"\"), \n            checkVal(undefined, !1, !1, isRTL ? valueBuffer.reverse() : valueBuffer), $.isFunction(opts.onBeforeWrite) && opts.onBeforeWrite(undefined, getBuffer(), 0, opts)), \n            unmaskedvalue(el);\n\n          case \"mask\":\n            !function(elem) {\n                EventRuler.off(elem);\n                var isSupported = function(input, opts) {\n                    var elementType = input.getAttribute(\"type\"), isSupported = \"INPUT\" === input.tagName && -1 !== $.inArray(elementType, opts.supportsInputType) || input.isContentEditable || \"TEXTAREA\" === input.tagName;\n                    if (!isSupported) if (\"INPUT\" === input.tagName) {\n                        var el = document.createElement(\"input\");\n                        el.setAttribute(\"type\", elementType), isSupported = \"text\" === el.type, el = null;\n                    } else isSupported = \"partial\";\n                    return !1 !== isSupported && function(npt) {\n                        function getter() {\n                            return this.inputmask ? this.inputmask.opts.autoUnmask ? this.inputmask.unmaskedvalue() : -1 !== getLastValidPosition() || !0 !== opts.nullable ? document.activeElement === this && opts.clearMaskOnLostFocus ? (isRTL ? clearOptionalTail(getBuffer().slice()).reverse() : clearOptionalTail(getBuffer().slice())).join(\"\") : valueGet.call(this) : \"\" : valueGet.call(this);\n                        }\n                        function setter(value) {\n                            valueSet.call(this, value), this.inputmask && $(this).trigger(\"setvalue\");\n                        }\n                        var valueGet, valueSet;\n                        if (!npt.inputmask.__valueGet) {\n                            if (!0 !== opts.noValuePatching) {\n                                if (Object.getOwnPropertyDescriptor) {\n                                    \"function\" != typeof Object.getPrototypeOf && (Object.getPrototypeOf = \"object\" == typeof \"test\".__proto__ ? function(object) {\n                                        return object.__proto__;\n                                    } : function(object) {\n                                        return object.constructor.prototype;\n                                    });\n                                    var valueProperty = Object.getPrototypeOf ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(npt), \"value\") : undefined;\n                                    valueProperty && valueProperty.get && valueProperty.set ? (valueGet = valueProperty.get, \n                                    valueSet = valueProperty.set, Object.defineProperty(npt, \"value\", {\n                                        get: getter,\n                                        set: setter,\n                                        configurable: !0\n                                    })) : \"INPUT\" !== npt.tagName && (valueGet = function() {\n                                        return this.textContent;\n                                    }, valueSet = function(value) {\n                                        this.textContent = value;\n                                    }, Object.defineProperty(npt, \"value\", {\n                                        get: getter,\n                                        set: setter,\n                                        configurable: !0\n                                    }));\n                                } else document.__lookupGetter__ && npt.__lookupGetter__(\"value\") && (valueGet = npt.__lookupGetter__(\"value\"), \n                                valueSet = npt.__lookupSetter__(\"value\"), npt.__defineGetter__(\"value\", getter), \n                                npt.__defineSetter__(\"value\", setter));\n                                npt.inputmask.__valueGet = valueGet, npt.inputmask.__valueSet = valueSet;\n                            }\n                            npt.inputmask._valueGet = function(overruleRTL) {\n                                return isRTL && !0 !== overruleRTL ? valueGet.call(this.el).split(\"\").reverse().join(\"\") : valueGet.call(this.el);\n                            }, npt.inputmask._valueSet = function(value, overruleRTL) {\n                                valueSet.call(this.el, null === value || value === undefined ? \"\" : !0 !== overruleRTL && isRTL ? value.split(\"\").reverse().join(\"\") : value);\n                            }, valueGet === undefined && (valueGet = function() {\n                                return this.value;\n                            }, valueSet = function(value) {\n                                this.value = value;\n                            }, function(type) {\n                                if ($.valHooks && ($.valHooks[type] === undefined || !0 !== $.valHooks[type].inputmaskpatch)) {\n                                    var valhookGet = $.valHooks[type] && $.valHooks[type].get ? $.valHooks[type].get : function(elem) {\n                                        return elem.value;\n                                    }, valhookSet = $.valHooks[type] && $.valHooks[type].set ? $.valHooks[type].set : function(elem, value) {\n                                        return elem.value = value, elem;\n                                    };\n                                    $.valHooks[type] = {\n                                        get: function(elem) {\n                                            if (elem.inputmask) {\n                                                if (elem.inputmask.opts.autoUnmask) return elem.inputmask.unmaskedvalue();\n                                                var result = valhookGet(elem);\n                                                return -1 !== getLastValidPosition(undefined, undefined, elem.inputmask.maskset.validPositions) || !0 !== opts.nullable ? result : \"\";\n                                            }\n                                            return valhookGet(elem);\n                                        },\n                                        set: function(elem, value) {\n                                            var result, $elem = $(elem);\n                                            return result = valhookSet(elem, value), elem.inputmask && $elem.trigger(\"setvalue\"), \n                                            result;\n                                        },\n                                        inputmaskpatch: !0\n                                    };\n                                }\n                            }(npt.type), function(npt) {\n                                EventRuler.on(npt, \"mouseenter\", function(event) {\n                                    var $input = $(this);\n                                    this.inputmask._valueGet() !== getBuffer().join(\"\") && $input.trigger(\"setvalue\");\n                                });\n                            }(npt));\n                        }\n                    }(input), isSupported;\n                }(elem, opts);\n                if (!1 !== isSupported && (el = elem, $el = $(el), !0 === opts.colorMask && initializeColorMask(el), \n                android && (el.hasOwnProperty(\"inputmode\") && (el.inputmode = opts.inputmode, el.setAttribute(\"inputmode\", opts.inputmode)), \n                \"rtfm\" === opts.androidHack && (!0 !== opts.colorMask && initializeColorMask(el), \n                el.type = \"password\")), !0 === isSupported && (EventRuler.on(el, \"submit\", EventHandlers.submitEvent), \n                EventRuler.on(el, \"reset\", EventHandlers.resetEvent), EventRuler.on(el, \"mouseenter\", EventHandlers.mouseenterEvent), \n                EventRuler.on(el, \"blur\", EventHandlers.blurEvent), EventRuler.on(el, \"focus\", EventHandlers.focusEvent), \n                EventRuler.on(el, \"mouseleave\", EventHandlers.mouseleaveEvent), !0 !== opts.colorMask && EventRuler.on(el, \"click\", EventHandlers.clickEvent), \n                EventRuler.on(el, \"dblclick\", EventHandlers.dblclickEvent), EventRuler.on(el, \"paste\", EventHandlers.pasteEvent), \n                EventRuler.on(el, \"dragdrop\", EventHandlers.pasteEvent), EventRuler.on(el, \"drop\", EventHandlers.pasteEvent), \n                EventRuler.on(el, \"cut\", EventHandlers.cutEvent), EventRuler.on(el, \"complete\", opts.oncomplete), \n                EventRuler.on(el, \"incomplete\", opts.onincomplete), EventRuler.on(el, \"cleared\", opts.oncleared), \n                android || !0 === opts.inputEventOnly || (EventRuler.on(el, \"keydown\", EventHandlers.keydownEvent), \n                EventRuler.on(el, \"keypress\", EventHandlers.keypressEvent)), EventRuler.on(el, \"compositionstart\", $.noop), \n                EventRuler.on(el, \"compositionupdate\", $.noop), EventRuler.on(el, \"compositionend\", $.noop), \n                EventRuler.on(el, \"keyup\", $.noop), EventRuler.on(el, \"input\", EventHandlers.inputFallBackEvent), \n                EventRuler.on(el, \"beforeinput\", $.noop)), EventRuler.on(el, \"setvalue\", EventHandlers.setValueEvent), \n                undoValue = getBufferTemplate().join(\"\"), \"\" !== el.inputmask._valueGet(!0) || !1 === opts.clearMaskOnLostFocus || document.activeElement === el)) {\n                    var initialValue = $.isFunction(opts.onBeforeMask) ? opts.onBeforeMask(el.inputmask._valueGet(!0), opts) || el.inputmask._valueGet(!0) : el.inputmask._valueGet(!0);\n                    \"\" !== initialValue && checkVal(el, !0, !1, isRTL ? initialValue.split(\"\").reverse() : initialValue.split(\"\"));\n                    var buffer = getBuffer().slice();\n                    undoValue = buffer.join(\"\"), !1 === isComplete(buffer) && opts.clearIncomplete && resetMaskSet(), \n                    opts.clearMaskOnLostFocus && document.activeElement !== el && (-1 === getLastValidPosition() ? buffer = [] : clearOptionalTail(buffer)), \n                    writeBuffer(el, buffer), document.activeElement === el && caret(el, seekNext(getLastValidPosition()));\n                }\n            }(el);\n            break;\n\n          case \"format\":\n            return valueBuffer = ($.isFunction(opts.onBeforeMask) ? opts.onBeforeMask(actionObj.value, opts) || actionObj.value : actionObj.value).split(\"\"), \n            checkVal(undefined, !0, !1, isRTL ? valueBuffer.reverse() : valueBuffer), actionObj.metadata ? {\n                value: isRTL ? getBuffer().slice().reverse().join(\"\") : getBuffer().join(\"\"),\n                metadata: maskScope.call(this, {\n                    action: \"getmetadata\"\n                }, maskset, opts)\n            } : isRTL ? getBuffer().slice().reverse().join(\"\") : getBuffer().join(\"\");\n\n          case \"isValid\":\n            actionObj.value ? (valueBuffer = actionObj.value.split(\"\"), checkVal(undefined, !0, !0, isRTL ? valueBuffer.reverse() : valueBuffer)) : actionObj.value = getBuffer().join(\"\");\n            for (var buffer = getBuffer(), rl = determineLastRequiredPosition(), lmib = buffer.length - 1; lmib > rl && !isMask(lmib); lmib--) ;\n            return buffer.splice(rl, lmib + 1 - rl), isComplete(buffer) && actionObj.value === getBuffer().join(\"\");\n\n          case \"getemptymask\":\n            return getBufferTemplate().join(\"\");\n\n          case \"remove\":\n            if (el && el.inputmask) {\n                $el = $(el), el.inputmask._valueSet(opts.autoUnmask ? unmaskedvalue(el) : el.inputmask._valueGet(!0)), \n                EventRuler.off(el);\n                Object.getOwnPropertyDescriptor && Object.getPrototypeOf ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(el), \"value\") && el.inputmask.__valueGet && Object.defineProperty(el, \"value\", {\n                    get: el.inputmask.__valueGet,\n                    set: el.inputmask.__valueSet,\n                    configurable: !0\n                }) : document.__lookupGetter__ && el.__lookupGetter__(\"value\") && el.inputmask.__valueGet && (el.__defineGetter__(\"value\", el.inputmask.__valueGet), \n                el.__defineSetter__(\"value\", el.inputmask.__valueSet)), el.inputmask = undefined;\n            }\n            return el;\n\n          case \"getmetadata\":\n            if ($.isArray(maskset.metadata)) {\n                var maskTarget = getMaskTemplate(!0, 0, !1).join(\"\");\n                return $.each(maskset.metadata, function(ndx, mtdt) {\n                    if (mtdt.mask === maskTarget) return maskTarget = mtdt, !1;\n                }), maskTarget;\n            }\n            return maskset.metadata;\n        }\n    }\n    var ua = navigator.userAgent, mobile = /mobile/i.test(ua), iemobile = /iemobile/i.test(ua), iphone = /iphone/i.test(ua) && !iemobile, android = /android/i.test(ua) && !iemobile;\n    return Inputmask.prototype = {\n        dataAttribute: \"data-inputmask\",\n        defaults: {\n            placeholder: \"_\",\n            optionalmarker: {\n                start: \"[\",\n                end: \"]\"\n            },\n            quantifiermarker: {\n                start: \"{\",\n                end: \"}\"\n            },\n            groupmarker: {\n                start: \"(\",\n                end: \")\"\n            },\n            alternatormarker: \"|\",\n            escapeChar: \"\\\\\",\n            mask: null,\n            regex: null,\n            oncomplete: $.noop,\n            onincomplete: $.noop,\n            oncleared: $.noop,\n            repeat: 0,\n            greedy: !0,\n            autoUnmask: !1,\n            removeMaskOnSubmit: !1,\n            clearMaskOnLostFocus: !0,\n            insertMode: !0,\n            clearIncomplete: !1,\n            alias: null,\n            onKeyDown: $.noop,\n            onBeforeMask: null,\n            onBeforePaste: function(pastedValue, opts) {\n                return $.isFunction(opts.onBeforeMask) ? opts.onBeforeMask(pastedValue, opts) : pastedValue;\n            },\n            onBeforeWrite: null,\n            onUnMask: null,\n            showMaskOnFocus: !0,\n            showMaskOnHover: !0,\n            onKeyValidation: $.noop,\n            skipOptionalPartCharacter: \" \",\n            numericInput: !1,\n            rightAlign: !1,\n            undoOnEscape: !0,\n            radixPoint: \"\",\n            radixPointDefinitionSymbol: undefined,\n            groupSeparator: \"\",\n            keepStatic: null,\n            positionCaretOnTab: !0,\n            tabThrough: !1,\n            supportsInputType: [ \"text\", \"tel\", \"password\" ],\n            ignorables: [ 8, 9, 13, 19, 27, 33, 34, 35, 36, 37, 38, 39, 40, 45, 46, 93, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 0, 229 ],\n            isComplete: null,\n            canClearPosition: $.noop,\n            preValidation: null,\n            postValidation: null,\n            staticDefinitionSymbol: undefined,\n            jitMasking: !1,\n            nullable: !0,\n            inputEventOnly: !1,\n            noValuePatching: !1,\n            positionCaretOnClick: \"lvp\",\n            casing: null,\n            inputmode: \"verbatim\",\n            colorMask: !1,\n            androidHack: !1\n        },\n        definitions: {\n            \"9\": {\n                validator: \"[0-9]\",\n                cardinality: 1,\n                definitionSymbol: \"*\"\n            },\n            a: {\n                validator: \"[A-Za-z\\u0410-\\u044f\\u0401\\u0451\\xc0-\\xff\\xb5]\",\n                cardinality: 1,\n                definitionSymbol: \"*\"\n            },\n            \"*\": {\n                validator: \"[0-9A-Za-z\\u0410-\\u044f\\u0401\\u0451\\xc0-\\xff\\xb5]\",\n                cardinality: 1\n            }\n        },\n        aliases: {},\n        masksCache: {},\n        mask: function(elems) {\n            function importAttributeOptions(npt, opts, userOptions, dataAttribute) {\n                function importOption(option, optionData) {\n                    null !== (optionData = optionData !== undefined ? optionData : npt.getAttribute(dataAttribute + \"-\" + option)) && (\"string\" == typeof optionData && (0 === option.indexOf(\"on\") ? optionData = window[optionData] : \"false\" === optionData ? optionData = !1 : \"true\" === optionData && (optionData = !0)), \n                    userOptions[option] = optionData);\n                }\n                (\"rtl\" === npt.dir || opts.rightAlign) && (npt.style.textAlign = \"right\"), (\"rtl\" === npt.dir || opts.numericInput) && (npt.dir = \"ltr\", \n                npt.removeAttribute(\"dir\"), opts.isRTL = !0);\n                var option, dataoptions, optionData, p, attrOptions = npt.getAttribute(dataAttribute);\n                if (attrOptions && \"\" !== attrOptions && (attrOptions = attrOptions.replace(new RegExp(\"'\", \"g\"), '\"'), \n                dataoptions = JSON.parse(\"{\" + attrOptions + \"}\")), dataoptions) {\n                    optionData = undefined;\n                    for (p in dataoptions) if (\"alias\" === p.toLowerCase()) {\n                        optionData = dataoptions[p];\n                        break;\n                    }\n                }\n                importOption(\"alias\", optionData), userOptions.alias && resolveAlias(userOptions.alias, userOptions, opts);\n                for (option in opts) {\n                    if (dataoptions) {\n                        optionData = undefined;\n                        for (p in dataoptions) if (p.toLowerCase() === option.toLowerCase()) {\n                            optionData = dataoptions[p];\n                            break;\n                        }\n                    }\n                    importOption(option, optionData);\n                }\n                return $.extend(!0, opts, userOptions), opts;\n            }\n            var that = this;\n            return \"string\" == typeof elems && (elems = document.getElementById(elems) || document.querySelectorAll(elems)), \n            elems = elems.nodeName ? [ elems ] : elems, $.each(elems, function(ndx, el) {\n                var scopedOpts = $.extend(!0, {}, that.opts);\n                importAttributeOptions(el, scopedOpts, $.extend(!0, {}, that.userOptions), that.dataAttribute);\n                var maskset = generateMaskSet(scopedOpts, that.noMasksCache);\n                maskset !== undefined && (el.inputmask !== undefined && el.inputmask.remove(), el.inputmask = new Inputmask(undefined, undefined, !0), \n                el.inputmask.opts = scopedOpts, el.inputmask.noMasksCache = that.noMasksCache, el.inputmask.userOptions = $.extend(!0, {}, that.userOptions), \n                el.inputmask.isRTL = scopedOpts.isRTL, el.inputmask.el = el, el.inputmask.maskset = maskset, \n                $.data(el, \"_inputmask_opts\", scopedOpts), maskScope.call(el.inputmask, {\n                    action: \"mask\"\n                }));\n            }), elems && elems[0] ? elems[0].inputmask || this : this;\n        },\n        option: function(options, noremask) {\n            return \"string\" == typeof options ? this.opts[options] : \"object\" == typeof options ? ($.extend(this.userOptions, options), \n            this.el && !0 !== noremask && this.mask(this.el), this) : void 0;\n        },\n        unmaskedvalue: function(value) {\n            return this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache), \n            maskScope.call(this, {\n                action: \"unmaskedvalue\",\n                value: value\n            });\n        },\n        remove: function() {\n            return maskScope.call(this, {\n                action: \"remove\"\n            });\n        },\n        getemptymask: function() {\n            return this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache), \n            maskScope.call(this, {\n                action: \"getemptymask\"\n            });\n        },\n        hasMaskedValue: function() {\n            return !this.opts.autoUnmask;\n        },\n        isComplete: function() {\n            return this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache), \n            maskScope.call(this, {\n                action: \"isComplete\"\n            });\n        },\n        getmetadata: function() {\n            return this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache), \n            maskScope.call(this, {\n                action: \"getmetadata\"\n            });\n        },\n        isValid: function(value) {\n            return this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache), \n            maskScope.call(this, {\n                action: \"isValid\",\n                value: value\n            });\n        },\n        format: function(value, metadata) {\n            return this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache), \n            maskScope.call(this, {\n                action: \"format\",\n                value: value,\n                metadata: metadata\n            });\n        },\n        analyseMask: function(mask, regexMask, opts) {\n            function MaskToken(isGroup, isOptional, isQuantifier, isAlternator) {\n                this.matches = [], this.openGroup = isGroup || !1, this.alternatorGroup = !1, this.isGroup = isGroup || !1, \n                this.isOptional = isOptional || !1, this.isQuantifier = isQuantifier || !1, this.isAlternator = isAlternator || !1, \n                this.quantifier = {\n                    min: 1,\n                    max: 1\n                };\n            }\n            function insertTestDefinition(mtoken, element, position) {\n                position = position !== undefined ? position : mtoken.matches.length;\n                var prevMatch = mtoken.matches[position - 1];\n                if (regexMask) 0 === element.indexOf(\"[\") || escaped ? mtoken.matches.splice(position++, 0, {\n                    fn: new RegExp(element, opts.casing ? \"i\" : \"\"),\n                    cardinality: 1,\n                    optionality: mtoken.isOptional,\n                    newBlockMarker: prevMatch === undefined || prevMatch.def !== element,\n                    casing: null,\n                    def: element,\n                    placeholder: undefined,\n                    nativeDef: element\n                }) : $.each(element.split(\"\"), function(ndx, lmnt) {\n                    prevMatch = mtoken.matches[position - 1], mtoken.matches.splice(position++, 0, {\n                        fn: null,\n                        cardinality: 0,\n                        optionality: mtoken.isOptional,\n                        newBlockMarker: prevMatch === undefined || prevMatch.def !== lmnt && null !== prevMatch.fn,\n                        casing: null,\n                        def: opts.staticDefinitionSymbol || lmnt,\n                        placeholder: opts.staticDefinitionSymbol !== undefined ? lmnt : undefined,\n                        nativeDef: lmnt\n                    });\n                }), escaped = !1; else {\n                    var maskdef = (opts.definitions ? opts.definitions[element] : undefined) || Inputmask.prototype.definitions[element];\n                    if (maskdef && !escaped) {\n                        for (var prevalidators = maskdef.prevalidator, prevalidatorsL = prevalidators ? prevalidators.length : 0, i = 1; i < maskdef.cardinality; i++) {\n                            var prevalidator = prevalidatorsL >= i ? prevalidators[i - 1] : [], validator = prevalidator.validator, cardinality = prevalidator.cardinality;\n                            mtoken.matches.splice(position++, 0, {\n                                fn: validator ? \"string\" == typeof validator ? new RegExp(validator, opts.casing ? \"i\" : \"\") : new function() {\n                                    this.test = validator;\n                                }() : new RegExp(\".\"),\n                                cardinality: cardinality || 1,\n                                optionality: mtoken.isOptional,\n                                newBlockMarker: prevMatch === undefined || prevMatch.def !== (maskdef.definitionSymbol || element),\n                                casing: maskdef.casing,\n                                def: maskdef.definitionSymbol || element,\n                                placeholder: maskdef.placeholder,\n                                nativeDef: element\n                            }), prevMatch = mtoken.matches[position - 1];\n                        }\n                        mtoken.matches.splice(position++, 0, {\n                            fn: maskdef.validator ? \"string\" == typeof maskdef.validator ? new RegExp(maskdef.validator, opts.casing ? \"i\" : \"\") : new function() {\n                                this.test = maskdef.validator;\n                            }() : new RegExp(\".\"),\n                            cardinality: maskdef.cardinality,\n                            optionality: mtoken.isOptional,\n                            newBlockMarker: prevMatch === undefined || prevMatch.def !== (maskdef.definitionSymbol || element),\n                            casing: maskdef.casing,\n                            def: maskdef.definitionSymbol || element,\n                            placeholder: maskdef.placeholder,\n                            nativeDef: element\n                        });\n                    } else mtoken.matches.splice(position++, 0, {\n                        fn: null,\n                        cardinality: 0,\n                        optionality: mtoken.isOptional,\n                        newBlockMarker: prevMatch === undefined || prevMatch.def !== element && null !== prevMatch.fn,\n                        casing: null,\n                        def: opts.staticDefinitionSymbol || element,\n                        placeholder: opts.staticDefinitionSymbol !== undefined ? element : undefined,\n                        nativeDef: element\n                    }), escaped = !1;\n                }\n            }\n            function verifyGroupMarker(maskToken) {\n                maskToken && maskToken.matches && $.each(maskToken.matches, function(ndx, token) {\n                    var nextToken = maskToken.matches[ndx + 1];\n                    (nextToken === undefined || nextToken.matches === undefined || !1 === nextToken.isQuantifier) && token && token.isGroup && (token.isGroup = !1, \n                    regexMask || (insertTestDefinition(token, opts.groupmarker.start, 0), !0 !== token.openGroup && insertTestDefinition(token, opts.groupmarker.end))), \n                    verifyGroupMarker(token);\n                });\n            }\n            function defaultCase() {\n                if (openenings.length > 0) {\n                    if (currentOpeningToken = openenings[openenings.length - 1], insertTestDefinition(currentOpeningToken, m), \n                    currentOpeningToken.isAlternator) {\n                        alternator = openenings.pop();\n                        for (var mndx = 0; mndx < alternator.matches.length; mndx++) alternator.matches[mndx].isGroup = !1;\n                        openenings.length > 0 ? (currentOpeningToken = openenings[openenings.length - 1], \n                        currentOpeningToken.matches.push(alternator)) : currentToken.matches.push(alternator);\n                    }\n                } else insertTestDefinition(currentToken, m);\n            }\n            function reverseTokens(maskToken) {\n                maskToken.matches = maskToken.matches.reverse();\n                for (var match in maskToken.matches) if (maskToken.matches.hasOwnProperty(match)) {\n                    var intMatch = parseInt(match);\n                    if (maskToken.matches[match].isQuantifier && maskToken.matches[intMatch + 1] && maskToken.matches[intMatch + 1].isGroup) {\n                        var qt = maskToken.matches[match];\n                        maskToken.matches.splice(match, 1), maskToken.matches.splice(intMatch + 1, 0, qt);\n                    }\n                    maskToken.matches[match].matches !== undefined ? maskToken.matches[match] = reverseTokens(maskToken.matches[match]) : maskToken.matches[match] = function(st) {\n                        return st === opts.optionalmarker.start ? st = opts.optionalmarker.end : st === opts.optionalmarker.end ? st = opts.optionalmarker.start : st === opts.groupmarker.start ? st = opts.groupmarker.end : st === opts.groupmarker.end && (st = opts.groupmarker.start), \n                        st;\n                    }(maskToken.matches[match]);\n                }\n                return maskToken;\n            }\n            var match, m, openingToken, currentOpeningToken, alternator, lastMatch, groupToken, tokenizer = /(?:[?*+]|\\{[0-9\\+\\*]+(?:,[0-9\\+\\*]*)?\\})|[^.?*+^${[]()|\\\\]+|./g, regexTokenizer = /\\[\\^?]?(?:[^\\\\\\]]+|\\\\[\\S\\s]?)*]?|\\\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9][0-9]*|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|c[A-Za-z]|[\\S\\s]?)|\\((?:\\?[:=!]?)?|(?:[?*+]|\\{[0-9]+(?:,[0-9]*)?\\})\\??|[^.?*+^${[()|\\\\]+|./g, escaped = !1, currentToken = new MaskToken(), openenings = [], maskTokens = [];\n            for (regexMask && (opts.optionalmarker.start = undefined, opts.optionalmarker.end = undefined); match = regexMask ? regexTokenizer.exec(mask) : tokenizer.exec(mask); ) {\n                if (m = match[0], regexMask && !0 !== escaped) switch (m.charAt(0)) {\n                  case \"?\":\n                    m = \"{0,1}\";\n                    break;\n\n                  case \"+\":\n                  case \"*\":\n                    m = \"{\" + m + \"}\";\n                }\n                if (escaped) defaultCase(); else switch (m.charAt(0)) {\n                  case opts.escapeChar:\n                    escaped = !0, regexMask && defaultCase();\n                    break;\n\n                  case opts.optionalmarker.end:\n                  case opts.groupmarker.end:\n                    if (openingToken = openenings.pop(), openingToken.openGroup = !1, openingToken !== undefined) if (openenings.length > 0) {\n                        if (currentOpeningToken = openenings[openenings.length - 1], currentOpeningToken.matches.push(openingToken), \n                        currentOpeningToken.isAlternator) {\n                            alternator = openenings.pop();\n                            for (var mndx = 0; mndx < alternator.matches.length; mndx++) alternator.matches[mndx].isGroup = !1, \n                            alternator.matches[mndx].alternatorGroup = !1;\n                            openenings.length > 0 ? (currentOpeningToken = openenings[openenings.length - 1], \n                            currentOpeningToken.matches.push(alternator)) : currentToken.matches.push(alternator);\n                        }\n                    } else currentToken.matches.push(openingToken); else defaultCase();\n                    break;\n\n                  case opts.optionalmarker.start:\n                    openenings.push(new MaskToken(!1, !0));\n                    break;\n\n                  case opts.groupmarker.start:\n                    openenings.push(new MaskToken(!0));\n                    break;\n\n                  case opts.quantifiermarker.start:\n                    var quantifier = new MaskToken(!1, !1, !0);\n                    m = m.replace(/[{}]/g, \"\");\n                    var mq = m.split(\",\"), mq0 = isNaN(mq[0]) ? mq[0] : parseInt(mq[0]), mq1 = 1 === mq.length ? mq0 : isNaN(mq[1]) ? mq[1] : parseInt(mq[1]);\n                    if (\"*\" !== mq1 && \"+\" !== mq1 || (mq0 = \"*\" === mq1 ? 0 : 1), quantifier.quantifier = {\n                        min: mq0,\n                        max: mq1\n                    }, openenings.length > 0) {\n                        var matches = openenings[openenings.length - 1].matches;\n                        match = matches.pop(), match.isGroup || (groupToken = new MaskToken(!0), groupToken.matches.push(match), \n                        match = groupToken), matches.push(match), matches.push(quantifier);\n                    } else match = currentToken.matches.pop(), match.isGroup || (regexMask && null === match.fn && \".\" === match.def && (match.fn = new RegExp(match.def, opts.casing ? \"i\" : \"\")), \n                    groupToken = new MaskToken(!0), groupToken.matches.push(match), match = groupToken), \n                    currentToken.matches.push(match), currentToken.matches.push(quantifier);\n                    break;\n\n                  case opts.alternatormarker:\n                    if (openenings.length > 0) {\n                        currentOpeningToken = openenings[openenings.length - 1];\n                        var subToken = currentOpeningToken.matches[currentOpeningToken.matches.length - 1];\n                        lastMatch = currentOpeningToken.openGroup && (subToken.matches === undefined || !1 === subToken.isGroup && !1 === subToken.isAlternator) ? openenings.pop() : currentOpeningToken.matches.pop();\n                    } else lastMatch = currentToken.matches.pop();\n                    if (lastMatch.isAlternator) openenings.push(lastMatch); else if (lastMatch.alternatorGroup ? (alternator = openenings.pop(), \n                    lastMatch.alternatorGroup = !1) : alternator = new MaskToken(!1, !1, !1, !0), alternator.matches.push(lastMatch), \n                    openenings.push(alternator), lastMatch.openGroup) {\n                        lastMatch.openGroup = !1;\n                        var alternatorGroup = new MaskToken(!0);\n                        alternatorGroup.alternatorGroup = !0, openenings.push(alternatorGroup);\n                    }\n                    break;\n\n                  default:\n                    defaultCase();\n                }\n            }\n            for (;openenings.length > 0; ) openingToken = openenings.pop(), currentToken.matches.push(openingToken);\n            return currentToken.matches.length > 0 && (verifyGroupMarker(currentToken), maskTokens.push(currentToken)), \n            (opts.numericInput || opts.isRTL) && reverseTokens(maskTokens[0]), maskTokens;\n        }\n    }, Inputmask.extendDefaults = function(options) {\n        $.extend(!0, Inputmask.prototype.defaults, options);\n    }, Inputmask.extendDefinitions = function(definition) {\n        $.extend(!0, Inputmask.prototype.definitions, definition);\n    }, Inputmask.extendAliases = function(alias) {\n        $.extend(!0, Inputmask.prototype.aliases, alias);\n    }, Inputmask.format = function(value, options, metadata) {\n        return Inputmask(options).format(value, metadata);\n    }, Inputmask.unmask = function(value, options) {\n        return Inputmask(options).unmaskedvalue(value);\n    }, Inputmask.isValid = function(value, options) {\n        return Inputmask(options).isValid(value);\n    }, Inputmask.remove = function(elems) {\n        $.each(elems, function(ndx, el) {\n            el.inputmask && el.inputmask.remove();\n        });\n    }, Inputmask.escapeRegex = function(str) {\n        var specials = [ \"/\", \".\", \"*\", \"+\", \"?\", \"|\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\", \"\\\\\", \"$\", \"^\" ];\n        return str.replace(new RegExp(\"(\\\\\" + specials.join(\"|\\\\\") + \")\", \"gim\"), \"\\\\$1\");\n    }, Inputmask.keyCode = {\n        ALT: 18,\n        BACKSPACE: 8,\n        BACKSPACE_SAFARI: 127,\n        CAPS_LOCK: 20,\n        COMMA: 188,\n        COMMAND: 91,\n        COMMAND_LEFT: 91,\n        COMMAND_RIGHT: 93,\n        CONTROL: 17,\n        DELETE: 46,\n        DOWN: 40,\n        END: 35,\n        ENTER: 13,\n        ESCAPE: 27,\n        HOME: 36,\n        INSERT: 45,\n        LEFT: 37,\n        MENU: 93,\n        NUMPAD_ADD: 107,\n        NUMPAD_DECIMAL: 110,\n        NUMPAD_DIVIDE: 111,\n        NUMPAD_ENTER: 108,\n        NUMPAD_MULTIPLY: 106,\n        NUMPAD_SUBTRACT: 109,\n        PAGE_DOWN: 34,\n        PAGE_UP: 33,\n        PERIOD: 190,\n        RIGHT: 39,\n        SHIFT: 16,\n        SPACE: 32,\n        TAB: 9,\n        UP: 38,\n        WINDOWS: 91,\n        X: 88\n    }, Inputmask;\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/inputmask/dist/inputmask/inputmask.js\n// module id = 1\n// module chunks = 0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 2\n// module chunks = 0","/*!\n* global/document.js\n* https://github.com/RobinHerbots/Inputmask\n* Copyright (c) 2010 - 2017 Robin Herbots\n* Licensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)\n* Version: 3.3.7\n*/\n\n\"function\" == typeof define && define.amd ? define(function() {\n    return document;\n}) : \"object\" == typeof exports && (module.exports = document);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/inputmask/dist/inputmask/global/document.js\n// module id = 3\n// module chunks = 0","/*!\n* global/window.js\n* https://github.com/RobinHerbots/Inputmask\n* Copyright (c) 2010 - 2017 Robin Herbots\n* Licensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)\n* Version: 3.3.7\n*/\n\n\"function\" == typeof define && define.amd ? define(function() {\n    return window;\n}) : \"object\" == typeof exports && (module.exports = window);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/inputmask/dist/inputmask/global/window.js\n// module id = 4\n// module chunks = 0","// Generated by CoffeeScript 1.7.1\n\n/*\n Paraxify.js - v0.1\n @author Jaime Caballero\n MIT license\n */\n(function(document, window, index) {\n  \"use strict\";\n  var paraxify;\n  paraxify = function(el, options) {\n    var Paraxify, contador, i, opt, pho, posY, screenY;\n    posY = 0;\n    screenY = 0;\n    i = 0;\n    opt = {};\n    pho = [];\n    contador = 0;\n    Paraxify = function(el, options) {\n      this.options = {\n        speed: 1,\n        boost: 0\n      };\n      for (i in options) {\n        this.options[i] = options[i];\n      }\n      if (this.options.speed < 0 || this.options.speed > 1) {\n        this.options.speed = 1;\n      }\n      if (!el) {\n        el = 'paraxify';\n      }\n      if (document.getElementsByClassName(el.replace('.', ''))) {\n        this.photos = document.getElementsByClassName(el.replace('.', ''));\n      } else if (document.querySelector(el) !== false) {\n        this.photos = querySelector(el);\n      } else {\n        throw new Error(\"The elements you're trying to select don't exist.\");\n      }\n      opt = this.options;\n      pho = this.photos;\n      this._init(this);\n    };\n    Paraxify.prototype = {\n      update: function() {\n        screenY = window.innerHeight;\n        i = 0;\n        while (i < pho.length) {\n          pho[i].style.backgroundPosition = \"center center\";\n          pho[i].url = window.getComputedStyle(pho[i], false).backgroundImage.replace(/url\\((['\"])?(.*?)\\1\\)/gi, '$2').split(',')[0];\n          if (!pho[i].img) {\n            pho[i].img = new Image();\n          }\n          if (pho[i].url !== pho[i].img.src) {\n            this._check(i);\n            pho[i].img.src = pho[i].url;\n          }\n          i++;\n        }\n        this._animate();\n      },\n      _init: function() {\n        this.update();\n        window.onscroll = (function() {\n          this._animate();\n        }).bind(this);\n        window.onresize = (function() {\n          this.update();\n        }).bind(this);\n      },\n      _check: function(i) {\n        var actualHeight, main;\n        main = pho[i];\n        main.ok = true;\n        main.bgSize = window.getComputedStyle(main, false).backgroundSize;\n        actualHeight = screenY;\n        pho[i].img.onload = function() {\n          if (main.bgSize === '' || main.bgSize === 'auto') {\n            if (this.height < main.offsetHeight) {\n              main.ok = false;\n              throw new Error(\"The image \" + main.url + \" (\" + this.height + \"px) is too short for that container (\" + main.offsetHeight + \"px).\");\n            } else {\n              actualHeight = this.height;\n              if (this.height < screenY) {\n                actualHeight = actualHeight + ((screenY - main.offsetHeight) * opt.speed);\n              }\n            }\n          } else if (main.bgSize === 'cover') {\n            if (screenY < main.offsetHeight) {\n              main.ok = false;\n              throw new Error(\"The container (\" + main.offsetHeight + \"px) can't be bigger than the image (\" + screenY + \"px).\");\n            }\n          } else {\n            window.getComputedStyle(main, false).backgroundSize === 'cover';\n            this._check(i);\n          }\n          main.diff = -(actualHeight - main.offsetHeight) * opt.speed;\n          main.diff = main.diff - (main.offsetHeight * opt.boost);\n        };\n      },\n      _visible: function(i) {\n        if (((posY + screenY) > pho[i].offsetTop) && (posY < pho[i].offsetTop + pho[i].offsetHeight)) {\n          return true;\n        }\n        return false;\n      },\n      _animate: function() {\n        var per, position;\n        if (window.pageYOffset !== void 0) {\n          posY = window.pageYOffset;\n        } else {\n          posY = (document.documentElement || document.body.parentNode || document.body).scrollTop;\n        }\n        i = 0;\n        while (i < pho.length) {\n          this._check(i);\n          if (pho[i].ok && window.getComputedStyle(pho[i], false).backgroundAttachment === \"fixed\" && this._visible(i)) {\n            per = (posY - pho[i].offsetTop + screenY) / (pho[i].offsetHeight + screenY);\n            position = pho[i].diff * (per - 0.5);\n            if (pho[i].bgSize !== 'cover') {\n              position = position + ((screenY - pho[i].img.height) / 2);\n            }\n            position = Math.round(position * 100) / 100;\n          } else {\n            position = \"center\";\n          }\n          pho[i].style.backgroundPosition = \"center \" + position + \"px\";\n          i++;\n        }\n      }\n    };\n    return new Paraxify(el, options);\n  };\n  window.paraxify = paraxify;\n})(document, window, 0);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./home/static/home/js/paraxify.js\n// module id = 5\n// module chunks = 0","/*! @vimeo/player v2.0.2 | (c) 2017 Vimeo | MIT License | https://github.com/vimeo/player.js */\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.Vimeo = global.Vimeo || {}, global.Vimeo.Player = factory());\n}(this, (function () { 'use strict';\n\nvar arrayIndexOfSupport = typeof Array.prototype.indexOf !== 'undefined';\nvar postMessageSupport = typeof window.postMessage !== 'undefined';\n\nif (!arrayIndexOfSupport || !postMessageSupport) {\n    throw new Error('Sorry, the Vimeo Player API is not available in this browser.');\n}\n\nvar commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n\n\n\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nvar index = createCommonjsModule(function (module, exports) {\n(function (exports) {\n  'use strict';\n  //shared pointer\n\n  var i;\n  //shortcuts\n  var defineProperty = Object.defineProperty,\n      is = function is(a, b) {\n    return a === b || a !== a && b !== b;\n  };\n\n  //Polyfill global objects\n  if (typeof WeakMap == 'undefined') {\n    exports.WeakMap = createCollection({\n      // WeakMap#delete(key:void*):boolean\n      'delete': sharedDelete,\n      // WeakMap#clear():\n      clear: sharedClear,\n      // WeakMap#get(key:void*):void*\n      get: sharedGet,\n      // WeakMap#has(key:void*):boolean\n      has: mapHas,\n      // WeakMap#set(key:void*, value:void*):void\n      set: sharedSet\n    }, true);\n  }\n\n  if (typeof Map == 'undefined' || typeof new Map().values !== 'function' || !new Map().values().next) {\n    exports.Map = createCollection({\n      // WeakMap#delete(key:void*):boolean\n      'delete': sharedDelete,\n      //:was Map#get(key:void*[, d3fault:void*]):void*\n      // Map#has(key:void*):boolean\n      has: mapHas,\n      // Map#get(key:void*):boolean\n      get: sharedGet,\n      // Map#set(key:void*, value:void*):void\n      set: sharedSet,\n      // Map#keys(void):Iterator\n      keys: sharedKeys,\n      // Map#values(void):Iterator\n      values: sharedValues,\n      // Map#entries(void):Iterator\n      entries: mapEntries,\n      // Map#forEach(callback:Function, context:void*):void ==> callback.call(context, key, value, mapObject) === not in specs`\n      forEach: sharedForEach,\n      // Map#clear():\n      clear: sharedClear\n    });\n  }\n\n  if (typeof Set == 'undefined' || typeof new Set().values !== 'function' || !new Set().values().next) {\n    exports.Set = createCollection({\n      // Set#has(value:void*):boolean\n      has: setHas,\n      // Set#add(value:void*):boolean\n      add: sharedAdd,\n      // Set#delete(key:void*):boolean\n      'delete': sharedDelete,\n      // Set#clear():\n      clear: sharedClear,\n      // Set#keys(void):Iterator\n      keys: sharedValues, // specs actually say \"the same function object as the initial value of the values property\"\n      // Set#values(void):Iterator\n      values: sharedValues,\n      // Set#entries(void):Iterator\n      entries: setEntries,\n      // Set#forEach(callback:Function, context:void*):void ==> callback.call(context, value, index) === not in specs\n      forEach: sharedForEach\n    });\n  }\n\n  if (typeof WeakSet == 'undefined') {\n    exports.WeakSet = createCollection({\n      // WeakSet#delete(key:void*):boolean\n      'delete': sharedDelete,\n      // WeakSet#add(value:void*):boolean\n      add: sharedAdd,\n      // WeakSet#clear():\n      clear: sharedClear,\n      // WeakSet#has(value:void*):boolean\n      has: setHas\n    }, true);\n  }\n\n  /**\n   * ES6 collection constructor\n   * @return {Function} a collection class\n   */\n  function createCollection(proto, objectOnly) {\n    function Collection(a) {\n      if (!this || this.constructor !== Collection) return new Collection(a);\n      this._keys = [];\n      this._values = [];\n      this._itp = []; // iteration pointers\n      this.objectOnly = objectOnly;\n\n      //parse initial iterable argument passed\n      if (a) init.call(this, a);\n    }\n\n    //define size for non object-only collections\n    if (!objectOnly) {\n      defineProperty(proto, 'size', {\n        get: sharedSize\n      });\n    }\n\n    //set prototype\n    proto.constructor = Collection;\n    Collection.prototype = proto;\n\n    return Collection;\n  }\n\n  /** parse initial iterable argument passed */\n  function init(a) {\n    var i;\n    //init Set argument, like `[1,2,3,{}]`\n    if (this.add) a.forEach(this.add, this);\n    //init Map argument like `[[1,2], [{}, 4]]`\n    else a.forEach(function (a) {\n        this.set(a[0], a[1]);\n      }, this);\n  }\n\n  /** delete */\n  function sharedDelete(key) {\n    if (this.has(key)) {\n      this._keys.splice(i, 1);\n      this._values.splice(i, 1);\n      // update iteration pointers\n      this._itp.forEach(function (p) {\n        if (i < p[0]) p[0]--;\n      });\n    }\n    // Aurora here does it while Canary doesn't\n    return -1 < i;\n  }\n\n  function sharedGet(key) {\n    return this.has(key) ? this._values[i] : undefined;\n  }\n\n  function has(list, key) {\n    if (this.objectOnly && key !== Object(key)) throw new TypeError(\"Invalid value used as weak collection key\");\n    //NaN or 0 passed\n    if (key != key || key === 0) for (i = list.length; i-- && !is(list[i], key);) {} else i = list.indexOf(key);\n    return -1 < i;\n  }\n\n  function setHas(value) {\n    return has.call(this, this._values, value);\n  }\n\n  function mapHas(value) {\n    return has.call(this, this._keys, value);\n  }\n\n  /** @chainable */\n  function sharedSet(key, value) {\n    this.has(key) ? this._values[i] = value : this._values[this._keys.push(key) - 1] = value;\n    return this;\n  }\n\n  /** @chainable */\n  function sharedAdd(value) {\n    if (!this.has(value)) this._values.push(value);\n    return this;\n  }\n\n  function sharedClear() {\n    (this._keys || 0).length = this._values.length = 0;\n  }\n\n  /** keys, values, and iterate related methods */\n  function sharedKeys() {\n    return sharedIterator(this._itp, this._keys);\n  }\n\n  function sharedValues() {\n    return sharedIterator(this._itp, this._values);\n  }\n\n  function mapEntries() {\n    return sharedIterator(this._itp, this._keys, this._values);\n  }\n\n  function setEntries() {\n    return sharedIterator(this._itp, this._values, this._values);\n  }\n\n  function sharedIterator(itp, array, array2) {\n    var p = [0],\n        done = false;\n    itp.push(p);\n    return {\n      next: function next() {\n        var v,\n            k = p[0];\n        if (!done && k < array.length) {\n          v = array2 ? [array[k], array2[k]] : array[k];\n          p[0]++;\n        } else {\n          done = true;\n          itp.splice(itp.indexOf(p), 1);\n        }\n        return { done: done, value: v };\n      }\n    };\n  }\n\n  function sharedSize() {\n    return this._values.length;\n  }\n\n  function sharedForEach(callback, context) {\n    var it = this.entries();\n    for (;;) {\n      var r = it.next();\n      if (r.done) break;\n      callback.call(context, r.value[1], r.value[0], this);\n    }\n  }\n})('object' != 'undefined' && typeof commonjsGlobal != 'undefined' ? commonjsGlobal : window);\n});\n\nvar npo_src = createCommonjsModule(function (module) {\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/*! Native Promise Only\n    v0.8.1 (c) Kyle Simpson\n    MIT License: http://getify.mit-license.org\n*/\n\n(function UMD(name, context, definition) {\n\t// special form of UMD for polyfilling across evironments\n\tcontext[name] = context[name] || definition();\n\tif ('object' != \"undefined\" && module.exports) {\n\t\tmodule.exports = context[name];\n\t} else if (typeof undefined == \"function\" && undefined.amd) {\n\t\tundefined(function $AMD$() {\n\t\t\treturn context[name];\n\t\t});\n\t}\n})(\"Promise\", typeof commonjsGlobal != \"undefined\" ? commonjsGlobal : commonjsGlobal, function DEF() {\n\t/*jshint validthis:true */\n\t\"use strict\";\n\n\tvar builtInProp,\n\t    cycle,\n\t    scheduling_queue,\n\t    ToString = Object.prototype.toString,\n\t    timer = typeof setImmediate != \"undefined\" ? function timer(fn) {\n\t\treturn setImmediate(fn);\n\t} : setTimeout;\n\n\t// dammit, IE8.\n\ttry {\n\t\tObject.defineProperty({}, \"x\", {});\n\t\tbuiltInProp = function builtInProp(obj, name, val, config) {\n\t\t\treturn Object.defineProperty(obj, name, {\n\t\t\t\tvalue: val,\n\t\t\t\twritable: true,\n\t\t\t\tconfigurable: config !== false\n\t\t\t});\n\t\t};\n\t} catch (err) {\n\t\tbuiltInProp = function builtInProp(obj, name, val) {\n\t\t\tobj[name] = val;\n\t\t\treturn obj;\n\t\t};\n\t}\n\n\t// Note: using a queue instead of array for efficiency\n\tscheduling_queue = function Queue() {\n\t\tvar first, last, item;\n\n\t\tfunction Item(fn, self) {\n\t\t\tthis.fn = fn;\n\t\t\tthis.self = self;\n\t\t\tthis.next = void 0;\n\t\t}\n\n\t\treturn {\n\t\t\tadd: function add(fn, self) {\n\t\t\t\titem = new Item(fn, self);\n\t\t\t\tif (last) {\n\t\t\t\t\tlast.next = item;\n\t\t\t\t} else {\n\t\t\t\t\tfirst = item;\n\t\t\t\t}\n\t\t\t\tlast = item;\n\t\t\t\titem = void 0;\n\t\t\t},\n\t\t\tdrain: function drain() {\n\t\t\t\tvar f = first;\n\t\t\t\tfirst = last = cycle = void 0;\n\n\t\t\t\twhile (f) {\n\t\t\t\t\tf.fn.call(f.self);\n\t\t\t\t\tf = f.next;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}();\n\n\tfunction schedule(fn, self) {\n\t\tscheduling_queue.add(fn, self);\n\t\tif (!cycle) {\n\t\t\tcycle = timer(scheduling_queue.drain);\n\t\t}\n\t}\n\n\t// promise duck typing\n\tfunction isThenable(o) {\n\t\tvar _then,\n\t\t    o_type = typeof o === \"undefined\" ? \"undefined\" : _typeof(o);\n\n\t\tif (o != null && (o_type == \"object\" || o_type == \"function\")) {\n\t\t\t_then = o.then;\n\t\t}\n\t\treturn typeof _then == \"function\" ? _then : false;\n\t}\n\n\tfunction notify() {\n\t\tfor (var i = 0; i < this.chain.length; i++) {\n\t\t\tnotifyIsolated(this, this.state === 1 ? this.chain[i].success : this.chain[i].failure, this.chain[i]);\n\t\t}\n\t\tthis.chain.length = 0;\n\t}\n\n\t// NOTE: This is a separate function to isolate\n\t// the `try..catch` so that other code can be\n\t// optimized better\n\tfunction notifyIsolated(self, cb, chain) {\n\t\tvar ret, _then;\n\t\ttry {\n\t\t\tif (cb === false) {\n\t\t\t\tchain.reject(self.msg);\n\t\t\t} else {\n\t\t\t\tif (cb === true) {\n\t\t\t\t\tret = self.msg;\n\t\t\t\t} else {\n\t\t\t\t\tret = cb.call(void 0, self.msg);\n\t\t\t\t}\n\n\t\t\t\tif (ret === chain.promise) {\n\t\t\t\t\tchain.reject(TypeError(\"Promise-chain cycle\"));\n\t\t\t\t} else if (_then = isThenable(ret)) {\n\t\t\t\t\t_then.call(ret, chain.resolve, chain.reject);\n\t\t\t\t} else {\n\t\t\t\t\tchain.resolve(ret);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tchain.reject(err);\n\t\t}\n\t}\n\n\tfunction resolve(msg) {\n\t\tvar _then,\n\t\t    self = this;\n\n\t\t// already triggered?\n\t\tif (self.triggered) {\n\t\t\treturn;\n\t\t}\n\n\t\tself.triggered = true;\n\n\t\t// unwrap\n\t\tif (self.def) {\n\t\t\tself = self.def;\n\t\t}\n\n\t\ttry {\n\t\t\tif (_then = isThenable(msg)) {\n\t\t\t\tschedule(function () {\n\t\t\t\t\tvar def_wrapper = new MakeDefWrapper(self);\n\t\t\t\t\ttry {\n\t\t\t\t\t\t_then.call(msg, function $resolve$() {\n\t\t\t\t\t\t\tresolve.apply(def_wrapper, arguments);\n\t\t\t\t\t\t}, function $reject$() {\n\t\t\t\t\t\t\treject.apply(def_wrapper, arguments);\n\t\t\t\t\t\t});\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\treject.call(def_wrapper, err);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tself.msg = msg;\n\t\t\t\tself.state = 1;\n\t\t\t\tif (self.chain.length > 0) {\n\t\t\t\t\tschedule(notify, self);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (err) {\n\t\t\treject.call(new MakeDefWrapper(self), err);\n\t\t}\n\t}\n\n\tfunction reject(msg) {\n\t\tvar self = this;\n\n\t\t// already triggered?\n\t\tif (self.triggered) {\n\t\t\treturn;\n\t\t}\n\n\t\tself.triggered = true;\n\n\t\t// unwrap\n\t\tif (self.def) {\n\t\t\tself = self.def;\n\t\t}\n\n\t\tself.msg = msg;\n\t\tself.state = 2;\n\t\tif (self.chain.length > 0) {\n\t\t\tschedule(notify, self);\n\t\t}\n\t}\n\n\tfunction iteratePromises(Constructor, arr, resolver, rejecter) {\n\t\tfor (var idx = 0; idx < arr.length; idx++) {\n\t\t\t(function IIFE(idx) {\n\t\t\t\tConstructor.resolve(arr[idx]).then(function $resolver$(msg) {\n\t\t\t\t\tresolver(idx, msg);\n\t\t\t\t}, rejecter);\n\t\t\t})(idx);\n\t\t}\n\t}\n\n\tfunction MakeDefWrapper(self) {\n\t\tthis.def = self;\n\t\tthis.triggered = false;\n\t}\n\n\tfunction MakeDef(self) {\n\t\tthis.promise = self;\n\t\tthis.state = 0;\n\t\tthis.triggered = false;\n\t\tthis.chain = [];\n\t\tthis.msg = void 0;\n\t}\n\n\tfunction Promise(executor) {\n\t\tif (typeof executor != \"function\") {\n\t\t\tthrow TypeError(\"Not a function\");\n\t\t}\n\n\t\tif (this.__NPO__ !== 0) {\n\t\t\tthrow TypeError(\"Not a promise\");\n\t\t}\n\n\t\t// instance shadowing the inherited \"brand\"\n\t\t// to signal an already \"initialized\" promise\n\t\tthis.__NPO__ = 1;\n\n\t\tvar def = new MakeDef(this);\n\n\t\tthis[\"then\"] = function then(success, failure) {\n\t\t\tvar o = {\n\t\t\t\tsuccess: typeof success == \"function\" ? success : true,\n\t\t\t\tfailure: typeof failure == \"function\" ? failure : false\n\t\t\t};\n\t\t\t// Note: `then(..)` itself can be borrowed to be used against\n\t\t\t// a different promise constructor for making the chained promise,\n\t\t\t// by substituting a different `this` binding.\n\t\t\to.promise = new this.constructor(function extractChain(resolve, reject) {\n\t\t\t\tif (typeof resolve != \"function\" || typeof reject != \"function\") {\n\t\t\t\t\tthrow TypeError(\"Not a function\");\n\t\t\t\t}\n\n\t\t\t\to.resolve = resolve;\n\t\t\t\to.reject = reject;\n\t\t\t});\n\t\t\tdef.chain.push(o);\n\n\t\t\tif (def.state !== 0) {\n\t\t\t\tschedule(notify, def);\n\t\t\t}\n\n\t\t\treturn o.promise;\n\t\t};\n\t\tthis[\"catch\"] = function $catch$(failure) {\n\t\t\treturn this.then(void 0, failure);\n\t\t};\n\n\t\ttry {\n\t\t\texecutor.call(void 0, function publicResolve(msg) {\n\t\t\t\tresolve.call(def, msg);\n\t\t\t}, function publicReject(msg) {\n\t\t\t\treject.call(def, msg);\n\t\t\t});\n\t\t} catch (err) {\n\t\t\treject.call(def, err);\n\t\t}\n\t}\n\n\tvar PromisePrototype = builtInProp({}, \"constructor\", Promise,\n\t/*configurable=*/false);\n\n\t// Note: Android 4 cannot use `Object.defineProperty(..)` here\n\tPromise.prototype = PromisePrototype;\n\n\t// built-in \"brand\" to signal an \"uninitialized\" promise\n\tbuiltInProp(PromisePrototype, \"__NPO__\", 0,\n\t/*configurable=*/false);\n\n\tbuiltInProp(Promise, \"resolve\", function Promise$resolve(msg) {\n\t\tvar Constructor = this;\n\n\t\t// spec mandated checks\n\t\t// note: best \"isPromise\" check that's practical for now\n\t\tif (msg && (typeof msg === \"undefined\" ? \"undefined\" : _typeof(msg)) == \"object\" && msg.__NPO__ === 1) {\n\t\t\treturn msg;\n\t\t}\n\n\t\treturn new Constructor(function executor(resolve, reject) {\n\t\t\tif (typeof resolve != \"function\" || typeof reject != \"function\") {\n\t\t\t\tthrow TypeError(\"Not a function\");\n\t\t\t}\n\n\t\t\tresolve(msg);\n\t\t});\n\t});\n\n\tbuiltInProp(Promise, \"reject\", function Promise$reject(msg) {\n\t\treturn new this(function executor(resolve, reject) {\n\t\t\tif (typeof resolve != \"function\" || typeof reject != \"function\") {\n\t\t\t\tthrow TypeError(\"Not a function\");\n\t\t\t}\n\n\t\t\treject(msg);\n\t\t});\n\t});\n\n\tbuiltInProp(Promise, \"all\", function Promise$all(arr) {\n\t\tvar Constructor = this;\n\n\t\t// spec mandated checks\n\t\tif (ToString.call(arr) != \"[object Array]\") {\n\t\t\treturn Constructor.reject(TypeError(\"Not an array\"));\n\t\t}\n\t\tif (arr.length === 0) {\n\t\t\treturn Constructor.resolve([]);\n\t\t}\n\n\t\treturn new Constructor(function executor(resolve, reject) {\n\t\t\tif (typeof resolve != \"function\" || typeof reject != \"function\") {\n\t\t\t\tthrow TypeError(\"Not a function\");\n\t\t\t}\n\n\t\t\tvar len = arr.length,\n\t\t\t    msgs = Array(len),\n\t\t\t    count = 0;\n\n\t\t\titeratePromises(Constructor, arr, function resolver(idx, msg) {\n\t\t\t\tmsgs[idx] = msg;\n\t\t\t\tif (++count === len) {\n\t\t\t\t\tresolve(msgs);\n\t\t\t\t}\n\t\t\t}, reject);\n\t\t});\n\t});\n\n\tbuiltInProp(Promise, \"race\", function Promise$race(arr) {\n\t\tvar Constructor = this;\n\n\t\t// spec mandated checks\n\t\tif (ToString.call(arr) != \"[object Array]\") {\n\t\t\treturn Constructor.reject(TypeError(\"Not an array\"));\n\t\t}\n\n\t\treturn new Constructor(function executor(resolve, reject) {\n\t\t\tif (typeof resolve != \"function\" || typeof reject != \"function\") {\n\t\t\t\tthrow TypeError(\"Not a function\");\n\t\t\t}\n\n\t\t\titeratePromises(Constructor, arr, function resolver(idx, msg) {\n\t\t\t\tresolve(msg);\n\t\t\t}, reject);\n\t\t});\n\t});\n\n\treturn Promise;\n});\n});\n\n/**\n * @module lib/callbacks\n */\n\nvar callbackMap = new WeakMap();\n\n/**\n * Store a callback for a method or event for a player.\n *\n * @author Brad Dougherty <brad@vimeo.com>\n * @param {Player} player The player object.\n * @param {string} name The method or event name.\n * @param {(function(this:Player, *): void|{resolve: function, reject: function})} callback\n *        The callback to call or an object with resolve and reject functions for a promise.\n * @return {void}\n */\nfunction storeCallback(player, name, callback) {\n    var playerCallbacks = callbackMap.get(player.element) || {};\n\n    if (!(name in playerCallbacks)) {\n        playerCallbacks[name] = [];\n    }\n\n    playerCallbacks[name].push(callback);\n    callbackMap.set(player.element, playerCallbacks);\n}\n\n/**\n * Get the callbacks for a player and event or method.\n *\n * @author Brad Dougherty <brad@vimeo.com>\n * @param {Player} player The player object.\n * @param {string} name The method or event name\n * @return {function[]}\n */\nfunction getCallbacks(player, name) {\n    var playerCallbacks = callbackMap.get(player.element) || {};\n    return playerCallbacks[name] || [];\n}\n\n/**\n * Remove a stored callback for a method or event for a player.\n *\n * @author Brad Dougherty <brad@vimeo.com>\n * @param {Player} player The player object.\n * @param {string} name The method or event name\n * @param {function} [callback] The specific callback to remove.\n * @return {boolean} Was this the last callback?\n */\nfunction removeCallback(player, name, callback) {\n    var playerCallbacks = callbackMap.get(player.element) || {};\n\n    if (!playerCallbacks[name]) {\n        return true;\n    }\n\n    // If no callback is passed, remove all callbacks for the event\n    if (!callback) {\n        playerCallbacks[name] = [];\n        callbackMap.set(player.element, playerCallbacks);\n\n        return true;\n    }\n\n    var index = playerCallbacks[name].indexOf(callback);\n\n    if (index !== -1) {\n        playerCallbacks[name].splice(index, 1);\n    }\n\n    callbackMap.set(player.element, playerCallbacks);\n    return playerCallbacks[name] && playerCallbacks[name].length === 0;\n}\n\n/**\n * Return the first stored callback for a player and event or method.\n *\n * @param {Player} player The player object.\n * @param {string} name The method or event name.\n * @return {function} The callback, or false if there were none\n */\nfunction shiftCallbacks(player, name) {\n    var playerCallbacks = getCallbacks(player, name);\n\n    if (playerCallbacks.length < 1) {\n        return false;\n    }\n\n    var callback = playerCallbacks.shift();\n    removeCallback(player, name, callback);\n    return callback;\n}\n\n/**\n * Move callbacks associated with an element to another element.\n *\n * @author Brad Dougherty <brad@vimeo.com>\n * @param {HTMLElement} oldElement The old element.\n * @param {HTMLElement} newElement The new element.\n * @return {void}\n */\nfunction swapCallbacks(oldElement, newElement) {\n    var playerCallbacks = callbackMap.get(oldElement);\n\n    callbackMap.set(newElement, playerCallbacks);\n    callbackMap.delete(oldElement);\n}\n\n/**\n * @module lib/functions\n */\n\n/**\n * Get the name of the method for a given getter or setter.\n *\n * @author Brad Dougherty <brad@vimeo.com>\n * @param {string} prop The name of the property.\n * @param {string} type Either “get” or “set”.\n * @return {string}\n */\nfunction getMethodName(prop, type) {\n    if (prop.indexOf(type.toLowerCase()) === 0) {\n        return prop;\n    }\n\n    return '' + type.toLowerCase() + prop.substr(0, 1).toUpperCase() + prop.substr(1);\n}\n\n/**\n * Check to see if the object is a DOM Element.\n *\n * @author Brad Dougherty <brad@vimeo.com>\n * @param {*} element The object to check.\n * @return {boolean}\n */\nfunction isDomElement(element) {\n    return element instanceof window.HTMLElement;\n}\n\n/**\n * Check to see whether the value is a number.\n *\n * @author Brad Dougherty <brad@vimeo.com>\n * @see http://dl.dropboxusercontent.com/u/35146/js/tests/isNumber.html\n * @param {*} value The value to check.\n * @param {boolean} integer Check if the value is an integer.\n * @return {boolean}\n */\nfunction isInteger(value) {\n    // eslint-disable-next-line eqeqeq\n    return !isNaN(parseFloat(value)) && isFinite(value) && Math.floor(value) == value;\n}\n\n/**\n * Check to see if the URL is a Vimeo url.\n *\n * @author Brad Dougherty <brad@vimeo.com>\n * @param {string} url The url string.\n * @return {boolean}\n */\nfunction isVimeoUrl(url) {\n    return (/^(https?:)?\\/\\/((player|www).)?vimeo.com(?=$|\\/)/.test(url)\n    );\n}\n\n/**\n * Get the Vimeo URL from an element.\n * The element must have either a data-vimeo-id or data-vimeo-url attribute.\n *\n * @author Brad Dougherty <brad@vimeo.com>\n * @param {object} oEmbedParameters The oEmbed parameters.\n * @return {string}\n */\nfunction getVimeoUrl() {\n    var oEmbedParameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    var id = oEmbedParameters.id;\n    var url = oEmbedParameters.url;\n    var idOrUrl = id || url;\n\n    if (!idOrUrl) {\n        throw new Error('An id or url must be passed, either in an options object or as a data-vimeo-id or data-vimeo-url attribute.');\n    }\n\n    if (isInteger(idOrUrl)) {\n        return 'https://vimeo.com/' + idOrUrl;\n    }\n\n    if (isVimeoUrl(idOrUrl)) {\n        return idOrUrl.replace('http:', 'https:');\n    }\n\n    if (id) {\n        throw new TypeError('\\u201C' + id + '\\u201D is not a valid video id.');\n    }\n\n    throw new TypeError('\\u201C' + idOrUrl + '\\u201D is not a vimeo.com url.');\n}\n\n/**\n * @module lib/embed\n */\n\nvar oEmbedParameters = ['id', 'url', 'width', 'maxwidth', 'height', 'maxheight', 'portrait', 'title', 'byline', 'color', 'autoplay', 'autopause', 'loop', 'responsive'];\n\n/**\n * Get the 'data-vimeo'-prefixed attributes from an element as an object.\n *\n * @author Brad Dougherty <brad@vimeo.com>\n * @param {HTMLElement} element The element.\n * @param {Object} [defaults={}] The default values to use.\n * @return {Object<string, string>}\n */\nfunction getOEmbedParameters(element) {\n    var defaults = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    return oEmbedParameters.reduce(function (params, param) {\n        var value = element.getAttribute('data-vimeo-' + param);\n\n        if (value || value === '') {\n            params[param] = value === '' ? 1 : value;\n        }\n\n        return params;\n    }, defaults);\n}\n\n/**\n * Make an oEmbed call for the specified URL.\n *\n * @author Brad Dougherty <brad@vimeo.com>\n * @param {string} videoUrl The vimeo.com url for the video.\n * @param {Object} [params] Parameters to pass to oEmbed.\n * @return {Promise}\n */\nfunction getOEmbedData(videoUrl) {\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    return new Promise(function (resolve, reject) {\n        if (!isVimeoUrl(videoUrl)) {\n            throw new TypeError('\\u201C' + videoUrl + '\\u201D is not a vimeo.com url.');\n        }\n\n        var url = 'https://vimeo.com/api/oembed.json?url=' + encodeURIComponent(videoUrl);\n\n        for (var param in params) {\n            if (params.hasOwnProperty(param)) {\n                url += '&' + param + '=' + encodeURIComponent(params[param]);\n            }\n        }\n\n        var xhr = 'XDomainRequest' in window ? new XDomainRequest() : new XMLHttpRequest();\n        xhr.open('GET', url, true);\n\n        xhr.onload = function () {\n            if (xhr.status === 404) {\n                reject(new Error('\\u201C' + videoUrl + '\\u201D was not found.'));\n                return;\n            }\n\n            if (xhr.status === 403) {\n                reject(new Error('\\u201C' + videoUrl + '\\u201D is not embeddable.'));\n                return;\n            }\n\n            try {\n                var json = JSON.parse(xhr.responseText);\n                resolve(json);\n            } catch (error) {\n                reject(error);\n            }\n        };\n\n        xhr.onerror = function () {\n            var status = xhr.status ? ' (' + xhr.status + ')' : '';\n            reject(new Error('There was an error fetching the embed code from Vimeo' + status + '.'));\n        };\n\n        xhr.send();\n    });\n}\n\n/**\n * Create an embed from oEmbed data inside an element.\n *\n * @author Brad Dougherty <brad@vimeo.com>\n * @param {object} data The oEmbed data.\n * @param {HTMLElement} element The element to put the iframe in.\n * @return {HTMLIFrameElement} The iframe embed.\n */\nfunction createEmbed(_ref, element) {\n    var html = _ref.html;\n\n    if (!element) {\n        throw new TypeError('An element must be provided');\n    }\n\n    if (element.getAttribute('data-vimeo-initialized') !== null) {\n        return element.querySelector('iframe');\n    }\n\n    var div = document.createElement('div');\n    div.innerHTML = html;\n\n    element.appendChild(div.firstChild);\n    element.setAttribute('data-vimeo-initialized', 'true');\n\n    return element.querySelector('iframe');\n}\n\n/**\n * Initialize all embeds within a specific element\n *\n * @author Brad Dougherty <brad@vimeo.com>\n * @param {HTMLElement} [parent=document] The parent element.\n * @return {void}\n */\nfunction initializeEmbeds() {\n    var parent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;\n\n    var elements = [].slice.call(parent.querySelectorAll('[data-vimeo-id], [data-vimeo-url]'));\n\n    var handleError = function handleError(error) {\n        if ('console' in window && console.error) {\n            console.error('There was an error creating an embed: ' + error);\n        }\n    };\n\n    elements.forEach(function (element) {\n        try {\n            // Skip any that have data-vimeo-defer\n            if (element.getAttribute('data-vimeo-defer') !== null) {\n                return;\n            }\n\n            var params = getOEmbedParameters(element);\n            var url = getVimeoUrl(params);\n\n            getOEmbedData(url, params).then(function (data) {\n                return createEmbed(data, element);\n            }).catch(handleError);\n        } catch (error) {\n            handleError(error);\n        }\n    });\n}\n\n/**\n * @module lib/postmessage\n */\n\n/**\n * Parse a message received from postMessage.\n *\n * @param {*} data The data received from postMessage.\n * @return {object}\n */\nfunction parseMessageData(data) {\n    if (typeof data === 'string') {\n        data = JSON.parse(data);\n    }\n\n    return data;\n}\n\n/**\n * Post a message to the specified target.\n *\n * @author Brad Dougherty <brad@vimeo.com>\n * @param {Player} player The player object to use.\n * @param {string} method The API method to call.\n * @param {object} params The parameters to send to the player.\n * @return {void}\n */\nfunction postMessage(player, method, params) {\n    if (!player.element.contentWindow || !player.element.contentWindow.postMessage) {\n        return;\n    }\n\n    var message = {\n        method: method\n    };\n\n    if (params !== undefined) {\n        message.value = params;\n    }\n\n    // IE 8 and 9 do not support passing messages, so stringify them\n    var ieVersion = parseFloat(navigator.userAgent.toLowerCase().replace(/^.*msie (\\d+).*$/, '$1'));\n    if (ieVersion >= 8 && ieVersion < 10) {\n        message = JSON.stringify(message);\n    }\n\n    player.element.contentWindow.postMessage(message, player.origin);\n}\n\n/**\n * Parse the data received from a message event.\n *\n * @author Brad Dougherty <brad@vimeo.com>\n * @param {Player} player The player that received the message.\n * @param {(Object|string)} data The message data. Strings will be parsed into JSON.\n * @return {void}\n */\nfunction processData(player, data) {\n    data = parseMessageData(data);\n    var callbacks = [];\n    var param = void 0;\n\n    if (data.event) {\n        if (data.event === 'error') {\n            var promises = getCallbacks(player, data.data.method);\n\n            promises.forEach(function (promise) {\n                var error = new Error(data.data.message);\n                error.name = data.data.name;\n\n                promise.reject(error);\n                removeCallback(player, data.data.method, promise);\n            });\n        }\n\n        callbacks = getCallbacks(player, 'event:' + data.event);\n        param = data.data;\n    } else if (data.method) {\n        var callback = shiftCallbacks(player, data.method);\n\n        if (callback) {\n            callbacks.push(callback);\n            param = data.value;\n        }\n    }\n\n    callbacks.forEach(function (callback) {\n        try {\n            if (typeof callback === 'function') {\n                callback.call(player, param);\n                return;\n            }\n\n            callback.resolve(param);\n        } catch (e) {\n            // empty\n        }\n    });\n}\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar playerMap = new WeakMap();\nvar readyMap = new WeakMap();\n\nvar Player = function () {\n    /**\n    * Create a Player.\n    *\n    * @author Brad Dougherty <brad@vimeo.com>\n    * @param {(HTMLIFrameElement|HTMLElement|string|jQuery)} element A reference to the Vimeo\n    *        player iframe, and id, or a jQuery object.\n    * @param {object} [options] oEmbed parameters to use when creating an embed in the element.\n    * @return {Player}\n    */\n    function Player(element) {\n        var _this = this;\n\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        _classCallCheck(this, Player);\n\n        /* global jQuery */\n        if (window.jQuery && element instanceof jQuery) {\n            if (element.length > 1 && window.console && console.warn) {\n                console.warn('A jQuery object with multiple elements was passed, using the first element.');\n            }\n\n            element = element[0];\n        }\n\n        // Find an element by ID\n        if (typeof element === 'string') {\n            element = document.getElementById(element);\n        }\n\n        // Not an element!\n        if (!isDomElement(element)) {\n            throw new TypeError('You must pass either a valid element or a valid id.');\n        }\n\n        // Already initialized an embed in this div, so grab the iframe\n        if (element.nodeName !== 'IFRAME') {\n            var iframe = element.querySelector('iframe');\n\n            if (iframe) {\n                element = iframe;\n            }\n        }\n\n        // iframe url is not a Vimeo url\n        if (element.nodeName === 'IFRAME' && !isVimeoUrl(element.getAttribute('src') || '')) {\n            throw new Error('The player element passed isn’t a Vimeo embed.');\n        }\n\n        // If there is already a player object in the map, return that\n        if (playerMap.has(element)) {\n            return playerMap.get(element);\n        }\n\n        this.element = element;\n        this.origin = '*';\n\n        var readyPromise = new npo_src(function (resolve, reject) {\n            var onMessage = function onMessage(event) {\n                if (!isVimeoUrl(event.origin) || _this.element.contentWindow !== event.source) {\n                    return;\n                }\n\n                if (_this.origin === '*') {\n                    _this.origin = event.origin;\n                }\n\n                var data = parseMessageData(event.data);\n                var isReadyEvent = 'event' in data && data.event === 'ready';\n                var isPingResponse = 'method' in data && data.method === 'ping';\n\n                if (isReadyEvent || isPingResponse) {\n                    _this.element.setAttribute('data-ready', 'true');\n                    resolve();\n                    return;\n                }\n\n                processData(_this, data);\n            };\n\n            if (window.addEventListener) {\n                window.addEventListener('message', onMessage, false);\n            } else if (window.attachEvent) {\n                window.attachEvent('onmessage', onMessage);\n            }\n\n            if (_this.element.nodeName !== 'IFRAME') {\n                var params = getOEmbedParameters(element, options);\n                var url = getVimeoUrl(params);\n\n                getOEmbedData(url, params).then(function (data) {\n                    var iframe = createEmbed(data, element);\n                    _this.element = iframe;\n\n                    swapCallbacks(element, iframe);\n                    playerMap.set(_this.element, _this);\n\n                    return data;\n                }).catch(function (error) {\n                    return reject(error);\n                });\n            }\n        });\n\n        // Store a copy of this Player in the map\n        readyMap.set(this, readyPromise);\n        playerMap.set(this.element, this);\n\n        // Send a ping to the iframe so the ready promise will be resolved if\n        // the player is already ready.\n        if (this.element.nodeName === 'IFRAME') {\n            postMessage(this, 'ping');\n        }\n\n        return this;\n    }\n\n    /**\n     * Get a promise for a method.\n     *\n     * @author Brad Dougherty <brad@vimeo.com>\n     * @param {string} name The API method to call.\n     * @param {Object} [args={}] Arguments to send via postMessage.\n     * @return {Promise}\n     */\n\n\n    _createClass(Player, [{\n        key: 'callMethod',\n        value: function callMethod(name) {\n            var _this2 = this;\n\n            var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n            return new npo_src(function (resolve, reject) {\n                // We are storing the resolve/reject handlers to call later, so we\n                // can’t return here.\n                // eslint-disable-next-line promise/always-return\n                return _this2.ready().then(function () {\n                    storeCallback(_this2, name, {\n                        resolve: resolve,\n                        reject: reject\n                    });\n\n                    postMessage(_this2, name, args);\n                });\n            });\n        }\n\n        /**\n         * Get a promise for the value of a player property.\n         *\n         * @author Brad Dougherty <brad@vimeo.com>\n         * @param {string} name The property name\n         * @return {Promise}\n         */\n\n    }, {\n        key: 'get',\n        value: function get(name) {\n            var _this3 = this;\n\n            return new npo_src(function (resolve, reject) {\n                name = getMethodName(name, 'get');\n\n                // We are storing the resolve/reject handlers to call later, so we\n                // can’t return here.\n                // eslint-disable-next-line promise/always-return\n                return _this3.ready().then(function () {\n                    storeCallback(_this3, name, {\n                        resolve: resolve,\n                        reject: reject\n                    });\n\n                    postMessage(_this3, name);\n                });\n            });\n        }\n\n        /**\n         * Get a promise for setting the value of a player property.\n         *\n         * @author Brad Dougherty <brad@vimeo.com>\n         * @param {string} name The API method to call.\n         * @param {mixed} value The value to set.\n         * @return {Promise}\n         */\n\n    }, {\n        key: 'set',\n        value: function set(name, value) {\n            var _this4 = this;\n\n            return npo_src.resolve(value).then(function (val) {\n                name = getMethodName(name, 'set');\n\n                if (val === undefined || val === null) {\n                    throw new TypeError('There must be a value to set.');\n                }\n\n                return _this4.ready().then(function () {\n                    return new npo_src(function (resolve, reject) {\n                        storeCallback(_this4, name, {\n                            resolve: resolve,\n                            reject: reject\n                        });\n\n                        postMessage(_this4, name, val);\n                    });\n                });\n            });\n        }\n\n        /**\n         * Add an event listener for the specified event. Will call the\n         * callback with a single parameter, `data`, that contains the data for\n         * that event.\n         *\n         * @author Brad Dougherty <brad@vimeo.com>\n         * @param {string} eventName The name of the event.\n         * @param {function(*)} callback The function to call when the event fires.\n         * @return {void}\n         */\n\n    }, {\n        key: 'on',\n        value: function on(eventName, callback) {\n            if (!eventName) {\n                throw new TypeError('You must pass an event name.');\n            }\n\n            if (!callback) {\n                throw new TypeError('You must pass a callback function.');\n            }\n\n            if (typeof callback !== 'function') {\n                throw new TypeError('The callback must be a function.');\n            }\n\n            var callbacks = getCallbacks(this, 'event:' + eventName);\n            if (callbacks.length === 0) {\n                this.callMethod('addEventListener', eventName).catch(function () {\n                    // Ignore the error. There will be an error event fired that\n                    // will trigger the error callback if they are listening.\n                });\n            }\n\n            storeCallback(this, 'event:' + eventName, callback);\n        }\n\n        /**\n         * Remove an event listener for the specified event. Will remove all\n         * listeners for that event if a `callback` isn’t passed, or only that\n         * specific callback if it is passed.\n         *\n         * @author Brad Dougherty <brad@vimeo.com>\n         * @param {string} eventName The name of the event.\n         * @param {function} [callback] The specific callback to remove.\n         * @return {void}\n         */\n\n    }, {\n        key: 'off',\n        value: function off(eventName, callback) {\n            if (!eventName) {\n                throw new TypeError('You must pass an event name.');\n            }\n\n            if (callback && typeof callback !== 'function') {\n                throw new TypeError('The callback must be a function.');\n            }\n\n            var lastCallback = removeCallback(this, 'event:' + eventName, callback);\n\n            // If there are no callbacks left, remove the listener\n            if (lastCallback) {\n                this.callMethod('removeEventListener', eventName).catch(function (e) {\n                    // Ignore the error. There will be an error event fired that\n                    // will trigger the error callback if they are listening.\n                });\n            }\n        }\n\n        /**\n         * A promise to load a new video.\n         *\n         * @promise LoadVideoPromise\n         * @fulfill {number} The video with this id successfully loaded.\n         * @reject {TypeError} The id was not a number.\n         */\n        /**\n         * Load a new video into this embed. The promise will be resolved if\n         * the video is successfully loaded, or it will be rejected if it could\n         * not be loaded.\n         *\n         * @author Brad Dougherty <brad@vimeo.com>\n         * @param {number} id The id of the video.\n         * @return {LoadVideoPromise}\n         */\n\n    }, {\n        key: 'loadVideo',\n        value: function loadVideo(id) {\n            return this.callMethod('loadVideo', id);\n        }\n\n        /**\n         * A promise to perform an action when the Player is ready.\n         *\n         * @todo document errors\n         * @promise LoadVideoPromise\n         * @fulfill {void}\n         */\n        /**\n         * Trigger a function when the player iframe has initialized. You do not\n         * need to wait for `ready` to trigger to begin adding event listeners\n         * or calling other methods.\n         *\n         * @author Brad Dougherty <brad@vimeo.com>\n         * @return {ReadyPromise}\n         */\n\n    }, {\n        key: 'ready',\n        value: function ready() {\n            var readyPromise = readyMap.get(this);\n            return npo_src.resolve(readyPromise);\n        }\n\n        /**\n         * A promise to add a cue point to the player.\n         *\n         * @promise AddCuePointPromise\n         * @fulfill {string} The id of the cue point to use for removeCuePoint.\n         * @reject {RangeError} the time was less than 0 or greater than the\n         *         video’s duration.\n         * @reject {UnsupportedError} Cue points are not supported with the current\n         *         player or browser.\n         */\n        /**\n         * Add a cue point to the player.\n         *\n         * @author Brad Dougherty <brad@vimeo.com>\n         * @param {number} time The time for the cue point.\n         * @param {object} [data] Arbitrary data to be returned with the cue point.\n         * @return {AddCuePointPromise}\n         */\n\n    }, {\n        key: 'addCuePoint',\n        value: function addCuePoint(time) {\n            var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n            return this.callMethod('addCuePoint', { time: time, data: data });\n        }\n\n        /**\n         * A promise to remove a cue point from the player.\n         *\n         * @promise AddCuePointPromise\n         * @fulfill {string} The id of the cue point that was removed.\n         * @reject {InvalidCuePoint} The cue point with the specified id was not\n         *         found.\n         * @reject {UnsupportedError} Cue points are not supported with the current\n         *         player or browser.\n         */\n        /**\n         * Remove a cue point from the video.\n         *\n         * @author Brad Dougherty <brad@vimeo.com>\n         * @param {string} id The id of the cue point to remove.\n         * @return {RemoveCuePointPromise}\n         */\n\n    }, {\n        key: 'removeCuePoint',\n        value: function removeCuePoint(id) {\n            return this.callMethod('removeCuePoint', id);\n        }\n\n        /**\n         * A representation of a text track on a video.\n         *\n         * @typedef {Object} VimeoTextTrack\n         * @property {string} language The ISO language code.\n         * @property {string} kind The kind of track it is (captions or subtitles).\n         * @property {string} label The human‐readable label for the track.\n         */\n        /**\n         * A promise to enable a text track.\n         *\n         * @promise EnableTextTrackPromise\n         * @fulfill {VimeoTextTrack} The text track that was enabled.\n         * @reject {InvalidTrackLanguageError} No track was available with the\n         *         specified language.\n         * @reject {InvalidTrackError} No track was available with the specified\n         *         language and kind.\n         */\n        /**\n         * Enable the text track with the specified language, and optionally the\n         * specified kind (captions or subtitles).\n         *\n         * When set via the API, the track language will not change the viewer’s\n         * stored preference.\n         *\n         * @author Brad Dougherty <brad@vimeo.com>\n         * @param {string} language The two‐letter language code.\n         * @param {string} [kind] The kind of track to enable (captions or subtitles).\n         * @return {EnableTextTrackPromise}\n         */\n\n    }, {\n        key: 'enableTextTrack',\n        value: function enableTextTrack(language, kind) {\n            if (!language) {\n                throw new TypeError('You must pass a language.');\n            }\n\n            return this.callMethod('enableTextTrack', {\n                language: language,\n                kind: kind\n            });\n        }\n\n        /**\n         * A promise to disable the active text track.\n         *\n         * @promise DisableTextTrackPromise\n         * @fulfill {void} The track was disabled.\n         */\n        /**\n         * Disable the currently-active text track.\n         *\n         * @author Brad Dougherty <brad@vimeo.com>\n         * @return {DisableTextTrackPromise}\n         */\n\n    }, {\n        key: 'disableTextTrack',\n        value: function disableTextTrack() {\n            return this.callMethod('disableTextTrack');\n        }\n\n        /**\n         * A promise to pause the video.\n         *\n         * @promise PausePromise\n         * @fulfill {void} The video was paused.\n         */\n        /**\n         * Pause the video if it’s playing.\n         *\n         * @author Brad Dougherty <brad@vimeo.com>\n         * @return {PausePromise}\n         */\n\n    }, {\n        key: 'pause',\n        value: function pause() {\n            return this.callMethod('pause');\n        }\n\n        /**\n         * A promise to play the video.\n         *\n         * @promise PlayPromise\n         * @fulfill {void} The video was played.\n         */\n        /**\n         * Play the video if it’s paused. **Note:** on iOS and some other\n         * mobile devices, you cannot programmatically trigger play. Once the\n         * viewer has tapped on the play button in the player, however, you\n         * will be able to use this function.\n         *\n         * @author Brad Dougherty <brad@vimeo.com>\n         * @return {PlayPromise}\n         */\n\n    }, {\n        key: 'play',\n        value: function play() {\n            return this.callMethod('play');\n        }\n\n        /**\n         * A promise to unload the video.\n         *\n         * @promise UnloadPromise\n         * @fulfill {void} The video was unloaded.\n         */\n        /**\n         * Return the player to its initial state.\n         *\n         * @author Brad Dougherty <brad@vimeo.com>\n         * @return {UnloadPromise}\n         */\n\n    }, {\n        key: 'unload',\n        value: function unload() {\n            return this.callMethod('unload');\n        }\n\n        /**\n         * A promise to get the autopause behavior of the video.\n         *\n         * @promise GetAutopausePromise\n         * @fulfill {boolean} Whether autopause is turned on or off.\n         * @reject {UnsupportedError} Autopause is not supported with the current\n         *         player or browser.\n         */\n        /**\n         * Get the autopause behavior for this player.\n         *\n         * @author Brad Dougherty <brad@vimeo.com>\n         * @return {GetAutopausePromise}\n         */\n\n    }, {\n        key: 'getAutopause',\n        value: function getAutopause() {\n            return this.get('autopause');\n        }\n\n        /**\n         * A promise to set the autopause behavior of the video.\n         *\n         * @promise SetAutopausePromise\n         * @fulfill {boolean} Whether autopause is turned on or off.\n         * @reject {UnsupportedError} Autopause is not supported with the current\n         *         player or browser.\n         */\n        /**\n         * Enable or disable the autopause behavior of this player.\n         *\n         * By default, when another video is played in the same browser, this\n         * player will automatically pause. Unless you have a specific reason\n         * for doing so, we recommend that you leave autopause set to the\n         * default (`true`).\n         *\n         * @author Brad Dougherty <brad@vimeo.com>\n         * @param {boolean} autopause\n         * @return {SetAutopausePromise}\n         */\n\n    }, {\n        key: 'setAutopause',\n        value: function setAutopause(autopause) {\n            return this.set('autopause', autopause);\n        }\n\n        /**\n         * A promise to get the color of the player.\n         *\n         * @promise GetColorPromise\n         * @fulfill {string} The hex color of the player.\n         */\n        /**\n         * Get the color for this player.\n         *\n         * @author Brad Dougherty <brad@vimeo.com>\n         * @return {GetColorPromise}\n         */\n\n    }, {\n        key: 'getColor',\n        value: function getColor() {\n            return this.get('color');\n        }\n\n        /**\n         * A promise to set the color of the player.\n         *\n         * @promise SetColorPromise\n         * @fulfill {string} The color was successfully set.\n         * @reject {TypeError} The string was not a valid hex or rgb color.\n         * @reject {ContrastError} The color was set, but the contrast is\n         *         outside of the acceptable range.\n         * @reject {EmbedSettingsError} The owner of the player has chosen to\n         *         use a specific color.\n         */\n        /**\n         * Set the color of this player to a hex or rgb string. Setting the\n         * color may fail if the owner of the video has set their embed\n         * preferences to force a specific color.\n         *\n         * @author Brad Dougherty <brad@vimeo.com>\n         * @param {string} color The hex or rgb color string to set.\n         * @return {SetColorPromise}\n         */\n\n    }, {\n        key: 'setColor',\n        value: function setColor(color) {\n            return this.set('color', color);\n        }\n\n        /**\n         * A representation of a cue point.\n         *\n         * @typedef {Object} VimeoCuePoint\n         * @property {number} time The time of the cue point.\n         * @property {object} data The data passed when adding the cue point.\n         * @property {string} id The unique id for use with removeCuePoint.\n         */\n        /**\n         * A promise to get the cue points of a video.\n         *\n         * @promise GetCuePointsPromise\n         * @fulfill {VimeoCuePoint[]} The cue points added to the video.\n         * @reject {UnsupportedError} Cue points are not supported with the current\n         *         player or browser.\n         */\n        /**\n         * Get an array of the cue points added to the video.\n         *\n         * @author Brad Dougherty <brad@vimeo.com>\n         * @return {GetCuePointsPromise}\n         */\n\n    }, {\n        key: 'getCuePoints',\n        value: function getCuePoints() {\n            return this.get('cuePoints');\n        }\n\n        /**\n         * A promise to get the current time of the video.\n         *\n         * @promise GetCurrentTimePromise\n         * @fulfill {number} The current time in seconds.\n         */\n        /**\n         * Get the current playback position in seconds.\n         *\n         * @author Brad Dougherty <brad@vimeo.com>\n         * @return {GetCurrentTimePromise}\n         */\n\n    }, {\n        key: 'getCurrentTime',\n        value: function getCurrentTime() {\n            return this.get('currentTime');\n        }\n\n        /**\n         * A promise to set the current time of the video.\n         *\n         * @promise SetCurrentTimePromise\n         * @fulfill {number} The actual current time that was set.\n         * @reject {RangeError} the time was less than 0 or greater than the\n         *         video’s duration.\n         */\n        /**\n         * Set the current playback position in seconds. If the player was\n         * paused, it will remain paused. Likewise, if the player was playing,\n         * it will resume playing once the video has buffered.\n         *\n         * You can provide an accurate time and the player will attempt to seek\n         * to as close to that time as possible. The exact time will be the\n         * fulfilled value of the promise.\n         *\n         * @author Brad Dougherty <brad@vimeo.com>\n         * @param {number} currentTime\n         * @return {SetCurrentTimePromise}\n         */\n\n    }, {\n        key: 'setCurrentTime',\n        value: function setCurrentTime(currentTime) {\n            return this.set('currentTime', currentTime);\n        }\n\n        /**\n         * A promise to get the duration of the video.\n         *\n         * @promise GetDurationPromise\n         * @fulfill {number} The duration in seconds.\n         */\n        /**\n         * Get the duration of the video in seconds. It will be rounded to the\n         * nearest second before playback begins, and to the nearest thousandth\n         * of a second after playback begins.\n         *\n         * @author Brad Dougherty <brad@vimeo.com>\n         * @return {GetDurationPromise}\n         */\n\n    }, {\n        key: 'getDuration',\n        value: function getDuration() {\n            return this.get('duration');\n        }\n\n        /**\n         * A promise to get the ended state of the video.\n         *\n         * @promise GetEndedPromise\n         * @fulfill {boolean} Whether or not the video has ended.\n         */\n        /**\n         * Get the ended state of the video. The video has ended if\n         * `currentTime === duration`.\n         *\n         * @author Brad Dougherty <brad@vimeo.com>\n         * @return {GetEndedPromise}\n         */\n\n    }, {\n        key: 'getEnded',\n        value: function getEnded() {\n            return this.get('ended');\n        }\n\n        /**\n         * A promise to get the loop state of the player.\n         *\n         * @promise GetLoopPromise\n         * @fulfill {boolean} Whether or not the player is set to loop.\n         */\n        /**\n         * Get the loop state of the player.\n         *\n         * @author Brad Dougherty <brad@vimeo.com>\n         * @return {GetLoopPromise}\n         */\n\n    }, {\n        key: 'getLoop',\n        value: function getLoop() {\n            return this.get('loop');\n        }\n\n        /**\n         * A promise to set the loop state of the player.\n         *\n         * @promise SetLoopPromise\n         * @fulfill {boolean} The loop state that was set.\n         */\n        /**\n         * Set the loop state of the player. When set to `true`, the player\n         * will start over immediately once playback ends.\n         *\n         * @author Brad Dougherty <brad@vimeo.com>\n         * @param {boolean} loop\n         * @return {SetLoopPromise}\n         */\n\n    }, {\n        key: 'setLoop',\n        value: function setLoop(loop) {\n            return this.set('loop', loop);\n        }\n\n        /**\n         * A promise to get the paused state of the player.\n         *\n         * @promise GetLoopPromise\n         * @fulfill {boolean} Whether or not the video is paused.\n         */\n        /**\n         * Get the paused state of the player.\n         *\n         * @author Brad Dougherty <brad@vimeo.com>\n         * @return {GetLoopPromise}\n         */\n\n    }, {\n        key: 'getPaused',\n        value: function getPaused() {\n            return this.get('paused');\n        }\n\n        /**\n         * A promise to get the text tracks of a video.\n         *\n         * @promise GetTextTracksPromise\n         * @fulfill {VimeoTextTrack[]} The text tracks associated with the video.\n         */\n        /**\n         * Get an array of the text tracks that exist for the video.\n         *\n         * @author Brad Dougherty <brad@vimeo.com>\n         * @return {GetTextTracksPromise}\n         */\n\n    }, {\n        key: 'getTextTracks',\n        value: function getTextTracks() {\n            return this.get('textTracks');\n        }\n\n        /**\n         * A promise to get the embed code for the video.\n         *\n         * @promise GetVideoEmbedCodePromise\n         * @fulfill {string} The `<iframe>` embed code for the video.\n         */\n        /**\n         * Get the `<iframe>` embed code for the video.\n         *\n         * @author Brad Dougherty <brad@vimeo.com>\n         * @return {GetVideoEmbedCodePromise}\n         */\n\n    }, {\n        key: 'getVideoEmbedCode',\n        value: function getVideoEmbedCode() {\n            return this.get('videoEmbedCode');\n        }\n\n        /**\n         * A promise to get the id of the video.\n         *\n         * @promise GetVideoIdPromise\n         * @fulfill {number} The id of the video.\n         */\n        /**\n         * Get the id of the video.\n         *\n         * @author Brad Dougherty <brad@vimeo.com>\n         * @return {GetVideoIdPromise}\n         */\n\n    }, {\n        key: 'getVideoId',\n        value: function getVideoId() {\n            return this.get('videoId');\n        }\n\n        /**\n         * A promise to get the title of the video.\n         *\n         * @promise GetVideoTitlePromise\n         * @fulfill {number} The title of the video.\n         */\n        /**\n         * Get the title of the video.\n         *\n         * @author Brad Dougherty <brad@vimeo.com>\n         * @return {GetVideoTitlePromise}\n         */\n\n    }, {\n        key: 'getVideoTitle',\n        value: function getVideoTitle() {\n            return this.get('videoTitle');\n        }\n\n        /**\n         * A promise to get the native width of the video.\n         *\n         * @promise GetVideoWidthPromise\n         * @fulfill {number} The native width of the video.\n         */\n        /**\n         * Get the native width of the currently‐playing video. The width of\n         * the highest‐resolution available will be used before playback begins.\n         *\n         * @author Brad Dougherty <brad@vimeo.com>\n         * @return {GetVideoWidthPromise}\n         */\n\n    }, {\n        key: 'getVideoWidth',\n        value: function getVideoWidth() {\n            return this.get('videoWidth');\n        }\n\n        /**\n         * A promise to get the native height of the video.\n         *\n         * @promise GetVideoHeightPromise\n         * @fulfill {number} The native height of the video.\n         */\n        /**\n         * Get the native height of the currently‐playing video. The height of\n         * the highest‐resolution available will be used before playback begins.\n         *\n         * @author Brad Dougherty <brad@vimeo.com>\n         * @return {GetVideoHeightPromise}\n         */\n\n    }, {\n        key: 'getVideoHeight',\n        value: function getVideoHeight() {\n            return this.get('videoHeight');\n        }\n\n        /**\n         * A promise to get the vimeo.com url for the video.\n         *\n         * @promise GetVideoUrlPromise\n         * @fulfill {number} The vimeo.com url for the video.\n         * @reject {PrivacyError} The url isn’t available because of the video’s privacy setting.\n         */\n        /**\n         * Get the vimeo.com url for the video.\n         *\n         * @author Brad Dougherty <brad@vimeo.com>\n         * @return {GetVideoUrlPromise}\n         */\n\n    }, {\n        key: 'getVideoUrl',\n        value: function getVideoUrl() {\n            return this.get('videoUrl');\n        }\n\n        /**\n         * A promise to get the volume level of the player.\n         *\n         * @promise GetVolumePromise\n         * @fulfill {number} The volume level of the player on a scale from 0 to 1.\n         */\n        /**\n         * Get the current volume level of the player on a scale from `0` to `1`.\n         *\n         * Most mobile devices do not support an independent volume from the\n         * system volume. In those cases, this method will always return `1`.\n         *\n         * @author Brad Dougherty <brad@vimeo.com>\n         * @return {GetVolumePromise}\n         */\n\n    }, {\n        key: 'getVolume',\n        value: function getVolume() {\n            return this.get('volume');\n        }\n\n        /**\n         * A promise to set the volume level of the player.\n         *\n         * @promise SetVolumePromise\n         * @fulfill {number} The volume was set.\n         * @reject {RangeError} The volume was less than 0 or greater than 1.\n         */\n        /**\n         * Set the volume of the player on a scale from `0` to `1`. When set\n         * via the API, the volume level will not be synchronized to other\n         * players or stored as the viewer’s preference.\n         *\n         * Most mobile devices do not support setting the volume. An error will\n         * *not* be triggered in that situation.\n         *\n         * @author Brad Dougherty <brad@vimeo.com>\n         * @param {number} volume\n         * @return {SetVolumePromise}\n         */\n\n    }, {\n        key: 'setVolume',\n        value: function setVolume(volume) {\n            return this.set('volume', volume);\n        }\n    }]);\n\n    return Player;\n}();\n\ninitializeEmbeds();\n\nreturn Player;\n\n})));\n\n//# sourceMappingURL=player.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@vimeo/player/dist/player.js\n// module id = 6\n// module chunks = 0","// removed by extract-text-webpack-plugin\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./home/static/home/css/paraxify.css\n// module id = 7\n// module chunks = 0","// removed by extract-text-webpack-plugin\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./home/static/home/styl/home.styl\n// module id = 8\n// module chunks = 0","// removed by extract-text-webpack-plugin\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/normalize.css/normalize.css\n// module id = 9\n// module chunks = 0","require(\"./dist/inputmask/inputmask.date.extensions\");\r\nrequire(\"./dist/inputmask/inputmask.extensions\");\r\nrequire(\"./dist/inputmask/inputmask.numeric.extensions\");\r\nrequire(\"./dist/inputmask/inputmask.phone.extensions\");\r\n\r\n// require(\"./dist/inputmask/phone-codes/phone-be\");\r\n// require(\"./dist/inputmask/phone-codes/phone-nl\");\r\n// require(\"./dist/inputmask/phone-codes/phone-ru\");\r\n// require(\"./dist/inputmask/phone-codes/phone-uk\");\r\n// require(\"./dist/inputmask/phone-codes/phone\");\r\n\r\nmodule.exports = require(\"./dist/inputmask/inputmask.js\");\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/inputmask/index.js\n// module id = 10\n// module chunks = 0","(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.shuffle = factory());\n}(this, (function () { 'use strict';\n\n// Polyfill for creating CustomEvents on IE9/10/11\n\n// code pulled from:\n// https://github.com/d4tocchini/customevent-polyfill\n// https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent#Polyfill\n\ntry {\n    var ce = new window.CustomEvent('test');\n    ce.preventDefault();\n    if (ce.defaultPrevented !== true) {\n        // IE has problems with .preventDefault() on custom events\n        // http://stackoverflow.com/questions/23349191\n        throw new Error('Could not prevent default');\n    }\n} catch(e) {\n  var CustomEvent$1 = function(event, params) {\n    var evt, origPrevent;\n    params = params || {\n      bubbles: false,\n      cancelable: false,\n      detail: undefined\n    };\n\n    evt = document.createEvent(\"CustomEvent\");\n    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n    origPrevent = evt.preventDefault;\n    evt.preventDefault = function () {\n      origPrevent.call(this);\n      try {\n        Object.defineProperty(this, 'defaultPrevented', {\n          get: function () {\n            return true;\n          }\n        });\n      } catch(e) {\n        this.defaultPrevented = true;\n      }\n    };\n    return evt;\n  };\n\n  CustomEvent$1.prototype = window.Event.prototype;\n  window.CustomEvent = CustomEvent$1; // expose definition to window\n}\n\nvar proto = Element.prototype;\nvar vendor = proto.matches\n  || proto.matchesSelector\n  || proto.webkitMatchesSelector\n  || proto.mozMatchesSelector\n  || proto.msMatchesSelector\n  || proto.oMatchesSelector;\n\nvar index = match;\n\n/**\n * Match `el` to `selector`.\n *\n * @param {Element} el\n * @param {String} selector\n * @return {Boolean}\n * @api public\n */\n\nfunction match(el, selector) {\n  if (vendor) return vendor.call(el, selector);\n  var nodes = el.parentNode.querySelectorAll(selector);\n  for (var i = 0; i < nodes.length; i++) {\n    if (nodes[i] == el) return true;\n  }\n  return false;\n}\n\nvar commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n\n\n\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nvar index$1 = createCommonjsModule(function (module) {\n'use strict';\n\n// there's 3 implementations written in increasing order of efficiency\n\n// 1 - no Set type is defined\nfunction uniqNoSet(arr) {\n\tvar ret = [];\n\n\tfor (var i = 0; i < arr.length; i++) {\n\t\tif (ret.indexOf(arr[i]) === -1) {\n\t\t\tret.push(arr[i]);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n// 2 - a simple Set type is defined\nfunction uniqSet(arr) {\n\tvar seen = new Set();\n\treturn arr.filter(function (el) {\n\t\tif (!seen.has(el)) {\n\t\t\tseen.add(el);\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t});\n}\n\n// 3 - a standard Set type is defined and it has a forEach method\nfunction uniqSetWithForEach(arr) {\n\tvar ret = [];\n\n\t(new Set(arr)).forEach(function (el) {\n\t\tret.push(el);\n\t});\n\n\treturn ret;\n}\n\n// V8 currently has a broken implementation\n// https://github.com/joyent/node/issues/8449\nfunction doesForEachActuallyWork() {\n\tvar ret = false;\n\n\t(new Set([true])).forEach(function (el) {\n\t\tret = el;\n\t});\n\n\treturn ret === true;\n}\n\nif ('Set' in commonjsGlobal) {\n\tif (typeof Set.prototype.forEach === 'function' && doesForEachActuallyWork()) {\n\t\tmodule.exports = uniqSetWithForEach;\n\t} else {\n\t\tmodule.exports = uniqSet;\n\t}\n} else {\n\tmodule.exports = uniqNoSet;\n}\n});\n\nvar immutable = extend;\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction extend() {\n    var target = {};\n\n    for (var i = 0; i < arguments.length; i++) {\n        var source = arguments[i];\n\n        for (var key in source) {\n            if (hasOwnProperty.call(source, key)) {\n                target[key] = source[key];\n            }\n        }\n    }\n\n    return target\n}\n\nvar index$2 = throttle;\n\n/**\n * Returns a new function that, when invoked, invokes `func` at most once per `wait` milliseconds.\n *\n * @param {Function} func Function to wrap.\n * @param {Number} wait Number of milliseconds that must elapse between `func` invocations.\n * @return {Function} A new function that wraps the `func` function passed in.\n */\n\nfunction throttle (func, wait) {\n  var ctx, args, rtn, timeoutID; // caching\n  var last = 0;\n\n  return function throttled () {\n    ctx = this;\n    args = arguments;\n    var delta = new Date() - last;\n    if (!timeoutID)\n      if (delta >= wait) call();\n      else timeoutID = setTimeout(call, wait - delta);\n    return rtn;\n  };\n\n  function call () {\n    timeoutID = 0;\n    last = +new Date();\n    rtn = func.apply(ctx, args);\n    ctx = null;\n    args = null;\n  }\n}\n\nvar index$3 = function parallel(fns, context, callback) {\n  if (!callback) {\n    if (typeof context === 'function') {\n      callback = context;\n      context = null;\n    } else {\n      callback = noop;\n    }\n  }\n\n  var pending = fns && fns.length;\n  if (!pending) return callback(null, []);\n\n  var finished = false;\n  var results = new Array(pending);\n\n  fns.forEach(context ? function (fn, i) {\n    fn.call(context, maybeDone(i));\n  } : function (fn, i) {\n    fn(maybeDone(i));\n  });\n\n  function maybeDone(i) {\n    return function (err, result) {\n      if (finished) return;\n\n      if (err) {\n        callback(err, results);\n        finished = true;\n        return\n      }\n\n      results[i] = result;\n\n      if (!--pending) callback(null, results);\n    }\n  }\n};\n\nfunction noop() {}\n\n/**\n * Always returns a numeric value, given a value. Logic from jQuery's `isNumeric`.\n * @param {*} value Possibly numeric value.\n * @return {number} `value` or zero if `value` isn't numeric.\n */\nfunction getNumber(value) {\n  return parseFloat(value) || 0;\n}\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar Point = function () {\n\n  /**\n   * Represents a coordinate pair.\n   * @param {number} [x=0] X.\n   * @param {number} [y=0] Y.\n   */\n  function Point(x, y) {\n    classCallCheck(this, Point);\n\n    this.x = getNumber(x);\n    this.y = getNumber(y);\n  }\n\n  /**\n   * Whether two points are equal.\n   * @param {Point} a Point A.\n   * @param {Point} b Point B.\n   * @return {boolean}\n   */\n\n\n  createClass(Point, null, [{\n    key: 'equals',\n    value: function equals(a, b) {\n      return a.x === b.x && a.y === b.y;\n    }\n  }]);\n  return Point;\n}();\n\nvar Classes = {\n  BASE: 'shuffle',\n  SHUFFLE_ITEM: 'shuffle-item',\n  VISIBLE: 'shuffle-item--visible',\n  HIDDEN: 'shuffle-item--hidden'\n};\n\nvar id$1 = 0;\n\nvar ShuffleItem = function () {\n  function ShuffleItem(element) {\n    classCallCheck(this, ShuffleItem);\n\n    id$1 += 1;\n    this.id = id$1;\n    this.element = element;\n    this.isVisible = true;\n  }\n\n  createClass(ShuffleItem, [{\n    key: 'show',\n    value: function show() {\n      this.isVisible = true;\n      this.element.classList.remove(Classes.HIDDEN);\n      this.element.classList.add(Classes.VISIBLE);\n    }\n  }, {\n    key: 'hide',\n    value: function hide() {\n      this.isVisible = false;\n      this.element.classList.remove(Classes.VISIBLE);\n      this.element.classList.add(Classes.HIDDEN);\n    }\n  }, {\n    key: 'init',\n    value: function init() {\n      this.addClasses([Classes.SHUFFLE_ITEM, Classes.VISIBLE]);\n      this.applyCss(ShuffleItem.Css.INITIAL);\n      this.scale = ShuffleItem.Scale.VISIBLE;\n      this.point = new Point();\n    }\n  }, {\n    key: 'addClasses',\n    value: function addClasses(classes) {\n      var _this = this;\n\n      classes.forEach(function (className) {\n        _this.element.classList.add(className);\n      });\n    }\n  }, {\n    key: 'removeClasses',\n    value: function removeClasses(classes) {\n      var _this2 = this;\n\n      classes.forEach(function (className) {\n        _this2.element.classList.remove(className);\n      });\n    }\n  }, {\n    key: 'applyCss',\n    value: function applyCss(obj) {\n      var _this3 = this;\n\n      Object.keys(obj).forEach(function (key) {\n        _this3.element.style[key] = obj[key];\n      });\n    }\n  }, {\n    key: 'dispose',\n    value: function dispose() {\n      this.removeClasses([Classes.HIDDEN, Classes.VISIBLE, Classes.SHUFFLE_ITEM]);\n\n      this.element.removeAttribute('style');\n      this.element = null;\n    }\n  }]);\n  return ShuffleItem;\n}();\n\nShuffleItem.Css = {\n  INITIAL: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    visibility: 'visible',\n    'will-change': 'transform'\n  },\n  VISIBLE: {\n    before: {\n      opacity: 1,\n      visibility: 'visible'\n    },\n    after: {}\n  },\n  HIDDEN: {\n    before: {\n      opacity: 0\n    },\n    after: {\n      visibility: 'hidden'\n    }\n  }\n};\n\nShuffleItem.Scale = {\n  VISIBLE: 1,\n  HIDDEN: 0.001\n};\n\nvar element = document.body || document.documentElement;\nvar e$1 = document.createElement('div');\ne$1.style.cssText = 'width:10px;padding:2px;box-sizing:border-box;';\nelement.appendChild(e$1);\n\nvar width = window.getComputedStyle(e$1, null).width;\nvar ret = width === '10px';\n\nelement.removeChild(e$1);\n\n/**\n * Retrieve the computed style for an element, parsed as a float.\n * @param {Element} element Element to get style for.\n * @param {string} style Style property.\n * @param {CSSStyleDeclaration} [styles] Optionally include clean styles to\n *     use instead of asking for them again.\n * @return {number} The parsed computed value or zero if that fails because IE\n *     will return 'auto' when the element doesn't have margins instead of\n *     the computed style.\n */\nfunction getNumberStyle(element, style) {\n  var styles = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : window.getComputedStyle(element, null);\n\n  var value = getNumber(styles[style]);\n\n  // Support IE<=11 and W3C spec.\n  if (!ret && style === 'width') {\n    value += getNumber(styles.paddingLeft) + getNumber(styles.paddingRight) + getNumber(styles.borderLeftWidth) + getNumber(styles.borderRightWidth);\n  } else if (!ret && style === 'height') {\n    value += getNumber(styles.paddingTop) + getNumber(styles.paddingBottom) + getNumber(styles.borderTopWidth) + getNumber(styles.borderBottomWidth);\n  }\n\n  return value;\n}\n\n/**\n * Fisher-Yates shuffle.\n * http://stackoverflow.com/a/962890/373422\n * https://bost.ocks.org/mike/shuffle/\n * @param {Array} array Array to shuffle.\n * @return {Array} Randomly sorted array.\n */\nfunction randomize(array) {\n  var n = array.length;\n\n  while (n) {\n    n -= 1;\n    var i = Math.floor(Math.random() * (n + 1));\n    var temp = array[i];\n    array[i] = array[n];\n    array[n] = temp;\n  }\n\n  return array;\n}\n\nvar defaults$1 = {\n  // Use array.reverse() to reverse the results\n  reverse: false,\n\n  // Sorting function\n  by: null,\n\n  // If true, this will skip the sorting and return a randomized order in the array\n  randomize: false,\n\n  // Determines which property of each item in the array is passed to the\n  // sorting method.\n  key: 'element'\n};\n\n// You can return `undefined` from the `by` function to revert to DOM order.\nfunction sorter(arr, options) {\n  var opts = immutable(defaults$1, options);\n  var original = [].slice.call(arr);\n  var revert = false;\n\n  if (!arr.length) {\n    return [];\n  }\n\n  if (opts.randomize) {\n    return randomize(arr);\n  }\n\n  // Sort the elements by the opts.by function.\n  // If we don't have opts.by, default to DOM order\n  if (typeof opts.by === 'function') {\n    arr.sort(function (a, b) {\n      // Exit early if we already know we want to revert\n      if (revert) {\n        return 0;\n      }\n\n      var valA = opts.by(a[opts.key]);\n      var valB = opts.by(b[opts.key]);\n\n      // If both values are undefined, use the DOM order\n      if (valA === undefined && valB === undefined) {\n        revert = true;\n        return 0;\n      }\n\n      if (valA < valB || valA === 'sortFirst' || valB === 'sortLast') {\n        return -1;\n      }\n\n      if (valA > valB || valA === 'sortLast' || valB === 'sortFirst') {\n        return 1;\n      }\n\n      return 0;\n    });\n  }\n\n  // Revert to the original array if necessary\n  if (revert) {\n    return original;\n  }\n\n  if (opts.reverse) {\n    arr.reverse();\n  }\n\n  return arr;\n}\n\nvar transitions = {};\nvar eventName = 'transitionend';\nvar count = 0;\n\nfunction uniqueId() {\n  count += 1;\n  return eventName + count;\n}\n\nfunction cancelTransitionEnd(id) {\n  if (transitions[id]) {\n    transitions[id].element.removeEventListener(eventName, transitions[id].listener);\n    transitions[id] = null;\n    return true;\n  }\n\n  return false;\n}\n\nfunction onTransitionEnd(element, callback) {\n  var id = uniqueId();\n  var listener = function listener(evt) {\n    if (evt.currentTarget === evt.target) {\n      cancelTransitionEnd(id);\n      callback(evt);\n    }\n  };\n\n  element.addEventListener(eventName, listener);\n\n  transitions[id] = { element: element, listener: listener };\n\n  return id;\n}\n\nfunction arrayMax(array) {\n  return Math.max.apply(Math, array); // eslint-disable-line prefer-spread\n}\n\nfunction arrayMin(array) {\n  return Math.min.apply(Math, array); // eslint-disable-line prefer-spread\n}\n\n/**\n * Determine the number of columns an items spans.\n * @param {number} itemWidth Width of the item.\n * @param {number} columnWidth Width of the column (includes gutter).\n * @param {number} columns Total number of columns\n * @param {number} threshold A buffer value for the size of the column to fit.\n * @return {number}\n */\nfunction getColumnSpan(itemWidth, columnWidth, columns, threshold) {\n  var columnSpan = itemWidth / columnWidth;\n\n  // If the difference between the rounded column span number and the\n  // calculated column span number is really small, round the number to\n  // make it fit.\n  if (Math.abs(Math.round(columnSpan) - columnSpan) < threshold) {\n    // e.g. columnSpan = 4.0089945390298745\n    columnSpan = Math.round(columnSpan);\n  }\n\n  // Ensure the column span is not more than the amount of columns in the whole layout.\n  return Math.min(Math.ceil(columnSpan), columns);\n}\n\n/**\n * Retrieves the column set to use for placement.\n * @param {number} columnSpan The number of columns this current item spans.\n * @param {number} columns The total columns in the grid.\n * @return {Array.<number>} An array of numbers represeting the column set.\n */\nfunction getAvailablePositions(positions, columnSpan, columns) {\n  // The item spans only one column.\n  if (columnSpan === 1) {\n    return positions;\n  }\n\n  // The item spans more than one column, figure out how many different\n  // places it could fit horizontally.\n  // The group count is the number of places within the positions this block\n  // could fit, ignoring the current positions of items.\n  // Imagine a 2 column brick as the second item in a 4 column grid with\n  // 10px height each. Find the places it would fit:\n  // [20, 10, 10, 0]\n  //  |   |   |\n  //  *   *   *\n  //\n  // Then take the places which fit and get the bigger of the two:\n  // max([20, 10]), max([10, 10]), max([10, 0]) = [20, 10, 0]\n  //\n  // Next, find the first smallest number (the short column).\n  // [20, 10, 0]\n  //          |\n  //          *\n  //\n  // And that's where it should be placed!\n  //\n  // Another example where the second column's item extends past the first:\n  // [10, 20, 10, 0] => [20, 20, 10] => 10\n  var available = [];\n\n  // For how many possible positions for this item there are.\n  for (var i = 0; i <= columns - columnSpan; i++) {\n    // Find the bigger value for each place it could fit.\n    available.push(arrayMax(positions.slice(i, i + columnSpan)));\n  }\n\n  return available;\n}\n\n/**\n * Find index of short column, the first from the left where this item will go.\n *\n * @param {Array.<number>} positions The array to search for the smallest number.\n * @param {number} buffer Optional buffer which is very useful when the height\n *     is a percentage of the width.\n * @return {number} Index of the short column.\n */\nfunction getShortColumn(positions, buffer) {\n  var minPosition = arrayMin(positions);\n  for (var i = 0, len = positions.length; i < len; i++) {\n    if (positions[i] >= minPosition - buffer && positions[i] <= minPosition + buffer) {\n      return i;\n    }\n  }\n\n  return 0;\n}\n\n/**\n * Determine the location of the next item, based on its size.\n * @param {Object} itemSize Object with width and height.\n * @param {Array.<number>} positions Positions of the other current items.\n * @param {number} gridSize The column width or row height.\n * @param {number} total The total number of columns or rows.\n * @param {number} threshold Buffer value for the column to fit.\n * @param {number} buffer Vertical buffer for the height of items.\n * @return {Point}\n */\nfunction getItemPosition(_ref) {\n  var itemSize = _ref.itemSize,\n      positions = _ref.positions,\n      gridSize = _ref.gridSize,\n      total = _ref.total,\n      threshold = _ref.threshold,\n      buffer = _ref.buffer;\n\n  var span = getColumnSpan(itemSize.width, gridSize, total, threshold);\n  var setY = getAvailablePositions(positions, span, total);\n  var shortColumnIndex = getShortColumn(setY, buffer);\n\n  // Position the item\n  var point = new Point(Math.round(gridSize * shortColumnIndex), Math.round(setY[shortColumnIndex]));\n\n  // Update the columns array with the new values for each column.\n  // e.g. before the update the columns could be [250, 0, 0, 0] for an item\n  // which spans 2 columns. After it would be [250, itemHeight, itemHeight, 0].\n  var setHeight = setY[shortColumnIndex] + itemSize.height;\n  for (var i = 0; i < span; i++) {\n    positions[shortColumnIndex + i] = setHeight;\n  }\n\n  return point;\n}\n\nfunction toArray$$1(arrayLike) {\n  return Array.prototype.slice.call(arrayLike);\n}\n\nfunction arrayIncludes(array, obj) {\n  return array.indexOf(obj) > -1;\n}\n\n// Used for unique instance variables\nvar id = 0;\n\nvar Shuffle = function () {\n\n  /**\n   * Categorize, sort, and filter a responsive grid of items.\n   *\n   * @param {Element} element An element which is the parent container for the grid items.\n   * @param {Object} [options=Shuffle.options] Options object.\n   * @constructor\n   */\n  function Shuffle(element) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    classCallCheck(this, Shuffle);\n\n    this.options = immutable(Shuffle.options, options);\n\n    this.useSizer = false;\n    this.lastSort = {};\n    this.group = Shuffle.ALL_ITEMS;\n    this.lastFilter = Shuffle.ALL_ITEMS;\n    this.isEnabled = true;\n    this.isDestroyed = false;\n    this.isInitialized = false;\n    this._transitions = [];\n    this.isTransitioning = false;\n    this._queue = [];\n\n    var el = this._getElementOption(element);\n\n    if (!el) {\n      throw new TypeError('Shuffle needs to be initialized with an element.');\n    }\n\n    this.element = el;\n    this.id = 'shuffle_' + id;\n    id += 1;\n\n    this._init();\n    this.isInitialized = true;\n  }\n\n  createClass(Shuffle, [{\n    key: '_init',\n    value: function _init() {\n      this.items = this._getItems();\n\n      this.options.sizer = this._getElementOption(this.options.sizer);\n\n      if (this.options.sizer) {\n        this.useSizer = true;\n      }\n\n      // Add class and invalidate styles\n      this.element.classList.add(Shuffle.Classes.BASE);\n\n      // Set initial css for each item\n      this._initItems();\n\n      // Bind resize events\n      this._onResize = this._getResizeFunction();\n      window.addEventListener('resize', this._onResize);\n\n      // Get container css all in one request. Causes reflow\n      var containerCss = window.getComputedStyle(this.element, null);\n      var containerWidth = Shuffle.getSize(this.element).width;\n\n      // Add styles to the container if it doesn't have them.\n      this._validateStyles(containerCss);\n\n      // We already got the container's width above, no need to cause another\n      // reflow getting it again... Calculate the number of columns there will be\n      this._setColumns(containerWidth);\n\n      // Kick off!\n      this.filter(this.options.group, this.options.initialSort);\n\n      // The shuffle items haven't had transitions set on them yet so the user\n      // doesn't see the first layout. Set them now that the first layout is done.\n      // First, however, a synchronous layout must be caused for the previous\n      // styles to be applied without transitions.\n      this.element.offsetWidth; // eslint-disable-line no-unused-expressions\n      this._setTransitions();\n      this.element.style.transition = 'height ' + this.options.speed + 'ms ' + this.options.easing;\n    }\n\n    /**\n     * Returns a throttled and proxied function for the resize handler.\n     * @return {Function}\n     * @private\n     */\n\n  }, {\n    key: '_getResizeFunction',\n    value: function _getResizeFunction() {\n      var resizeFunction = this._handleResize.bind(this);\n      return this.options.throttle ? this.options.throttle(resizeFunction, this.options.throttleTime) : resizeFunction;\n    }\n\n    /**\n     * Retrieve an element from an option.\n     * @param {string|jQuery|Element} option The option to check.\n     * @return {?Element} The plain element or null.\n     * @private\n     */\n\n  }, {\n    key: '_getElementOption',\n    value: function _getElementOption(option) {\n      // If column width is a string, treat is as a selector and search for the\n      // sizer element within the outermost container\n      if (typeof option === 'string') {\n        return this.element.querySelector(option);\n\n        // Check for an element\n      } else if (option && option.nodeType && option.nodeType === 1) {\n        return option;\n\n        // Check for jQuery object\n      } else if (option && option.jquery) {\n        return option[0];\n      }\n\n      return null;\n    }\n\n    /**\n     * Ensures the shuffle container has the css styles it needs applied to it.\n     * @param {Object} styles Key value pairs for position and overflow.\n     * @private\n     */\n\n  }, {\n    key: '_validateStyles',\n    value: function _validateStyles(styles) {\n      // Position cannot be static.\n      if (styles.position === 'static') {\n        this.element.style.position = 'relative';\n      }\n\n      // Overflow has to be hidden.\n      if (styles.overflow !== 'hidden') {\n        this.element.style.overflow = 'hidden';\n      }\n    }\n\n    /**\n     * Filter the elements by a category.\n     * @param {string} [category] Category to filter by. If it's given, the last\n     *     category will be used to filter the items.\n     * @param {Array} [collection] Optionally filter a collection. Defaults to\n     *     all the items.\n     * @return {!{visible: Array, hidden: Array}}\n     * @private\n     */\n\n  }, {\n    key: '_filter',\n    value: function _filter() {\n      var category = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.lastFilter;\n      var collection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.items;\n\n      var set$$1 = this._getFilteredSets(category, collection);\n\n      // Individually add/remove hidden/visible classes\n      this._toggleFilterClasses(set$$1);\n\n      // Save the last filter in case elements are appended.\n      this.lastFilter = category;\n\n      // This is saved mainly because providing a filter function (like searching)\n      // will overwrite the `lastFilter` property every time its called.\n      if (typeof category === 'string') {\n        this.group = category;\n      }\n\n      return set$$1;\n    }\n\n    /**\n     * Returns an object containing the visible and hidden elements.\n     * @param {string|Function} category Category or function to filter by.\n     * @param {Array.<Element>} items A collection of items to filter.\n     * @return {!{visible: Array, hidden: Array}}\n     * @private\n     */\n\n  }, {\n    key: '_getFilteredSets',\n    value: function _getFilteredSets(category, items) {\n      var _this = this;\n\n      var visible = [];\n      var hidden = [];\n\n      // category === 'all', add visible class to everything\n      if (category === Shuffle.ALL_ITEMS) {\n        visible = items;\n\n        // Loop through each item and use provided function to determine\n        // whether to hide it or not.\n      } else {\n        items.forEach(function (item) {\n          if (_this._doesPassFilter(category, item.element)) {\n            visible.push(item);\n          } else {\n            hidden.push(item);\n          }\n        });\n      }\n\n      return {\n        visible: visible,\n        hidden: hidden\n      };\n    }\n\n    /**\n     * Test an item to see if it passes a category.\n     * @param {string|Function} category Category or function to filter by.\n     * @param {Element} element An element to test.\n     * @return {boolean} Whether it passes the category/filter.\n     * @private\n     */\n\n  }, {\n    key: '_doesPassFilter',\n    value: function _doesPassFilter(category, element) {\n      if (typeof category === 'function') {\n        return category.call(element, element, this);\n      }\n\n      // Check each element's data-groups attribute against the given category.\n      var attr = element.getAttribute('data-' + Shuffle.FILTER_ATTRIBUTE_KEY);\n      var keys = this.options.delimeter ? attr.split(this.options.delimeter) : JSON.parse(attr);\n\n      function testCategory(category) {\n        return arrayIncludes(keys, category);\n      }\n\n      if (Array.isArray(category)) {\n        if (this.options.filterMode === Shuffle.FilterMode.ANY) {\n          return category.some(testCategory);\n        }\n        return category.every(testCategory);\n      }\n\n      return arrayIncludes(keys, category);\n    }\n\n    /**\n     * Toggles the visible and hidden class names.\n     * @param {{visible, hidden}} Object with visible and hidden arrays.\n     * @private\n     */\n\n  }, {\n    key: '_toggleFilterClasses',\n    value: function _toggleFilterClasses(_ref) {\n      var visible = _ref.visible,\n          hidden = _ref.hidden;\n\n      visible.forEach(function (item) {\n        item.show();\n      });\n\n      hidden.forEach(function (item) {\n        item.hide();\n      });\n    }\n\n    /**\n     * Set the initial css for each item\n     * @param {Array.<ShuffleItem>} [items] Optionally specifiy at set to initialize.\n     * @private\n     */\n\n  }, {\n    key: '_initItems',\n    value: function _initItems() {\n      var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.items;\n\n      items.forEach(function (item) {\n        item.init();\n      });\n    }\n\n    /**\n     * Remove element reference and styles.\n     * @private\n     */\n\n  }, {\n    key: '_disposeItems',\n    value: function _disposeItems() {\n      var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.items;\n\n      items.forEach(function (item) {\n        item.dispose();\n      });\n    }\n\n    /**\n     * Updates the visible item count.\n     * @private\n     */\n\n  }, {\n    key: '_updateItemCount',\n    value: function _updateItemCount() {\n      this.visibleItems = this._getFilteredItems().length;\n    }\n\n    /**\n     * Sets css transform transition on a group of elements. This is not executed\n     * at the same time as `item.init` so that transitions don't occur upon\n     * initialization of Shuffle.\n     * @param {Array.<ShuffleItem>} items Shuffle items to set transitions on.\n     * @private\n     */\n\n  }, {\n    key: '_setTransitions',\n    value: function _setTransitions() {\n      var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.items;\n\n      var speed = this.options.speed;\n      var easing = this.options.easing;\n\n      var str = this.options.useTransforms ? 'transform ' + speed + 'ms ' + easing + ', opacity ' + speed + 'ms ' + easing : 'top ' + speed + 'ms ' + easing + ', left ' + speed + 'ms ' + easing + ', opacity ' + speed + 'ms ' + easing;\n\n      items.forEach(function (item) {\n        item.element.style.transition = str;\n      });\n    }\n  }, {\n    key: '_getItems',\n    value: function _getItems() {\n      var _this2 = this;\n\n      return toArray$$1(this.element.children).filter(function (el) {\n        return index(el, _this2.options.itemSelector);\n      }).map(function (el) {\n        return new ShuffleItem(el);\n      });\n    }\n\n    /**\n     * When new elements are added to the shuffle container, update the array of\n     * items because that is the order `_layout` calls them.\n     */\n\n  }, {\n    key: '_updateItemsOrder',\n    value: function _updateItemsOrder() {\n      var children = this.element.children;\n      this.items = sorter(this.items, {\n        by: function by(element) {\n          return Array.prototype.indexOf.call(children, element);\n        }\n      });\n    }\n  }, {\n    key: '_getFilteredItems',\n    value: function _getFilteredItems() {\n      return this.items.filter(function (item) {\n        return item.isVisible;\n      });\n    }\n  }, {\n    key: '_getConcealedItems',\n    value: function _getConcealedItems() {\n      return this.items.filter(function (item) {\n        return !item.isVisible;\n      });\n    }\n\n    /**\n     * Returns the column size, based on column width and sizer options.\n     * @param {number} containerWidth Size of the parent container.\n     * @param {number} gutterSize Size of the gutters.\n     * @return {number}\n     * @private\n     */\n\n  }, {\n    key: '_getColumnSize',\n    value: function _getColumnSize(containerWidth, gutterSize) {\n      var size = void 0;\n\n      // If the columnWidth property is a function, then the grid is fluid\n      if (typeof this.options.columnWidth === 'function') {\n        size = this.options.columnWidth(containerWidth);\n\n        // columnWidth option isn't a function, are they using a sizing element?\n      } else if (this.useSizer) {\n        size = Shuffle.getSize(this.options.sizer).width;\n\n        // if not, how about the explicitly set option?\n      } else if (this.options.columnWidth) {\n        size = this.options.columnWidth;\n\n        // or use the size of the first item\n      } else if (this.items.length > 0) {\n        size = Shuffle.getSize(this.items[0].element, true).width;\n\n        // if there's no items, use size of container\n      } else {\n        size = containerWidth;\n      }\n\n      // Don't let them set a column width of zero.\n      if (size === 0) {\n        size = containerWidth;\n      }\n\n      return size + gutterSize;\n    }\n\n    /**\n     * Returns the gutter size, based on gutter width and sizer options.\n     * @param {number} containerWidth Size of the parent container.\n     * @return {number}\n     * @private\n     */\n\n  }, {\n    key: '_getGutterSize',\n    value: function _getGutterSize(containerWidth) {\n      var size = void 0;\n      if (typeof this.options.gutterWidth === 'function') {\n        size = this.options.gutterWidth(containerWidth);\n      } else if (this.useSizer) {\n        size = getNumberStyle(this.options.sizer, 'marginLeft');\n      } else {\n        size = this.options.gutterWidth;\n      }\n\n      return size;\n    }\n\n    /**\n     * Calculate the number of columns to be used. Gets css if using sizer element.\n     * @param {number} [containerWidth] Optionally specify a container width if\n     *    it's already available.\n     */\n\n  }, {\n    key: '_setColumns',\n    value: function _setColumns() {\n      var containerWidth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Shuffle.getSize(this.element).width;\n\n      var gutter = this._getGutterSize(containerWidth);\n      var columnWidth = this._getColumnSize(containerWidth, gutter);\n      var calculatedColumns = (containerWidth + gutter) / columnWidth;\n\n      // Widths given from getStyles are not precise enough...\n      if (Math.abs(Math.round(calculatedColumns) - calculatedColumns) < this.options.columnThreshold) {\n        // e.g. calculatedColumns = 11.998876\n        calculatedColumns = Math.round(calculatedColumns);\n      }\n\n      this.cols = Math.max(Math.floor(calculatedColumns), 1);\n      this.containerWidth = containerWidth;\n      this.colWidth = columnWidth;\n    }\n\n    /**\n     * Adjust the height of the grid\n     */\n\n  }, {\n    key: '_setContainerSize',\n    value: function _setContainerSize() {\n      this.element.style.height = this._getContainerSize() + 'px';\n    }\n\n    /**\n     * Based on the column heights, it returns the biggest one.\n     * @return {number}\n     * @private\n     */\n\n  }, {\n    key: '_getContainerSize',\n    value: function _getContainerSize() {\n      return arrayMax(this.positions);\n    }\n\n    /**\n     * Get the clamped stagger amount.\n     * @param {number} index Index of the item to be staggered.\n     * @return {number}\n     */\n\n  }, {\n    key: '_getStaggerAmount',\n    value: function _getStaggerAmount(index$$1) {\n      return Math.min(index$$1 * this.options.staggerAmount, this.options.staggerAmountMax);\n    }\n\n    /**\n     * @return {boolean} Whether the event was prevented or not.\n     */\n\n  }, {\n    key: '_dispatch',\n    value: function _dispatch(name) {\n      var details = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (this.isDestroyed) {\n        return false;\n      }\n\n      details.shuffle = this;\n      return !this.element.dispatchEvent(new CustomEvent(name, {\n        bubbles: true,\n        cancelable: false,\n        detail: details\n      }));\n    }\n\n    /**\n     * Zeros out the y columns array, which is used to determine item placement.\n     * @private\n     */\n\n  }, {\n    key: '_resetCols',\n    value: function _resetCols() {\n      var i = this.cols;\n      this.positions = [];\n      while (i) {\n        i -= 1;\n        this.positions.push(0);\n      }\n    }\n\n    /**\n     * Loops through each item that should be shown and calculates the x, y position.\n     * @param {Array.<ShuffleItem>} items Array of items that will be shown/layed\n     *     out in order in their array.\n     */\n\n  }, {\n    key: '_layout',\n    value: function _layout(items) {\n      var _this3 = this;\n\n      var count = 0;\n      items.forEach(function (item) {\n        var currPos = item.point;\n        var currScale = item.scale;\n        var itemSize = Shuffle.getSize(item.element, true);\n        var pos = _this3._getItemPosition(itemSize);\n\n        function callback() {\n          item.element.style.transitionDelay = '';\n          item.applyCss(ShuffleItem.Css.VISIBLE.after);\n        }\n\n        // If the item will not change its position, do not add it to the render\n        // queue. Transitions don't fire when setting a property to the same value.\n        if (Point.equals(currPos, pos) && currScale === ShuffleItem.Scale.VISIBLE) {\n          item.applyCss(ShuffleItem.Css.VISIBLE.before);\n          callback();\n          return;\n        }\n\n        item.point = pos;\n        item.scale = ShuffleItem.Scale.VISIBLE;\n\n        // Use xtend here to clone the object so that the `before` object isn't\n        // modified when the transition delay is added.\n        var styles = immutable(ShuffleItem.Css.VISIBLE.before);\n        styles.transitionDelay = _this3._getStaggerAmount(count) + 'ms';\n\n        _this3._queue.push({\n          item: item,\n          styles: styles,\n          callback: callback\n        });\n\n        count += 1;\n      });\n    }\n\n    /**\n     * Determine the location of the next item, based on its size.\n     * @param {{width: number, height: number}} itemSize Object with width and height.\n     * @return {Point}\n     * @private\n     */\n\n  }, {\n    key: '_getItemPosition',\n    value: function _getItemPosition(itemSize) {\n      return getItemPosition({\n        itemSize: itemSize,\n        positions: this.positions,\n        gridSize: this.colWidth,\n        total: this.cols,\n        threshold: this.options.columnThreshold,\n        buffer: this.options.buffer\n      });\n    }\n\n    /**\n     * Hides the elements that don't match our filter.\n     * @param {Array.<ShuffleItem>} collection Collection to shrink.\n     * @private\n     */\n\n  }, {\n    key: '_shrink',\n    value: function _shrink() {\n      var _this4 = this;\n\n      var collection = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._getConcealedItems();\n\n      var count = 0;\n      collection.forEach(function (item) {\n        function callback() {\n          item.applyCss(ShuffleItem.Css.HIDDEN.after);\n        }\n\n        // Continuing would add a transitionend event listener to the element, but\n        // that listener would not execute because the transform and opacity would\n        // stay the same.\n        // The callback is executed here because it is not guaranteed to be called\n        // after the transitionend event because the transitionend could be\n        // canceled if another animation starts.\n        if (item.scale === ShuffleItem.Scale.HIDDEN) {\n          item.applyCss(ShuffleItem.Css.HIDDEN.before);\n          callback();\n          return;\n        }\n\n        item.scale = ShuffleItem.Scale.HIDDEN;\n\n        var styles = immutable(ShuffleItem.Css.HIDDEN.before);\n        styles.transitionDelay = _this4._getStaggerAmount(count) + 'ms';\n\n        _this4._queue.push({\n          item: item,\n          styles: styles,\n          callback: callback\n        });\n\n        count += 1;\n      });\n    }\n\n    /**\n     * Resize handler.\n     * @private\n     */\n\n  }, {\n    key: '_handleResize',\n    value: function _handleResize() {\n      // If shuffle is disabled, destroyed, don't do anything\n      if (!this.isEnabled || this.isDestroyed) {\n        return;\n      }\n\n      // Will need to check height in the future if it's layed out horizontaly\n      var containerWidth = Shuffle.getSize(this.element).width;\n\n      // containerWidth hasn't changed, don't do anything\n      if (containerWidth === this.containerWidth) {\n        return;\n      }\n\n      this.update();\n    }\n\n    /**\n     * Returns styles which will be applied to the an item for a transition.\n     * @param {Object} obj Transition options.\n     * @return {!Object} Transforms for transitions, left/top for animate.\n     * @private\n     */\n\n  }, {\n    key: '_getStylesForTransition',\n    value: function _getStylesForTransition(_ref2) {\n      var item = _ref2.item,\n          styles = _ref2.styles;\n\n      if (!styles.transitionDelay) {\n        styles.transitionDelay = '0ms';\n      }\n\n      var x = item.point.x;\n      var y = item.point.y;\n\n      if (this.options.useTransforms) {\n        styles.transform = 'translate(' + x + 'px, ' + y + 'px) scale(' + item.scale + ')';\n      } else {\n        styles.left = x + 'px';\n        styles.top = y + 'px';\n      }\n\n      return styles;\n    }\n\n    /**\n     * Listen for the transition end on an element and execute the itemCallback\n     * when it finishes.\n     * @param {Element} element Element to listen on.\n     * @param {Function} itemCallback Callback for the item.\n     * @param {Function} done Callback to notify `parallel` that this one is done.\n     */\n\n  }, {\n    key: '_whenTransitionDone',\n    value: function _whenTransitionDone(element, itemCallback, done) {\n      var id = onTransitionEnd(element, function (evt) {\n        itemCallback();\n        done(null, evt);\n      });\n\n      this._transitions.push(id);\n    }\n\n    /**\n     * Return a function which will set CSS styles and call the `done` function\n     * when (if) the transition finishes.\n     * @param {Object} opts Transition object.\n     * @return {Function} A function to be called with a `done` function.\n     */\n\n  }, {\n    key: '_getTransitionFunction',\n    value: function _getTransitionFunction(opts) {\n      var _this5 = this;\n\n      return function (done) {\n        opts.item.applyCss(_this5._getStylesForTransition(opts));\n        _this5._whenTransitionDone(opts.item.element, opts.callback, done);\n      };\n    }\n\n    /**\n     * Execute the styles gathered in the style queue. This applies styles to elements,\n     * triggering transitions.\n     * @private\n     */\n\n  }, {\n    key: '_processQueue',\n    value: function _processQueue() {\n      if (this.isTransitioning) {\n        this._cancelMovement();\n      }\n\n      var hasSpeed = this.options.speed > 0;\n      var hasQueue = this._queue.length > 0;\n\n      if (hasQueue && hasSpeed && this.isInitialized) {\n        this._startTransitions(this._queue);\n      } else if (hasQueue) {\n        this._styleImmediately(this._queue);\n        this._dispatchLayout();\n\n        // A call to layout happened, but none of the newly visible items will\n        // change position or the transition duration is zero, which will not trigger\n        // the transitionend event.\n      } else {\n        this._dispatchLayout();\n      }\n\n      // Remove everything in the style queue\n      this._queue.length = 0;\n    }\n\n    /**\n     * Wait for each transition to finish, the emit the layout event.\n     * @param {Array.<Object>} transitions Array of transition objects.\n     */\n\n  }, {\n    key: '_startTransitions',\n    value: function _startTransitions(transitions) {\n      var _this6 = this;\n\n      // Set flag that shuffle is currently in motion.\n      this.isTransitioning = true;\n\n      // Create an array of functions to be called.\n      var callbacks = transitions.map(function (obj) {\n        return _this6._getTransitionFunction(obj);\n      });\n\n      index$3(callbacks, this._movementFinished.bind(this));\n    }\n  }, {\n    key: '_cancelMovement',\n    value: function _cancelMovement() {\n      // Remove the transition end event for each listener.\n      this._transitions.forEach(cancelTransitionEnd);\n\n      // Reset the array.\n      this._transitions.length = 0;\n\n      // Show it's no longer active.\n      this.isTransitioning = false;\n    }\n\n    /**\n     * Apply styles without a transition.\n     * @param {Array.<Object>} objects Array of transition objects.\n     * @private\n     */\n\n  }, {\n    key: '_styleImmediately',\n    value: function _styleImmediately(objects) {\n      var _this7 = this;\n\n      if (objects.length) {\n        var elements = objects.map(function (obj) {\n          return obj.item.element;\n        });\n\n        Shuffle._skipTransitions(elements, function () {\n          objects.forEach(function (obj) {\n            obj.item.applyCss(_this7._getStylesForTransition(obj));\n            obj.callback();\n          });\n        });\n      }\n    }\n  }, {\n    key: '_movementFinished',\n    value: function _movementFinished() {\n      this._transitions.length = 0;\n      this.isTransitioning = false;\n      this._dispatchLayout();\n    }\n  }, {\n    key: '_dispatchLayout',\n    value: function _dispatchLayout() {\n      this._dispatch(Shuffle.EventType.LAYOUT);\n    }\n\n    /**\n     * The magic. This is what makes the plugin 'shuffle'\n     * @param {string|Function|Array.<string>} [category] Category to filter by.\n     *     Can be a function, string, or array of strings.\n     * @param {Object} [sortObj] A sort object which can sort the visible set\n     */\n\n  }, {\n    key: 'filter',\n    value: function filter(category, sortObj) {\n      if (!this.isEnabled) {\n        return;\n      }\n\n      if (!category || category && category.length === 0) {\n        category = Shuffle.ALL_ITEMS; // eslint-disable-line no-param-reassign\n      }\n\n      this._filter(category);\n\n      // Shrink each hidden item\n      this._shrink();\n\n      // How many visible elements?\n      this._updateItemCount();\n\n      // Update transforms on visible elements so they will animate to their new positions.\n      this.sort(sortObj);\n    }\n\n    /**\n     * Gets the visible elements, sorts them, and passes them to layout.\n     * @param {Object} opts the options object for the sorted plugin\n     */\n\n  }, {\n    key: 'sort',\n    value: function sort() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.lastSort;\n\n      if (!this.isEnabled) {\n        return;\n      }\n\n      this._resetCols();\n\n      var items = this._getFilteredItems();\n      items = sorter(items, opts);\n\n      this._layout(items);\n\n      // `_layout` always happens after `_shrink`, so it's safe to process the style\n      // queue here with styles from the shrink method.\n      this._processQueue();\n\n      // Adjust the height of the container.\n      this._setContainerSize();\n\n      this.lastSort = opts;\n    }\n\n    /**\n     * Reposition everything.\n     * @param {boolean} isOnlyLayout If true, column and gutter widths won't be\n     *     recalculated.\n     */\n\n  }, {\n    key: 'update',\n    value: function update(isOnlyLayout) {\n      if (this.isEnabled) {\n        if (!isOnlyLayout) {\n          // Get updated colCount\n          this._setColumns();\n        }\n\n        // Layout items\n        this.sort();\n      }\n    }\n\n    /**\n     * Use this instead of `update()` if you don't need the columns and gutters updated\n     * Maybe an image inside `shuffle` loaded (and now has a height), which means calculations\n     * could be off.\n     */\n\n  }, {\n    key: 'layout',\n    value: function layout() {\n      this.update(true);\n    }\n\n    /**\n     * New items have been appended to shuffle. Mix them in with the current\n     * filter or sort status.\n     * @param {Array.<Element>} newItems Collection of new items.\n     */\n\n  }, {\n    key: 'add',\n    value: function add(newItems) {\n      var items = index$1(newItems).map(function (el) {\n        return new ShuffleItem(el);\n      });\n\n      // Add classes and set initial positions.\n      this._initItems(items);\n\n      // Add transition to each item.\n      this._setTransitions(items);\n\n      // Update the list of items.\n      this.items = this.items.concat(items);\n      this._updateItemsOrder();\n      this.filter(this.lastFilter);\n    }\n\n    /**\n     * Disables shuffle from updating dimensions and layout on resize\n     */\n\n  }, {\n    key: 'disable',\n    value: function disable() {\n      this.isEnabled = false;\n    }\n\n    /**\n     * Enables shuffle again\n     * @param {boolean} [isUpdateLayout=true] if undefined, shuffle will update columns and gutters\n     */\n\n  }, {\n    key: 'enable',\n    value: function enable(isUpdateLayout) {\n      this.isEnabled = true;\n      if (isUpdateLayout !== false) {\n        this.update();\n      }\n    }\n\n    /**\n     * Remove 1 or more shuffle items\n     * @param {Array.<Element>} elements An array containing one or more\n     *     elements in shuffle\n     * @return {Shuffle} The shuffle object\n     */\n\n  }, {\n    key: 'remove',\n    value: function remove(elements) {\n      var _this8 = this;\n\n      if (!elements.length) {\n        return;\n      }\n\n      var collection = index$1(elements);\n\n      var oldItems = collection.map(function (element) {\n        return _this8.getItemByElement(element);\n      }).filter(function (item) {\n        return !!item;\n      });\n\n      var handleLayout = function handleLayout() {\n        _this8.element.removeEventListener(Shuffle.EventType.LAYOUT, handleLayout);\n        _this8._disposeItems(oldItems);\n\n        // Remove the collection in the callback\n        collection.forEach(function (element) {\n          element.parentNode.removeChild(element);\n        });\n\n        _this8._dispatch(Shuffle.EventType.REMOVED, { collection: collection });\n      };\n\n      // Hide collection first.\n      this._toggleFilterClasses({\n        visible: [],\n        hidden: oldItems\n      });\n\n      this._shrink(oldItems);\n\n      this.sort();\n\n      // Update the list of items here because `remove` could be called again\n      // with an item that is in the process of being removed.\n      this.items = this.items.filter(function (item) {\n        return !arrayIncludes(oldItems, item);\n      });\n      this._updateItemCount();\n\n      this.element.addEventListener(Shuffle.EventType.LAYOUT, handleLayout);\n    }\n\n    /**\n     * Retrieve a shuffle item by its element.\n     * @param {Element} element Element to look for.\n     * @return {?ShuffleItem} A shuffle item or null if it's not found.\n     */\n\n  }, {\n    key: 'getItemByElement',\n    value: function getItemByElement(element) {\n      for (var i = this.items.length - 1; i >= 0; i--) {\n        if (this.items[i].element === element) {\n          return this.items[i];\n        }\n      }\n\n      return null;\n    }\n\n    /**\n     * Destroys shuffle, removes events, styles, and classes\n     */\n\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      this._cancelMovement();\n      window.removeEventListener('resize', this._onResize);\n\n      // Reset container styles\n      this.element.classList.remove('shuffle');\n      this.element.removeAttribute('style');\n\n      // Reset individual item styles\n      this._disposeItems();\n\n      // Null DOM references\n      this.items = null;\n      this.options.sizer = null;\n      this.element = null;\n      this._transitions = null;\n\n      // Set a flag so if a debounced resize has been triggered,\n      // it can first check if it is actually isDestroyed and not doing anything\n      this.isDestroyed = true;\n    }\n\n    /**\n     * Returns the outer width of an element, optionally including its margins.\n     *\n     * There are a few different methods for getting the width of an element, none of\n     * which work perfectly for all Shuffle's use cases.\n     *\n     * 1. getBoundingClientRect() `left` and `right` properties.\n     *   - Accounts for transform scaled elements, making it useless for Shuffle\n     *   elements which have shrunk.\n     * 2. The `offsetWidth` property.\n     *   - This value stays the same regardless of the elements transform property,\n     *   however, it does not return subpixel values.\n     * 3. getComputedStyle()\n     *   - This works great Chrome, Firefox, Safari, but IE<=11 does not include\n     *   padding and border when box-sizing: border-box is set, requiring a feature\n     *   test and extra work to add the padding back for IE and other browsers which\n     *   follow the W3C spec here.\n     *\n     * @param {Element} element The element.\n     * @param {boolean} [includeMargins] Whether to include margins. Default is false.\n     * @return {{width: number, height: number}} The width and height.\n     */\n\n  }], [{\n    key: 'getSize',\n    value: function getSize(element, includeMargins) {\n      // Store the styles so that they can be used by others without asking for it again.\n      var styles = window.getComputedStyle(element, null);\n      var width = getNumberStyle(element, 'width', styles);\n      var height = getNumberStyle(element, 'height', styles);\n\n      if (includeMargins) {\n        var marginLeft = getNumberStyle(element, 'marginLeft', styles);\n        var marginRight = getNumberStyle(element, 'marginRight', styles);\n        var marginTop = getNumberStyle(element, 'marginTop', styles);\n        var marginBottom = getNumberStyle(element, 'marginBottom', styles);\n        width += marginLeft + marginRight;\n        height += marginTop + marginBottom;\n      }\n\n      return {\n        width: width,\n        height: height\n      };\n    }\n\n    /**\n     * Change a property or execute a function which will not have a transition\n     * @param {Array.<Element>} elements DOM elements that won't be transitioned.\n     * @param {Function} callback A function which will be called while transition\n     *     is set to 0ms.\n     * @private\n     */\n\n  }, {\n    key: '_skipTransitions',\n    value: function _skipTransitions(elements, callback) {\n      var zero = '0ms';\n\n      // Save current duration and delay.\n      var data = elements.map(function (element) {\n        var style = element.style;\n        var duration = style.transitionDuration;\n        var delay = style.transitionDelay;\n\n        // Set the duration to zero so it happens immediately\n        style.transitionDuration = zero;\n        style.transitionDelay = zero;\n\n        return {\n          duration: duration,\n          delay: delay\n        };\n      });\n\n      callback();\n\n      // Cause reflow.\n      elements[0].offsetWidth; // eslint-disable-line no-unused-expressions\n\n      // Put the duration back\n      elements.forEach(function (element, i) {\n        element.style.transitionDuration = data[i].duration;\n        element.style.transitionDelay = data[i].delay;\n      });\n    }\n  }]);\n  return Shuffle;\n}();\n\nShuffle.ShuffleItem = ShuffleItem;\n\nShuffle.ALL_ITEMS = 'all';\nShuffle.FILTER_ATTRIBUTE_KEY = 'groups';\n\n/**\n * @enum {string}\n */\nShuffle.EventType = {\n  LAYOUT: 'shuffle:layout',\n  REMOVED: 'shuffle:removed'\n};\n\n/** @enum {string} */\nShuffle.Classes = Classes;\n\n/**\n * @enum {string}\n */\nShuffle.FilterMode = {\n  ANY: 'any',\n  ALL: 'all'\n};\n\n// Overrideable options\nShuffle.options = {\n  // Initial filter group.\n  group: Shuffle.ALL_ITEMS,\n\n  // Transition/animation speed (milliseconds).\n  speed: 250,\n\n  // CSS easing function to use.\n  easing: 'ease',\n\n  // e.g. '.picture-item'.\n  itemSelector: '*',\n\n  // Element or selector string. Use an element to determine the size of columns\n  // and gutters.\n  sizer: null,\n\n  // A static number or function that tells the plugin how wide the gutters\n  // between columns are (in pixels).\n  gutterWidth: 0,\n\n  // A static number or function that returns a number which tells the plugin\n  // how wide the columns are (in pixels).\n  columnWidth: 0,\n\n  // If your group is not json, and is comma delimeted, you could set delimeter\n  // to ','.\n  delimeter: null,\n\n  // Useful for percentage based heights when they might not always be exactly\n  // the same (in pixels).\n  buffer: 0,\n\n  // Reading the width of elements isn't precise enough and can cause columns to\n  // jump between values.\n  columnThreshold: 0.01,\n\n  // Shuffle can be isInitialized with a sort object. It is the same object\n  // given to the sort method.\n  initialSort: null,\n\n  // By default, shuffle will throttle resize events. This can be changed or\n  // removed.\n  throttle: index$2,\n\n  // How often shuffle can be called on resize (in milliseconds).\n  throttleTime: 300,\n\n  // Transition delay offset for each item in milliseconds.\n  staggerAmount: 15,\n\n  // Maximum stagger delay in milliseconds.\n  staggerAmountMax: 250,\n\n  // Whether to use transforms or absolute positioning.\n  useTransforms: true,\n\n  // Affects using an array with filter. e.g. `filter(['one', 'two'])`. With \"any\",\n  // the element passes the test if any of its groups are in the array. With \"all\",\n  // the element only passes if all groups are in the array.\n  filterMode: Shuffle.FilterMode.ANY\n};\n\n// Expose for testing. Hack at your own risk.\nShuffle.__Point = Point;\nShuffle.__sorter = sorter;\nShuffle.__getColumnSpan = getColumnSpan;\nShuffle.__getAvailablePositions = getAvailablePositions;\nShuffle.__getShortColumn = getShortColumn;\n\nreturn Shuffle;\n\n})));\n//# sourceMappingURL=shuffle.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/shufflejs/dist/shuffle.js\n// module id = 11\n// module chunks = 0","import 'normalize.css';\nimport './../css/paraxify.css';\nimport './../styl/home.styl';\n\nimport './../js/paraxify';\nimport Shuffle from 'shufflejs';\nimport Vimeo from '@vimeo/player';\nimport Inputmask from \"inputmask\";\n\ndocument.addEventListener('DOMContentLoaded', () => {\n    window.addEventListener('scroll', () => {\n        const scroll = document.body.scrollTop;\n        if (scroll > 400) {\n            document.querySelector('.header').classList.add('affix');\n        } else {\n            document.querySelector('.header').classList.remove('affix');\n        }\n    });\n\n    document.getElementById('mobile-menu').addEventListener('click', () => {\n        document.querySelector('header.header').classList.toggle('active');\n    });\n\n    // Adjusts cover video size\n    const adjustVideo = () => {\n        const w = window.innerWidth;\n        if (w > 768 && top.offsetHeight > v.offsetHeight) {\n            const vRatio = (v.videoHeight - 20) / v.videoWidth;\n            top.style.height = (vRatio * w) + 'px';\n        }\n    }\n    const top = document.querySelector('.top');\n    const v = document.getElementsByTagName('video')[0];\n    if (v) {\n        v.addEventListener('loadeddata', () => {\n            adjustVideo();\n        });\n    }\n\n    // Parallax home page\n    paraxify('.paraxify');\n\n    // Adjusts home page projects container size\n    const adjustProjectContainers = () => {\n        const w = window.innerWidth;\n        const containers = document.querySelectorAll('.project-container');\n        if (w > 868) {\n            containers.forEach((c) => {\n                c.style.height = (c.querySelector('.project_big img').clientHeight - 2) + 'px';\n            });\n        } else {\n            containers.forEach((c) => {\n                c.style.height = null;\n            });\n        }\n    };\n    adjustProjectContainers();\n\n    document.querySelectorAll('.single_project-video').forEach((el) => {\n        const player = new Vimeo(el, {\n            id: el.dataset.id,\n            width: el.offsetWidth.toFixed(0)\n        });\n    });\n\n    // Vimeo lightbox\n    document.querySelectorAll('.start-video').forEach((d) => {\n        d.addEventListener('click', (e) => {\n            e.preventDefault();\n            const overlay = document.createElement('div');\n            overlay.id = 'body-overlay';\n            overlay.classList.add('body-overlay');\n            document.body.appendChild(overlay);\n            const close = document.createElement('span');\n            close.classList.add('fa');\n            close.classList.add('fa-close');\n            close.addEventListener('click', () => {\n                overlay.parentNode.removeChild(overlay);\n            });\n            overlay.addEventListener('click', (e) => {\n                if (e.target.id === 'body-overlay') {\n                    overlay.parentNode.removeChild(overlay);\n                }\n            });\n            overlay.appendChild(close);\n            const video = document.createElement('div');\n            video.classList.add('video-player');\n            overlay.appendChild(video);\n            const width = (overlay.offsetWidth * 0.8).toFixed(0);\n            const player = new Vimeo(video, {\n                id: e.target.dataset.id,\n                width\n            });\n        });\n    });\n\n    // Vimeo lightbox\n    document.querySelectorAll('.start-photo').forEach((d) => {\n        d.addEventListener('click', (e) => {\n            e.preventDefault();\n            const overlay = document.createElement('div');\n            overlay.id = 'body-overlay';\n            overlay.classList.add('body-overlay');\n            document.body.appendChild(overlay);\n            const close = document.createElement('span');\n            close.classList.add('fa');\n            close.classList.add('fa-close');\n            close.addEventListener('click', () => {\n                overlay.parentNode.removeChild(overlay);\n            });\n            overlay.addEventListener('click', (e) => {\n                if (e.target.id === 'body-overlay') {\n                    overlay.parentNode.removeChild(overlay);\n                }\n            });\n            overlay.appendChild(close);\n            const photo = document.createElement('img');\n            photo.src = `/media/${e.target.dataset.src}`;\n            photo.style.maxWidth = `${(overlay.offsetWidth * 0.8).toFixed(0)}px`;\n            photo.style.maxHeight = `${(overlay.offsetHeight * 0.8).toFixed(0)}px`;\n            console.log((overlay.offsetWidth * 0.8).toFixed(0));\n            overlay.appendChild(photo);\n        });\n    });\n\n    // Clients testimonials\n    let testPosition = 0;\n    const moveTestimonials = (direction) => {\n        const testContainer = document.getElementById('testimonial-container');\n        const testCount = document.querySelectorAll('.testimonial-content').length;\n        if (direction === 'right') {\n            if (testPosition < testCount - 1) {\n                const move = (testPosition + 1) * 100;\n                testContainer.style.transform = `translateX(-${move}%)`;\n                testPosition++;\n            } else {\n                testContainer.style.transform = 'translateX(0)';\n                testPosition = 0;\n            }\n        } else {\n            if (testPosition > 0) {\n                const move = (testPosition - 1) * 100;\n                testContainer.style.transform = `translateX(-${move}%)`;\n                testPosition--;\n            } else {\n                const move = (testCount - 1) * 100;\n                testContainer.style.transform = `translateX(-${move}%)`;\n                testPosition = testCount - 1;\n            }\n        }\n    };\n\n    const startTestimonials = (el, direction) => {\n        el.addEventListener('click', () => {\n            moveTestimonials(direction);\n        });\n    };\n\n    const arrowLeft = document.getElementById('testimonial-control-left');\n    const arrowRight = document.getElementById('testimonial-control-right');\n    if (arrowRight && arrowLeft) {\n        startTestimonials(arrowLeft, 'left');\n        startTestimonials(arrowRight, 'right');\n        setInterval(() => {\n            moveTestimonials('right');\n        }, 8000);\n    }\n\n    // Shuffle for projects page\n    const grid = document.getElementById('grid');\n    if (grid) {\n        const shuffle = new Shuffle(grid, {\n          itemSelector: '.projects-content_item',\n          gutterWidth: 20,\n          columnWidth: (w) => {\n            let width = (w / 3) - 15;\n            if (w < 400) {\n                width = w;\n            } else if (w < 750) {\n                width = (w / 2) - 10;\n            }\n            document.querySelectorAll('.projects-content_item').forEach((item) => {\n                item.style.width = width + 'px';\n                item.style.height = width + 'px';\n            });\n            return width;\n          },\n        });\n        document.querySelectorAll('.project-filter-button').forEach((button) => {\n            button.addEventListener('click', (e) => {\n                e.target.classList.toggle('active');\n                shuffle.filter(e.target.id);\n            })\n        });\n    }\n\n    const onResize = () => {\n        adjustProjectContainers();\n        if (v) {\n            adjustVideo();\n        }\n    };\n    window.onresize = onResize;\n\n    Inputmask({ 'mask': '(99) [9]9999-9999' }).mask('.telephone-number');\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./home/static/home/js/home.js\n// module id = 12\n// module chunks = 0","/*!\n* inputmask.date.extensions.js\n* https://github.com/RobinHerbots/Inputmask\n* Copyright (c) 2010 - 2017 Robin Herbots\n* Licensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)\n* Version: 3.3.7\n*/\n\n!function(factory) {\n    \"function\" == typeof define && define.amd ? define([ \"./dependencyLibs/inputmask.dependencyLib\", \"./inputmask\" ], factory) : \"object\" == typeof exports ? module.exports = factory(require(\"./dependencyLibs/inputmask.dependencyLib\"), require(\"./inputmask\")) : factory(window.dependencyLib || jQuery, window.Inputmask);\n}(function($, Inputmask) {\n    function isLeapYear(year) {\n        return isNaN(year) || 29 === new Date(year, 2, 0).getDate();\n    }\n    return Inputmask.extendAliases({\n        \"dd/mm/yyyy\": {\n            mask: \"1/2/y\",\n            placeholder: \"dd/mm/yyyy\",\n            regex: {\n                val1pre: new RegExp(\"[0-3]\"),\n                val1: new RegExp(\"0[1-9]|[12][0-9]|3[01]\"),\n                val2pre: function(separator) {\n                    var escapedSeparator = Inputmask.escapeRegex.call(this, separator);\n                    return new RegExp(\"((0[1-9]|[12][0-9]|3[01])\" + escapedSeparator + \"[01])\");\n                },\n                val2: function(separator) {\n                    var escapedSeparator = Inputmask.escapeRegex.call(this, separator);\n                    return new RegExp(\"((0[1-9]|[12][0-9])\" + escapedSeparator + \"(0[1-9]|1[012]))|(30\" + escapedSeparator + \"(0[13-9]|1[012]))|(31\" + escapedSeparator + \"(0[13578]|1[02]))\");\n                }\n            },\n            leapday: \"29/02/\",\n            separator: \"/\",\n            yearrange: {\n                minyear: 1900,\n                maxyear: 2099\n            },\n            isInYearRange: function(chrs, minyear, maxyear) {\n                if (isNaN(chrs)) return !1;\n                var enteredyear = parseInt(chrs.concat(minyear.toString().slice(chrs.length))), enteredyear2 = parseInt(chrs.concat(maxyear.toString().slice(chrs.length)));\n                return !isNaN(enteredyear) && (minyear <= enteredyear && enteredyear <= maxyear) || !isNaN(enteredyear2) && (minyear <= enteredyear2 && enteredyear2 <= maxyear);\n            },\n            determinebaseyear: function(minyear, maxyear, hint) {\n                var currentyear = new Date().getFullYear();\n                if (minyear > currentyear) return minyear;\n                if (maxyear < currentyear) {\n                    for (var maxYearPrefix = maxyear.toString().slice(0, 2), maxYearPostfix = maxyear.toString().slice(2, 4); maxyear < maxYearPrefix + hint; ) maxYearPrefix--;\n                    var maxxYear = maxYearPrefix + maxYearPostfix;\n                    return minyear > maxxYear ? minyear : maxxYear;\n                }\n                if (minyear <= currentyear && currentyear <= maxyear) {\n                    for (var currentYearPrefix = currentyear.toString().slice(0, 2); maxyear < currentYearPrefix + hint; ) currentYearPrefix--;\n                    var currentYearAndHint = currentYearPrefix + hint;\n                    return currentYearAndHint < minyear ? minyear : currentYearAndHint;\n                }\n                return currentyear;\n            },\n            onKeyDown: function(e, buffer, caretPos, opts) {\n                var $input = $(this);\n                if (e.ctrlKey && e.keyCode === Inputmask.keyCode.RIGHT) {\n                    var today = new Date();\n                    $input.val(today.getDate().toString() + (today.getMonth() + 1).toString() + today.getFullYear().toString()), \n                    $input.trigger(\"setvalue\");\n                }\n            },\n            getFrontValue: function(mask, buffer, opts) {\n                for (var start = 0, length = 0, i = 0; i < mask.length && \"2\" !== mask.charAt(i); i++) {\n                    var definition = opts.definitions[mask.charAt(i)];\n                    definition ? (start += length, length = definition.cardinality) : length++;\n                }\n                return buffer.join(\"\").substr(start, length);\n            },\n            postValidation: function(buffer, currentResult, opts) {\n                var dayMonthValue, year, bufferStr = buffer.join(\"\");\n                return 0 === opts.mask.indexOf(\"y\") ? (year = bufferStr.substr(0, 4), dayMonthValue = bufferStr.substring(4, 10)) : (year = bufferStr.substring(6, 10), \n                dayMonthValue = bufferStr.substr(0, 6)), currentResult && (dayMonthValue !== opts.leapday || isLeapYear(year));\n            },\n            definitions: {\n                \"1\": {\n                    validator: function(chrs, maskset, pos, strict, opts) {\n                        var isValid = opts.regex.val1.test(chrs);\n                        return strict || isValid || chrs.charAt(1) !== opts.separator && -1 === \"-./\".indexOf(chrs.charAt(1)) || !(isValid = opts.regex.val1.test(\"0\" + chrs.charAt(0))) ? isValid : (maskset.buffer[pos - 1] = \"0\", \n                        {\n                            refreshFromBuffer: {\n                                start: pos - 1,\n                                end: pos\n                            },\n                            pos: pos,\n                            c: chrs.charAt(0)\n                        });\n                    },\n                    cardinality: 2,\n                    prevalidator: [ {\n                        validator: function(chrs, maskset, pos, strict, opts) {\n                            var pchrs = chrs;\n                            isNaN(maskset.buffer[pos + 1]) || (pchrs += maskset.buffer[pos + 1]);\n                            var isValid = 1 === pchrs.length ? opts.regex.val1pre.test(pchrs) : opts.regex.val1.test(pchrs);\n                            if (!strict && !isValid) {\n                                if (isValid = opts.regex.val1.test(chrs + \"0\")) return maskset.buffer[pos] = chrs, \n                                maskset.buffer[++pos] = \"0\", {\n                                    pos: pos,\n                                    c: \"0\"\n                                };\n                                if (isValid = opts.regex.val1.test(\"0\" + chrs)) return maskset.buffer[pos] = \"0\", \n                                pos++, {\n                                    pos: pos\n                                };\n                            }\n                            return isValid;\n                        },\n                        cardinality: 1\n                    } ]\n                },\n                \"2\": {\n                    validator: function(chrs, maskset, pos, strict, opts) {\n                        var frontValue = opts.getFrontValue(maskset.mask, maskset.buffer, opts);\n                        -1 !== frontValue.indexOf(opts.placeholder[0]) && (frontValue = \"01\" + opts.separator);\n                        var isValid = opts.regex.val2(opts.separator).test(frontValue + chrs);\n                        return strict || isValid || chrs.charAt(1) !== opts.separator && -1 === \"-./\".indexOf(chrs.charAt(1)) || !(isValid = opts.regex.val2(opts.separator).test(frontValue + \"0\" + chrs.charAt(0))) ? isValid : (maskset.buffer[pos - 1] = \"0\", \n                        {\n                            refreshFromBuffer: {\n                                start: pos - 1,\n                                end: pos\n                            },\n                            pos: pos,\n                            c: chrs.charAt(0)\n                        });\n                    },\n                    cardinality: 2,\n                    prevalidator: [ {\n                        validator: function(chrs, maskset, pos, strict, opts) {\n                            isNaN(maskset.buffer[pos + 1]) || (chrs += maskset.buffer[pos + 1]);\n                            var frontValue = opts.getFrontValue(maskset.mask, maskset.buffer, opts);\n                            -1 !== frontValue.indexOf(opts.placeholder[0]) && (frontValue = \"01\" + opts.separator);\n                            var isValid = 1 === chrs.length ? opts.regex.val2pre(opts.separator).test(frontValue + chrs) : opts.regex.val2(opts.separator).test(frontValue + chrs);\n                            return strict || isValid || !(isValid = opts.regex.val2(opts.separator).test(frontValue + \"0\" + chrs)) ? isValid : (maskset.buffer[pos] = \"0\", \n                            pos++, {\n                                pos: pos\n                            });\n                        },\n                        cardinality: 1\n                    } ]\n                },\n                y: {\n                    validator: function(chrs, maskset, pos, strict, opts) {\n                        return opts.isInYearRange(chrs, opts.yearrange.minyear, opts.yearrange.maxyear);\n                    },\n                    cardinality: 4,\n                    prevalidator: [ {\n                        validator: function(chrs, maskset, pos, strict, opts) {\n                            var isValid = opts.isInYearRange(chrs, opts.yearrange.minyear, opts.yearrange.maxyear);\n                            if (!strict && !isValid) {\n                                var yearPrefix = opts.determinebaseyear(opts.yearrange.minyear, opts.yearrange.maxyear, chrs + \"0\").toString().slice(0, 1);\n                                if (isValid = opts.isInYearRange(yearPrefix + chrs, opts.yearrange.minyear, opts.yearrange.maxyear)) return maskset.buffer[pos++] = yearPrefix.charAt(0), \n                                {\n                                    pos: pos\n                                };\n                                if (yearPrefix = opts.determinebaseyear(opts.yearrange.minyear, opts.yearrange.maxyear, chrs + \"0\").toString().slice(0, 2), \n                                isValid = opts.isInYearRange(yearPrefix + chrs, opts.yearrange.minyear, opts.yearrange.maxyear)) return maskset.buffer[pos++] = yearPrefix.charAt(0), \n                                maskset.buffer[pos++] = yearPrefix.charAt(1), {\n                                    pos: pos\n                                };\n                            }\n                            return isValid;\n                        },\n                        cardinality: 1\n                    }, {\n                        validator: function(chrs, maskset, pos, strict, opts) {\n                            var isValid = opts.isInYearRange(chrs, opts.yearrange.minyear, opts.yearrange.maxyear);\n                            if (!strict && !isValid) {\n                                var yearPrefix = opts.determinebaseyear(opts.yearrange.minyear, opts.yearrange.maxyear, chrs).toString().slice(0, 2);\n                                if (isValid = opts.isInYearRange(chrs[0] + yearPrefix[1] + chrs[1], opts.yearrange.minyear, opts.yearrange.maxyear)) return maskset.buffer[pos++] = yearPrefix.charAt(1), \n                                {\n                                    pos: pos\n                                };\n                                if (yearPrefix = opts.determinebaseyear(opts.yearrange.minyear, opts.yearrange.maxyear, chrs).toString().slice(0, 2), \n                                isValid = opts.isInYearRange(yearPrefix + chrs, opts.yearrange.minyear, opts.yearrange.maxyear)) return maskset.buffer[pos - 1] = yearPrefix.charAt(0), \n                                maskset.buffer[pos++] = yearPrefix.charAt(1), maskset.buffer[pos++] = chrs.charAt(0), \n                                {\n                                    refreshFromBuffer: {\n                                        start: pos - 3,\n                                        end: pos\n                                    },\n                                    pos: pos\n                                };\n                            }\n                            return isValid;\n                        },\n                        cardinality: 2\n                    }, {\n                        validator: function(chrs, maskset, pos, strict, opts) {\n                            return opts.isInYearRange(chrs, opts.yearrange.minyear, opts.yearrange.maxyear);\n                        },\n                        cardinality: 3\n                    } ]\n                }\n            },\n            insertMode: !1,\n            autoUnmask: !1\n        },\n        \"mm/dd/yyyy\": {\n            placeholder: \"mm/dd/yyyy\",\n            alias: \"dd/mm/yyyy\",\n            regex: {\n                val2pre: function(separator) {\n                    var escapedSeparator = Inputmask.escapeRegex.call(this, separator);\n                    return new RegExp(\"((0[13-9]|1[012])\" + escapedSeparator + \"[0-3])|(02\" + escapedSeparator + \"[0-2])\");\n                },\n                val2: function(separator) {\n                    var escapedSeparator = Inputmask.escapeRegex.call(this, separator);\n                    return new RegExp(\"((0[1-9]|1[012])\" + escapedSeparator + \"(0[1-9]|[12][0-9]))|((0[13-9]|1[012])\" + escapedSeparator + \"30)|((0[13578]|1[02])\" + escapedSeparator + \"31)\");\n                },\n                val1pre: new RegExp(\"[01]\"),\n                val1: new RegExp(\"0[1-9]|1[012]\")\n            },\n            leapday: \"02/29/\",\n            onKeyDown: function(e, buffer, caretPos, opts) {\n                var $input = $(this);\n                if (e.ctrlKey && e.keyCode === Inputmask.keyCode.RIGHT) {\n                    var today = new Date();\n                    $input.val((today.getMonth() + 1).toString() + today.getDate().toString() + today.getFullYear().toString()), \n                    $input.trigger(\"setvalue\");\n                }\n            }\n        },\n        \"yyyy/mm/dd\": {\n            mask: \"y/1/2\",\n            placeholder: \"yyyy/mm/dd\",\n            alias: \"mm/dd/yyyy\",\n            leapday: \"/02/29\",\n            onKeyDown: function(e, buffer, caretPos, opts) {\n                var $input = $(this);\n                if (e.ctrlKey && e.keyCode === Inputmask.keyCode.RIGHT) {\n                    var today = new Date();\n                    $input.val(today.getFullYear().toString() + (today.getMonth() + 1).toString() + today.getDate().toString()), \n                    $input.trigger(\"setvalue\");\n                }\n            }\n        },\n        \"dd.mm.yyyy\": {\n            mask: \"1.2.y\",\n            placeholder: \"dd.mm.yyyy\",\n            leapday: \"29.02.\",\n            separator: \".\",\n            alias: \"dd/mm/yyyy\"\n        },\n        \"dd-mm-yyyy\": {\n            mask: \"1-2-y\",\n            placeholder: \"dd-mm-yyyy\",\n            leapday: \"29-02-\",\n            separator: \"-\",\n            alias: \"dd/mm/yyyy\"\n        },\n        \"mm.dd.yyyy\": {\n            mask: \"1.2.y\",\n            placeholder: \"mm.dd.yyyy\",\n            leapday: \"02.29.\",\n            separator: \".\",\n            alias: \"mm/dd/yyyy\"\n        },\n        \"mm-dd-yyyy\": {\n            mask: \"1-2-y\",\n            placeholder: \"mm-dd-yyyy\",\n            leapday: \"02-29-\",\n            separator: \"-\",\n            alias: \"mm/dd/yyyy\"\n        },\n        \"yyyy.mm.dd\": {\n            mask: \"y.1.2\",\n            placeholder: \"yyyy.mm.dd\",\n            leapday: \".02.29\",\n            separator: \".\",\n            alias: \"yyyy/mm/dd\"\n        },\n        \"yyyy-mm-dd\": {\n            mask: \"y-1-2\",\n            placeholder: \"yyyy-mm-dd\",\n            leapday: \"-02-29\",\n            separator: \"-\",\n            alias: \"yyyy/mm/dd\"\n        },\n        datetime: {\n            mask: \"1/2/y h:s\",\n            placeholder: \"dd/mm/yyyy hh:mm\",\n            alias: \"dd/mm/yyyy\",\n            regex: {\n                hrspre: new RegExp(\"[012]\"),\n                hrs24: new RegExp(\"2[0-4]|1[3-9]\"),\n                hrs: new RegExp(\"[01][0-9]|2[0-4]\"),\n                ampm: new RegExp(\"^[a|p|A|P][m|M]\"),\n                mspre: new RegExp(\"[0-5]\"),\n                ms: new RegExp(\"[0-5][0-9]\")\n            },\n            timeseparator: \":\",\n            hourFormat: \"24\",\n            definitions: {\n                h: {\n                    validator: function(chrs, maskset, pos, strict, opts) {\n                        if (\"24\" === opts.hourFormat && 24 === parseInt(chrs, 10)) return maskset.buffer[pos - 1] = \"0\", \n                        maskset.buffer[pos] = \"0\", {\n                            refreshFromBuffer: {\n                                start: pos - 1,\n                                end: pos\n                            },\n                            c: \"0\"\n                        };\n                        var isValid = opts.regex.hrs.test(chrs);\n                        if (!strict && !isValid && (chrs.charAt(1) === opts.timeseparator || -1 !== \"-.:\".indexOf(chrs.charAt(1))) && (isValid = opts.regex.hrs.test(\"0\" + chrs.charAt(0)))) return maskset.buffer[pos - 1] = \"0\", \n                        maskset.buffer[pos] = chrs.charAt(0), pos++, {\n                            refreshFromBuffer: {\n                                start: pos - 2,\n                                end: pos\n                            },\n                            pos: pos,\n                            c: opts.timeseparator\n                        };\n                        if (isValid && \"24\" !== opts.hourFormat && opts.regex.hrs24.test(chrs)) {\n                            var tmp = parseInt(chrs, 10);\n                            return 24 === tmp ? (maskset.buffer[pos + 5] = \"a\", maskset.buffer[pos + 6] = \"m\") : (maskset.buffer[pos + 5] = \"p\", \n                            maskset.buffer[pos + 6] = \"m\"), tmp -= 12, tmp < 10 ? (maskset.buffer[pos] = tmp.toString(), \n                            maskset.buffer[pos - 1] = \"0\") : (maskset.buffer[pos] = tmp.toString().charAt(1), \n                            maskset.buffer[pos - 1] = tmp.toString().charAt(0)), {\n                                refreshFromBuffer: {\n                                    start: pos - 1,\n                                    end: pos + 6\n                                },\n                                c: maskset.buffer[pos]\n                            };\n                        }\n                        return isValid;\n                    },\n                    cardinality: 2,\n                    prevalidator: [ {\n                        validator: function(chrs, maskset, pos, strict, opts) {\n                            var isValid = opts.regex.hrspre.test(chrs);\n                            return strict || isValid || !(isValid = opts.regex.hrs.test(\"0\" + chrs)) ? isValid : (maskset.buffer[pos] = \"0\", \n                            pos++, {\n                                pos: pos\n                            });\n                        },\n                        cardinality: 1\n                    } ]\n                },\n                s: {\n                    validator: \"[0-5][0-9]\",\n                    cardinality: 2,\n                    prevalidator: [ {\n                        validator: function(chrs, maskset, pos, strict, opts) {\n                            var isValid = opts.regex.mspre.test(chrs);\n                            return strict || isValid || !(isValid = opts.regex.ms.test(\"0\" + chrs)) ? isValid : (maskset.buffer[pos] = \"0\", \n                            pos++, {\n                                pos: pos\n                            });\n                        },\n                        cardinality: 1\n                    } ]\n                },\n                t: {\n                    validator: function(chrs, maskset, pos, strict, opts) {\n                        return opts.regex.ampm.test(chrs + \"m\");\n                    },\n                    casing: \"lower\",\n                    cardinality: 1\n                }\n            },\n            insertMode: !1,\n            autoUnmask: !1\n        },\n        datetime12: {\n            mask: \"1/2/y h:s t\\\\m\",\n            placeholder: \"dd/mm/yyyy hh:mm xm\",\n            alias: \"datetime\",\n            hourFormat: \"12\"\n        },\n        \"mm/dd/yyyy hh:mm xm\": {\n            mask: \"1/2/y h:s t\\\\m\",\n            placeholder: \"mm/dd/yyyy hh:mm xm\",\n            alias: \"datetime12\",\n            regex: {\n                val2pre: function(separator) {\n                    var escapedSeparator = Inputmask.escapeRegex.call(this, separator);\n                    return new RegExp(\"((0[13-9]|1[012])\" + escapedSeparator + \"[0-3])|(02\" + escapedSeparator + \"[0-2])\");\n                },\n                val2: function(separator) {\n                    var escapedSeparator = Inputmask.escapeRegex.call(this, separator);\n                    return new RegExp(\"((0[1-9]|1[012])\" + escapedSeparator + \"(0[1-9]|[12][0-9]))|((0[13-9]|1[012])\" + escapedSeparator + \"30)|((0[13578]|1[02])\" + escapedSeparator + \"31)\");\n                },\n                val1pre: new RegExp(\"[01]\"),\n                val1: new RegExp(\"0[1-9]|1[012]\")\n            },\n            leapday: \"02/29/\",\n            onKeyDown: function(e, buffer, caretPos, opts) {\n                var $input = $(this);\n                if (e.ctrlKey && e.keyCode === Inputmask.keyCode.RIGHT) {\n                    var today = new Date();\n                    $input.val((today.getMonth() + 1).toString() + today.getDate().toString() + today.getFullYear().toString()), \n                    $input.trigger(\"setvalue\");\n                }\n            }\n        },\n        \"hh:mm t\": {\n            mask: \"h:s t\\\\m\",\n            placeholder: \"hh:mm xm\",\n            alias: \"datetime\",\n            hourFormat: \"12\"\n        },\n        \"h:s t\": {\n            mask: \"h:s t\\\\m\",\n            placeholder: \"hh:mm xm\",\n            alias: \"datetime\",\n            hourFormat: \"12\"\n        },\n        \"hh:mm:ss\": {\n            mask: \"h:s:s\",\n            placeholder: \"hh:mm:ss\",\n            alias: \"datetime\",\n            autoUnmask: !1\n        },\n        \"hh:mm\": {\n            mask: \"h:s\",\n            placeholder: \"hh:mm\",\n            alias: \"datetime\",\n            autoUnmask: !1\n        },\n        date: {\n            alias: \"dd/mm/yyyy\"\n        },\n        \"mm/yyyy\": {\n            mask: \"1/y\",\n            placeholder: \"mm/yyyy\",\n            leapday: \"donotuse\",\n            separator: \"/\",\n            alias: \"mm/dd/yyyy\"\n        },\n        shamsi: {\n            regex: {\n                val2pre: function(separator) {\n                    var escapedSeparator = Inputmask.escapeRegex.call(this, separator);\n                    return new RegExp(\"((0[1-9]|1[012])\" + escapedSeparator + \"[0-3])\");\n                },\n                val2: function(separator) {\n                    var escapedSeparator = Inputmask.escapeRegex.call(this, separator);\n                    return new RegExp(\"((0[1-9]|1[012])\" + escapedSeparator + \"(0[1-9]|[12][0-9]))|((0[1-9]|1[012])\" + escapedSeparator + \"30)|((0[1-6])\" + escapedSeparator + \"31)\");\n                },\n                val1pre: new RegExp(\"[01]\"),\n                val1: new RegExp(\"0[1-9]|1[012]\")\n            },\n            yearrange: {\n                minyear: 1300,\n                maxyear: 1499\n            },\n            mask: \"y/1/2\",\n            leapday: \"/12/30\",\n            placeholder: \"yyyy/mm/dd\",\n            alias: \"mm/dd/yyyy\",\n            clearIncomplete: !0\n        },\n        \"yyyy-mm-dd hh:mm:ss\": {\n            mask: \"y-1-2 h:s:s\",\n            placeholder: \"yyyy-mm-dd hh:mm:ss\",\n            alias: \"datetime\",\n            separator: \"-\",\n            leapday: \"-02-29\",\n            regex: {\n                val2pre: function(separator) {\n                    var escapedSeparator = Inputmask.escapeRegex.call(this, separator);\n                    return new RegExp(\"((0[13-9]|1[012])\" + escapedSeparator + \"[0-3])|(02\" + escapedSeparator + \"[0-2])\");\n                },\n                val2: function(separator) {\n                    var escapedSeparator = Inputmask.escapeRegex.call(this, separator);\n                    return new RegExp(\"((0[1-9]|1[012])\" + escapedSeparator + \"(0[1-9]|[12][0-9]))|((0[13-9]|1[012])\" + escapedSeparator + \"30)|((0[13578]|1[02])\" + escapedSeparator + \"31)\");\n                },\n                val1pre: new RegExp(\"[01]\"),\n                val1: new RegExp(\"0[1-9]|1[012]\")\n            },\n            onKeyDown: function(e, buffer, caretPos, opts) {}\n        }\n    }), Inputmask;\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/inputmask/dist/inputmask/inputmask.date.extensions.js\n// module id = 13\n// module chunks = 0","/*!\n* inputmask.extensions.js\n* https://github.com/RobinHerbots/Inputmask\n* Copyright (c) 2010 - 2017 Robin Herbots\n* Licensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)\n* Version: 3.3.7\n*/\n\n!function(factory) {\n    \"function\" == typeof define && define.amd ? define([ \"./dependencyLibs/inputmask.dependencyLib\", \"./inputmask\" ], factory) : \"object\" == typeof exports ? module.exports = factory(require(\"./dependencyLibs/inputmask.dependencyLib\"), require(\"./inputmask\")) : factory(window.dependencyLib || jQuery, window.Inputmask);\n}(function($, Inputmask) {\n    return Inputmask.extendDefinitions({\n        A: {\n            validator: \"[A-Za-z\\u0410-\\u044f\\u0401\\u0451\\xc0-\\xff\\xb5]\",\n            cardinality: 1,\n            casing: \"upper\"\n        },\n        \"&\": {\n            validator: \"[0-9A-Za-z\\u0410-\\u044f\\u0401\\u0451\\xc0-\\xff\\xb5]\",\n            cardinality: 1,\n            casing: \"upper\"\n        },\n        \"#\": {\n            validator: \"[0-9A-Fa-f]\",\n            cardinality: 1,\n            casing: \"upper\"\n        }\n    }), Inputmask.extendAliases({\n        url: {\n            definitions: {\n                i: {\n                    validator: \".\",\n                    cardinality: 1\n                }\n            },\n            mask: \"(\\\\http://)|(\\\\http\\\\s://)|(ftp://)|(ftp\\\\s://)i{+}\",\n            insertMode: !1,\n            autoUnmask: !1,\n            inputmode: \"url\"\n        },\n        ip: {\n            mask: \"i[i[i]].i[i[i]].i[i[i]].i[i[i]]\",\n            definitions: {\n                i: {\n                    validator: function(chrs, maskset, pos, strict, opts) {\n                        return pos - 1 > -1 && \".\" !== maskset.buffer[pos - 1] ? (chrs = maskset.buffer[pos - 1] + chrs, \n                        chrs = pos - 2 > -1 && \".\" !== maskset.buffer[pos - 2] ? maskset.buffer[pos - 2] + chrs : \"0\" + chrs) : chrs = \"00\" + chrs, \n                        new RegExp(\"25[0-5]|2[0-4][0-9]|[01][0-9][0-9]\").test(chrs);\n                    },\n                    cardinality: 1\n                }\n            },\n            onUnMask: function(maskedValue, unmaskedValue, opts) {\n                return maskedValue;\n            },\n            inputmode: \"numeric\"\n        },\n        email: {\n            mask: \"*{1,64}[.*{1,64}][.*{1,64}][.*{1,63}]@-{1,63}.-{1,63}[.-{1,63}][.-{1,63}]\",\n            greedy: !1,\n            onBeforePaste: function(pastedValue, opts) {\n                return pastedValue = pastedValue.toLowerCase(), pastedValue.replace(\"mailto:\", \"\");\n            },\n            definitions: {\n                \"*\": {\n                    validator: \"[0-9A-Za-z!#$%&'*+/=?^_`{|}~-]\",\n                    cardinality: 1,\n                    casing: \"lower\"\n                },\n                \"-\": {\n                    validator: \"[0-9A-Za-z-]\",\n                    cardinality: 1,\n                    casing: \"lower\"\n                }\n            },\n            onUnMask: function(maskedValue, unmaskedValue, opts) {\n                return maskedValue;\n            },\n            inputmode: \"email\"\n        },\n        mac: {\n            mask: \"##:##:##:##:##:##\"\n        },\n        vin: {\n            mask: \"V{13}9{4}\",\n            definitions: {\n                V: {\n                    validator: \"[A-HJ-NPR-Za-hj-npr-z\\\\d]\",\n                    cardinality: 1,\n                    casing: \"upper\"\n                }\n            },\n            clearIncomplete: !0,\n            autoUnmask: !0\n        }\n    }), Inputmask;\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/inputmask/dist/inputmask/inputmask.extensions.js\n// module id = 14\n// module chunks = 0","/*!\n* inputmask.numeric.extensions.js\n* https://github.com/RobinHerbots/Inputmask\n* Copyright (c) 2010 - 2017 Robin Herbots\n* Licensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)\n* Version: 3.3.7\n*/\n\n!function(factory) {\n    \"function\" == typeof define && define.amd ? define([ \"./dependencyLibs/inputmask.dependencyLib\", \"./inputmask\" ], factory) : \"object\" == typeof exports ? module.exports = factory(require(\"./dependencyLibs/inputmask.dependencyLib\"), require(\"./inputmask\")) : factory(window.dependencyLib || jQuery, window.Inputmask);\n}(function($, Inputmask, undefined) {\n    function autoEscape(txt, opts) {\n        for (var escapedTxt = \"\", i = 0; i < txt.length; i++) Inputmask.prototype.definitions[txt.charAt(i)] || opts.definitions[txt.charAt(i)] || opts.optionalmarker.start === txt.charAt(i) || opts.optionalmarker.end === txt.charAt(i) || opts.quantifiermarker.start === txt.charAt(i) || opts.quantifiermarker.end === txt.charAt(i) || opts.groupmarker.start === txt.charAt(i) || opts.groupmarker.end === txt.charAt(i) || opts.alternatormarker === txt.charAt(i) ? escapedTxt += \"\\\\\" + txt.charAt(i) : escapedTxt += txt.charAt(i);\n        return escapedTxt;\n    }\n    return Inputmask.extendAliases({\n        numeric: {\n            mask: function(opts) {\n                if (0 !== opts.repeat && isNaN(opts.integerDigits) && (opts.integerDigits = opts.repeat), \n                opts.repeat = 0, opts.groupSeparator === opts.radixPoint && (\".\" === opts.radixPoint ? opts.groupSeparator = \",\" : \",\" === opts.radixPoint ? opts.groupSeparator = \".\" : opts.groupSeparator = \"\"), \n                \" \" === opts.groupSeparator && (opts.skipOptionalPartCharacter = undefined), opts.autoGroup = opts.autoGroup && \"\" !== opts.groupSeparator, \n                opts.autoGroup && (\"string\" == typeof opts.groupSize && isFinite(opts.groupSize) && (opts.groupSize = parseInt(opts.groupSize)), \n                isFinite(opts.integerDigits))) {\n                    var seps = Math.floor(opts.integerDigits / opts.groupSize), mod = opts.integerDigits % opts.groupSize;\n                    opts.integerDigits = parseInt(opts.integerDigits) + (0 === mod ? seps - 1 : seps), \n                    opts.integerDigits < 1 && (opts.integerDigits = \"*\");\n                }\n                opts.placeholder.length > 1 && (opts.placeholder = opts.placeholder.charAt(0)), \n                \"radixFocus\" === opts.positionCaretOnClick && \"\" === opts.placeholder && !1 === opts.integerOptional && (opts.positionCaretOnClick = \"lvp\"), \n                opts.definitions[\";\"] = opts.definitions[\"~\"], opts.definitions[\";\"].definitionSymbol = \"~\", \n                !0 === opts.numericInput && (opts.positionCaretOnClick = \"radixFocus\" === opts.positionCaretOnClick ? \"lvp\" : opts.positionCaretOnClick, \n                opts.digitsOptional = !1, isNaN(opts.digits) && (opts.digits = 2), opts.decimalProtect = !1);\n                var mask = \"[+]\";\n                if (mask += autoEscape(opts.prefix, opts), !0 === opts.integerOptional ? mask += \"~{1,\" + opts.integerDigits + \"}\" : mask += \"~{\" + opts.integerDigits + \"}\", \n                opts.digits !== undefined) {\n                    opts.radixPointDefinitionSymbol = opts.decimalProtect ? \":\" : opts.radixPoint;\n                    var dq = opts.digits.toString().split(\",\");\n                    isFinite(dq[0] && dq[1] && isFinite(dq[1])) ? mask += opts.radixPointDefinitionSymbol + \";{\" + opts.digits + \"}\" : (isNaN(opts.digits) || parseInt(opts.digits) > 0) && (opts.digitsOptional ? mask += \"[\" + opts.radixPointDefinitionSymbol + \";{1,\" + opts.digits + \"}]\" : mask += opts.radixPointDefinitionSymbol + \";{\" + opts.digits + \"}\");\n                }\n                return mask += autoEscape(opts.suffix, opts), mask += \"[-]\", opts.greedy = !1, mask;\n            },\n            placeholder: \"\",\n            greedy: !1,\n            digits: \"*\",\n            digitsOptional: !0,\n            enforceDigitsOnBlur: !1,\n            radixPoint: \".\",\n            positionCaretOnClick: \"radixFocus\",\n            groupSize: 3,\n            groupSeparator: \"\",\n            autoGroup: !1,\n            allowMinus: !0,\n            negationSymbol: {\n                front: \"-\",\n                back: \"\"\n            },\n            integerDigits: \"+\",\n            integerOptional: !0,\n            prefix: \"\",\n            suffix: \"\",\n            rightAlign: !0,\n            decimalProtect: !0,\n            min: null,\n            max: null,\n            step: 1,\n            insertMode: !0,\n            autoUnmask: !1,\n            unmaskAsNumber: !1,\n            inputmode: \"numeric\",\n            preValidation: function(buffer, pos, c, isSelection, opts) {\n                if (\"-\" === c || c == opts.negationSymbol.front) return !0 === opts.allowMinus && (opts.isNegative = opts.isNegative === undefined || !opts.isNegative, \n                \"\" === buffer.join(\"\") || {\n                    caret: pos,\n                    dopost: !0\n                });\n                if (!1 === isSelection && c === opts.radixPoint && opts.digits !== undefined && (isNaN(opts.digits) || parseInt(opts.digits) > 0)) {\n                    var radixPos = $.inArray(opts.radixPoint, buffer);\n                    if (-1 !== radixPos) return !0 === opts.numericInput ? pos === radixPos : {\n                        caret: radixPos + 1\n                    };\n                }\n                return !0;\n            },\n            postValidation: function(buffer, currentResult, opts) {\n                var suffix = opts.suffix.split(\"\"), prefix = opts.prefix.split(\"\");\n                if (currentResult.pos == undefined && currentResult.caret !== undefined && !0 !== currentResult.dopost) return currentResult;\n                var caretPos = currentResult.caret != undefined ? currentResult.caret : currentResult.pos, maskedValue = buffer.slice();\n                opts.numericInput && (caretPos = maskedValue.length - caretPos - 1, maskedValue = maskedValue.reverse());\n                var charAtPos = maskedValue[caretPos];\n                if (charAtPos === opts.groupSeparator && (caretPos += 1, charAtPos = maskedValue[caretPos]), \n                caretPos == maskedValue.length - opts.suffix.length - 1 && charAtPos === opts.radixPoint) return currentResult;\n                charAtPos !== undefined && charAtPos !== opts.radixPoint && charAtPos !== opts.negationSymbol.front && charAtPos !== opts.negationSymbol.back && (maskedValue[caretPos] = \"?\", \n                opts.prefix.length > 0 && caretPos >= (!1 === opts.isNegative ? 1 : 0) && caretPos < opts.prefix.length - 1 + (!1 === opts.isNegative ? 1 : 0) ? prefix[caretPos - (!1 === opts.isNegative ? 1 : 0)] = \"?\" : opts.suffix.length > 0 && caretPos >= maskedValue.length - opts.suffix.length - (!1 === opts.isNegative ? 1 : 0) && (suffix[caretPos - (maskedValue.length - opts.suffix.length - (!1 === opts.isNegative ? 1 : 0))] = \"?\")), \n                prefix = prefix.join(\"\"), suffix = suffix.join(\"\");\n                var processValue = maskedValue.join(\"\").replace(prefix, \"\");\n                if (processValue = processValue.replace(suffix, \"\"), processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), \"g\"), \"\"), \n                processValue = processValue.replace(new RegExp(\"[-\" + Inputmask.escapeRegex(opts.negationSymbol.front) + \"]\", \"g\"), \"\"), \n                processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.negationSymbol.back) + \"$\"), \"\"), \n                isNaN(opts.placeholder) && (processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.placeholder), \"g\"), \"\")), \n                processValue.length > 1 && 1 !== processValue.indexOf(opts.radixPoint) && (\"0\" == charAtPos && (processValue = processValue.replace(/^\\?/g, \"\")), \n                processValue = processValue.replace(/^0/g, \"\")), processValue.charAt(0) === opts.radixPoint && \"\" !== opts.radixPoint && !0 !== opts.numericInput && (processValue = \"0\" + processValue), \n                \"\" !== processValue) {\n                    if (processValue = processValue.split(\"\"), (!opts.digitsOptional || opts.enforceDigitsOnBlur && \"blur\" === currentResult.event) && isFinite(opts.digits)) {\n                        var radixPosition = $.inArray(opts.radixPoint, processValue), rpb = $.inArray(opts.radixPoint, maskedValue);\n                        -1 === radixPosition && (processValue.push(opts.radixPoint), radixPosition = processValue.length - 1);\n                        for (var i = 1; i <= opts.digits; i++) opts.digitsOptional && (!opts.enforceDigitsOnBlur || \"blur\" !== currentResult.event) || processValue[radixPosition + i] !== undefined && processValue[radixPosition + i] !== opts.placeholder.charAt(0) ? -1 !== rpb && maskedValue[rpb + i] !== undefined && (processValue[radixPosition + i] = processValue[radixPosition + i] || maskedValue[rpb + i]) : processValue[radixPosition + i] = currentResult.placeholder || opts.placeholder.charAt(0);\n                    }\n                    !0 !== opts.autoGroup || \"\" === opts.groupSeparator || charAtPos === opts.radixPoint && currentResult.pos === undefined && !currentResult.dopost ? processValue = processValue.join(\"\") : (processValue = Inputmask(function(buffer, opts) {\n                        var postMask = \"\";\n                        if (postMask += \"(\" + opts.groupSeparator + \"*{\" + opts.groupSize + \"}){*}\", \"\" !== opts.radixPoint) {\n                            var radixSplit = buffer.join(\"\").split(opts.radixPoint);\n                            radixSplit[1] && (postMask += opts.radixPoint + \"*{\" + radixSplit[1].match(/^\\d*\\??\\d*/)[0].length + \"}\");\n                        }\n                        return postMask;\n                    }(processValue, opts), {\n                        numericInput: !0,\n                        jitMasking: !0,\n                        definitions: {\n                            \"*\": {\n                                validator: \"[0-9?]\",\n                                cardinality: 1\n                            }\n                        }\n                    }).format(processValue.join(\"\")), processValue.charAt(0) === opts.groupSeparator && processValue.substr(1));\n                }\n                if (opts.isNegative && \"blur\" === currentResult.event && (opts.isNegative = \"0\" !== processValue), \n                processValue = prefix + processValue, processValue += suffix, opts.isNegative && (processValue = opts.negationSymbol.front + processValue, \n                processValue += opts.negationSymbol.back), processValue = processValue.split(\"\"), \n                charAtPos !== undefined) if (charAtPos !== opts.radixPoint && charAtPos !== opts.negationSymbol.front && charAtPos !== opts.negationSymbol.back) caretPos = $.inArray(\"?\", processValue), \n                caretPos > -1 ? processValue[caretPos] = charAtPos : caretPos = currentResult.caret || 0; else if (charAtPos === opts.radixPoint || charAtPos === opts.negationSymbol.front || charAtPos === opts.negationSymbol.back) {\n                    var newCaretPos = $.inArray(charAtPos, processValue);\n                    -1 !== newCaretPos && (caretPos = newCaretPos);\n                }\n                opts.numericInput && (caretPos = processValue.length - caretPos - 1, processValue = processValue.reverse());\n                var rslt = {\n                    caret: charAtPos === undefined || currentResult.pos !== undefined ? caretPos + (opts.numericInput ? -1 : 1) : caretPos,\n                    buffer: processValue,\n                    refreshFromBuffer: currentResult.dopost || buffer.join(\"\") !== processValue.join(\"\")\n                };\n                return rslt.refreshFromBuffer ? rslt : currentResult;\n            },\n            onBeforeWrite: function(e, buffer, caretPos, opts) {\n                if (e) switch (e.type) {\n                  case \"keydown\":\n                    return opts.postValidation(buffer, {\n                        caret: caretPos,\n                        dopost: !0\n                    }, opts);\n\n                  case \"blur\":\n                  case \"checkval\":\n                    var unmasked;\n                    if (function(opts) {\n                        opts.parseMinMaxOptions === undefined && (null !== opts.min && (opts.min = opts.min.toString().replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), \"g\"), \"\"), \n                        \",\" === opts.radixPoint && (opts.min = opts.min.replace(opts.radixPoint, \".\")), \n                        opts.min = isFinite(opts.min) ? parseFloat(opts.min) : NaN, isNaN(opts.min) && (opts.min = Number.MIN_VALUE)), \n                        null !== opts.max && (opts.max = opts.max.toString().replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), \"g\"), \"\"), \n                        \",\" === opts.radixPoint && (opts.max = opts.max.replace(opts.radixPoint, \".\")), \n                        opts.max = isFinite(opts.max) ? parseFloat(opts.max) : NaN, isNaN(opts.max) && (opts.max = Number.MAX_VALUE)), \n                        opts.parseMinMaxOptions = \"done\");\n                    }(opts), null !== opts.min || null !== opts.max) {\n                        if (unmasked = opts.onUnMask(buffer.join(\"\"), undefined, $.extend({}, opts, {\n                            unmaskAsNumber: !0\n                        })), null !== opts.min && unmasked < opts.min) return opts.isNegative = opts.min < 0, \n                        opts.postValidation(opts.min.toString().replace(\".\", opts.radixPoint).split(\"\"), {\n                            caret: caretPos,\n                            dopost: !0,\n                            placeholder: \"0\"\n                        }, opts);\n                        if (null !== opts.max && unmasked > opts.max) return opts.isNegative = opts.max < 0, \n                        opts.postValidation(opts.max.toString().replace(\".\", opts.radixPoint).split(\"\"), {\n                            caret: caretPos,\n                            dopost: !0,\n                            placeholder: \"0\"\n                        }, opts);\n                    }\n                    return opts.postValidation(buffer, {\n                        caret: caretPos,\n                        dopost: !0,\n                        placeholder: \"0\",\n                        event: \"blur\"\n                    }, opts);\n\n                  case \"_checkval\":\n                    return {\n                        caret: caretPos\n                    };\n                }\n            },\n            regex: {\n                integerPart: function(opts, emptyCheck) {\n                    return emptyCheck ? new RegExp(\"[\" + Inputmask.escapeRegex(opts.negationSymbol.front) + \"+]?\") : new RegExp(\"[\" + Inputmask.escapeRegex(opts.negationSymbol.front) + \"+]?\\\\d+\");\n                },\n                integerNPart: function(opts) {\n                    return new RegExp(\"[\\\\d\" + Inputmask.escapeRegex(opts.groupSeparator) + Inputmask.escapeRegex(opts.placeholder.charAt(0)) + \"]+\");\n                }\n            },\n            definitions: {\n                \"~\": {\n                    validator: function(chrs, maskset, pos, strict, opts, isSelection) {\n                        var isValid = strict ? new RegExp(\"[0-9\" + Inputmask.escapeRegex(opts.groupSeparator) + \"]\").test(chrs) : new RegExp(\"[0-9]\").test(chrs);\n                        if (!0 === isValid) {\n                            if (!0 !== opts.numericInput && maskset.validPositions[pos] !== undefined && \"~\" === maskset.validPositions[pos].match.def && !isSelection) {\n                                var processValue = maskset.buffer.join(\"\");\n                                processValue = processValue.replace(new RegExp(\"[-\" + Inputmask.escapeRegex(opts.negationSymbol.front) + \"]\", \"g\"), \"\"), \n                                processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.negationSymbol.back) + \"$\"), \"\");\n                                var pvRadixSplit = processValue.split(opts.radixPoint);\n                                pvRadixSplit.length > 1 && (pvRadixSplit[1] = pvRadixSplit[1].replace(/0/g, opts.placeholder.charAt(0))), \n                                \"0\" === pvRadixSplit[0] && (pvRadixSplit[0] = pvRadixSplit[0].replace(/0/g, opts.placeholder.charAt(0))), \n                                processValue = pvRadixSplit[0] + opts.radixPoint + pvRadixSplit[1] || \"\";\n                                var bufferTemplate = maskset._buffer.join(\"\");\n                                for (processValue === opts.radixPoint && (processValue = bufferTemplate); null === processValue.match(Inputmask.escapeRegex(bufferTemplate) + \"$\"); ) bufferTemplate = bufferTemplate.slice(1);\n                                processValue = processValue.replace(bufferTemplate, \"\"), processValue = processValue.split(\"\"), \n                                isValid = processValue[pos] === undefined ? {\n                                    pos: pos,\n                                    remove: pos\n                                } : {\n                                    pos: pos\n                                };\n                            }\n                        } else strict || chrs !== opts.radixPoint || maskset.validPositions[pos - 1] !== undefined || (maskset.buffer[pos] = \"0\", \n                        isValid = {\n                            pos: pos + 1\n                        });\n                        return isValid;\n                    },\n                    cardinality: 1\n                },\n                \"+\": {\n                    validator: function(chrs, maskset, pos, strict, opts) {\n                        return opts.allowMinus && (\"-\" === chrs || chrs === opts.negationSymbol.front);\n                    },\n                    cardinality: 1,\n                    placeholder: \"\"\n                },\n                \"-\": {\n                    validator: function(chrs, maskset, pos, strict, opts) {\n                        return opts.allowMinus && chrs === opts.negationSymbol.back;\n                    },\n                    cardinality: 1,\n                    placeholder: \"\"\n                },\n                \":\": {\n                    validator: function(chrs, maskset, pos, strict, opts) {\n                        var radix = \"[\" + Inputmask.escapeRegex(opts.radixPoint) + \"]\", isValid = new RegExp(radix).test(chrs);\n                        return isValid && maskset.validPositions[pos] && maskset.validPositions[pos].match.placeholder === opts.radixPoint && (isValid = {\n                            caret: pos + 1\n                        }), isValid;\n                    },\n                    cardinality: 1,\n                    placeholder: function(opts) {\n                        return opts.radixPoint;\n                    }\n                }\n            },\n            onUnMask: function(maskedValue, unmaskedValue, opts) {\n                if (\"\" === unmaskedValue && !0 === opts.nullable) return unmaskedValue;\n                var processValue = maskedValue.replace(opts.prefix, \"\");\n                return processValue = processValue.replace(opts.suffix, \"\"), processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), \"g\"), \"\"), \n                \"\" !== opts.placeholder.charAt(0) && (processValue = processValue.replace(new RegExp(opts.placeholder.charAt(0), \"g\"), \"0\")), \n                opts.unmaskAsNumber ? (\"\" !== opts.radixPoint && -1 !== processValue.indexOf(opts.radixPoint) && (processValue = processValue.replace(Inputmask.escapeRegex.call(this, opts.radixPoint), \".\")), \n                processValue = processValue.replace(new RegExp(\"^\" + Inputmask.escapeRegex(opts.negationSymbol.front)), \"-\"), \n                processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.negationSymbol.back) + \"$\"), \"\"), \n                Number(processValue)) : processValue;\n            },\n            isComplete: function(buffer, opts) {\n                var maskedValue = buffer.join(\"\");\n                if (buffer.slice().join(\"\") !== maskedValue) return !1;\n                var processValue = maskedValue.replace(opts.prefix, \"\");\n                return processValue = processValue.replace(opts.suffix, \"\"), processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), \"g\"), \"\"), \n                \",\" === opts.radixPoint && (processValue = processValue.replace(Inputmask.escapeRegex(opts.radixPoint), \".\")), \n                isFinite(processValue);\n            },\n            onBeforeMask: function(initialValue, opts) {\n                if (opts.isNegative = undefined, initialValue = initialValue.toString().charAt(initialValue.length - 1) === opts.radixPoint ? initialValue.toString().substr(0, initialValue.length - 1) : initialValue.toString(), \n                \"\" !== opts.radixPoint && isFinite(initialValue)) {\n                    var vs = initialValue.split(\".\"), groupSize = \"\" !== opts.groupSeparator ? parseInt(opts.groupSize) : 0;\n                    2 === vs.length && (vs[0].length > groupSize || vs[1].length > groupSize || vs[0].length <= groupSize && vs[1].length < groupSize) && (initialValue = initialValue.replace(\".\", opts.radixPoint));\n                }\n                var kommaMatches = initialValue.match(/,/g), dotMatches = initialValue.match(/\\./g);\n                if (dotMatches && kommaMatches ? dotMatches.length > kommaMatches.length ? (initialValue = initialValue.replace(/\\./g, \"\"), \n                initialValue = initialValue.replace(\",\", opts.radixPoint)) : kommaMatches.length > dotMatches.length ? (initialValue = initialValue.replace(/,/g, \"\"), \n                initialValue = initialValue.replace(\".\", opts.radixPoint)) : initialValue = initialValue.indexOf(\".\") < initialValue.indexOf(\",\") ? initialValue.replace(/\\./g, \"\") : initialValue = initialValue.replace(/,/g, \"\") : initialValue = initialValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), \"g\"), \"\"), \n                0 === opts.digits && (-1 !== initialValue.indexOf(\".\") ? initialValue = initialValue.substring(0, initialValue.indexOf(\".\")) : -1 !== initialValue.indexOf(\",\") && (initialValue = initialValue.substring(0, initialValue.indexOf(\",\")))), \n                \"\" !== opts.radixPoint && isFinite(opts.digits) && -1 !== initialValue.indexOf(opts.radixPoint)) {\n                    var valueParts = initialValue.split(opts.radixPoint), decPart = valueParts[1].match(new RegExp(\"\\\\d*\"))[0];\n                    if (parseInt(opts.digits) < decPart.toString().length) {\n                        var digitsFactor = Math.pow(10, parseInt(opts.digits));\n                        initialValue = initialValue.replace(Inputmask.escapeRegex(opts.radixPoint), \".\"), \n                        initialValue = Math.round(parseFloat(initialValue) * digitsFactor) / digitsFactor, \n                        initialValue = initialValue.toString().replace(\".\", opts.radixPoint);\n                    }\n                }\n                return initialValue;\n            },\n            canClearPosition: function(maskset, position, lvp, strict, opts) {\n                var vp = maskset.validPositions[position], canClear = vp.input !== opts.radixPoint || null !== maskset.validPositions[position].match.fn && !1 === opts.decimalProtect || vp.input === opts.radixPoint && maskset.validPositions[position + 1] && null === maskset.validPositions[position + 1].match.fn || isFinite(vp.input) || position === lvp || vp.input === opts.groupSeparator || vp.input === opts.negationSymbol.front || vp.input === opts.negationSymbol.back;\n                return !canClear || \"+\" != vp.match.nativeDef && \"-\" != vp.match.nativeDef || (opts.isNegative = !1), \n                canClear;\n            },\n            onKeyDown: function(e, buffer, caretPos, opts) {\n                var $input = $(this);\n                if (e.ctrlKey) switch (e.keyCode) {\n                  case Inputmask.keyCode.UP:\n                    $input.val(parseFloat(this.inputmask.unmaskedvalue()) + parseInt(opts.step)), $input.trigger(\"setvalue\");\n                    break;\n\n                  case Inputmask.keyCode.DOWN:\n                    $input.val(parseFloat(this.inputmask.unmaskedvalue()) - parseInt(opts.step)), $input.trigger(\"setvalue\");\n                }\n            }\n        },\n        currency: {\n            prefix: \"$ \",\n            groupSeparator: \",\",\n            alias: \"numeric\",\n            placeholder: \"0\",\n            autoGroup: !0,\n            digits: 2,\n            digitsOptional: !1,\n            clearMaskOnLostFocus: !1\n        },\n        decimal: {\n            alias: \"numeric\"\n        },\n        integer: {\n            alias: \"numeric\",\n            digits: 0,\n            radixPoint: \"\"\n        },\n        percentage: {\n            alias: \"numeric\",\n            digits: 2,\n            digitsOptional: !0,\n            radixPoint: \".\",\n            placeholder: \"0\",\n            autoGroup: !1,\n            min: 0,\n            max: 100,\n            suffix: \" %\",\n            allowMinus: !1\n        }\n    }), Inputmask;\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/inputmask/dist/inputmask/inputmask.numeric.extensions.js\n// module id = 15\n// module chunks = 0","/*!\n* inputmask.phone.extensions.js\n* https://github.com/RobinHerbots/Inputmask\n* Copyright (c) 2010 - 2017 Robin Herbots\n* Licensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)\n* Version: 3.3.7\n*/\n\n!function(factory) {\n    \"function\" == typeof define && define.amd ? define([ \"./dependencyLibs/inputmask.dependencyLib\", \"./inputmask\" ], factory) : \"object\" == typeof exports ? module.exports = factory(require(\"./dependencyLibs/inputmask.dependencyLib\"), require(\"./inputmask\")) : factory(window.dependencyLib || jQuery, window.Inputmask);\n}(function($, Inputmask) {\n    function maskSort(a, b) {\n        var maska = (a.mask || a).replace(/#/g, \"9\").replace(/\\)/, \"9\").replace(/[+()#-]/g, \"\"), maskb = (b.mask || b).replace(/#/g, \"9\").replace(/\\)/, \"9\").replace(/[+()#-]/g, \"\"), maskas = (a.mask || a).split(\"#\")[0], maskbs = (b.mask || b).split(\"#\")[0];\n        return 0 === maskbs.indexOf(maskas) ? -1 : 0 === maskas.indexOf(maskbs) ? 1 : maska.localeCompare(maskb);\n    }\n    var analyseMaskBase = Inputmask.prototype.analyseMask;\n    return Inputmask.prototype.analyseMask = function(mask, regexMask, opts) {\n        function reduceVariations(masks, previousVariation, previousmaskGroup) {\n            previousVariation = previousVariation || \"\", previousmaskGroup = previousmaskGroup || maskGroups, \n            \"\" !== previousVariation && (previousmaskGroup[previousVariation] = {});\n            for (var variation = \"\", maskGroup = previousmaskGroup[previousVariation] || previousmaskGroup, i = masks.length - 1; i >= 0; i--) mask = masks[i].mask || masks[i], \n            variation = mask.substr(0, 1), maskGroup[variation] = maskGroup[variation] || [], \n            maskGroup[variation].unshift(mask.substr(1)), masks.splice(i, 1);\n            for (var ndx in maskGroup) maskGroup[ndx].length > 500 && reduceVariations(maskGroup[ndx].slice(), ndx, maskGroup);\n        }\n        function rebuild(maskGroup) {\n            var mask = \"\", submasks = [];\n            for (var ndx in maskGroup) $.isArray(maskGroup[ndx]) ? 1 === maskGroup[ndx].length ? submasks.push(ndx + maskGroup[ndx]) : submasks.push(ndx + opts.groupmarker.start + maskGroup[ndx].join(opts.groupmarker.end + opts.alternatormarker + opts.groupmarker.start) + opts.groupmarker.end) : submasks.push(ndx + rebuild(maskGroup[ndx]));\n            return 1 === submasks.length ? mask += submasks[0] : mask += opts.groupmarker.start + submasks.join(opts.groupmarker.end + opts.alternatormarker + opts.groupmarker.start) + opts.groupmarker.end, \n            mask;\n        }\n        var maskGroups = {};\n        return opts.phoneCodes && (opts.phoneCodes && opts.phoneCodes.length > 1e3 && (mask = mask.substr(1, mask.length - 2), \n        reduceVariations(mask.split(opts.groupmarker.end + opts.alternatormarker + opts.groupmarker.start)), \n        mask = rebuild(maskGroups)), mask = mask.replace(/9/g, \"\\\\9\")), analyseMaskBase.call(this, mask, regexMask, opts);\n    }, Inputmask.extendAliases({\n        abstractphone: {\n            groupmarker: {\n                start: \"<\",\n                end: \">\"\n            },\n            countrycode: \"\",\n            phoneCodes: [],\n            mask: function(opts) {\n                return opts.definitions = {\n                    \"#\": Inputmask.prototype.definitions[9]\n                }, opts.phoneCodes.sort(maskSort);\n            },\n            keepStatic: !0,\n            onBeforeMask: function(value, opts) {\n                var processedValue = value.replace(/^0{1,2}/, \"\").replace(/[\\s]/g, \"\");\n                return (processedValue.indexOf(opts.countrycode) > 1 || -1 === processedValue.indexOf(opts.countrycode)) && (processedValue = \"+\" + opts.countrycode + processedValue), \n                processedValue;\n            },\n            onUnMask: function(maskedValue, unmaskedValue, opts) {\n                return maskedValue.replace(/[()#-]/g, \"\");\n            },\n            inputmode: \"tel\"\n        }\n    }), Inputmask;\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/inputmask/dist/inputmask/inputmask.phone.extensions.js\n// module id = 16\n// module chunks = 0","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/process/browser.js\n// module id = 17\n// module chunks = 0","(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/setimmediate/setImmediate.js\n// module id = 18\n// module chunks = 0","var apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\nrequire(\"setimmediate\");\nexports.setImmediate = setImmediate;\nexports.clearImmediate = clearImmediate;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/timers-browserify/main.js\n// module id = 19\n// module chunks = 0"],"sourceRoot":""}